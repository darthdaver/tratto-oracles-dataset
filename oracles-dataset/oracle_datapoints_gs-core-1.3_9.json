[ {
  "id" : 3483,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceXML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * Open a new xml events stream.\n\t * \n\t * @param stream\n\t * @throws IOException\n\t */",
  "methodSourceCode" : "protected void openStream(Reader stream) throws IOException{\n    if (reader != null)\n        closeStream();\n    try {\n        XMLEvent e;\n        reader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n        e = getNextEvent();\n        checkValid(e, XMLEvent.START_DOCUMENT, null);\n        afterStartDocument();\n    } catch (XMLStreamException e) {\n        throw new IOException(e);\n    } catch (FactoryConfigurationError e) {\n        throw new IOException(e);\n    }\n}",
  "classJavadoc" : "/**\n * Base for XML-based file format. It uses an xml events stream (\n * {@link javax.xml.streams}). One who want to define a new xml-based fiel\n * source has to define actions after the document start and before the document\n * end. The {@link #nextEvents()}, called between start and end, has to be\n * defined too.\n * \n * @author Guilhelm Savin\n * \n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.EnumMap;\nimport java.util.Iterator;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.StartElement;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * Base for XML-based file format. It uses an xml events stream (\n * {@link javax.xml.streams}). One who want to define a new xml-based fiel\n * source has to define actions after the document start and before the document\n * end. The {@link #nextEvents()}, called between start and end, has to be\n * defined too.\n * \n * @author Guilhelm Savin\n * \n */\npublic abstract class FileSourceXML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\t/**\n\t * XML events stream. Should not be used directly but with\n\t * {@link #getNextEvent()}.\n\t */\n\tprotected XMLEventReader reader;\n\t/*\n\t * Used to allow 'pushback' of events.\n\t */\n\tprivate Stack<XMLEvent> events;\n\n\tprotected FileSourceXML() {\n\t\tevents = new Stack<XMLEvent>();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/**\n\t * Called after the event\n\t * {@link javax.xml.stream.events.XMLEvent.START_DOCUMENT} has been\n\t * received.\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprotected abstract void afterStartDocument() throws IOException,\n\t\t\tXMLStreamException;\n\n\t/**\n\t * Called before trying to receive the events\n\t * {@link javax.xml.stream.event.END_DOCUMENT}.\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprotected abstract void beforeEndDocument() throws IOException,\n\t\t\tXMLStreamException;\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic abstract boolean nextEvents() throws IOException;\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\t/**\n\t * Get a new event from the stream. This method has to be used to allow the\n\t * {@link #pushback(XMLEvent)} method to work.\n\t * \n\t * @return the next event in the stream\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\t/**\n\t * Pushback an event in the stream.\n\t * \n\t * @param e\n\t *            the event\n\t */\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\t/**\n\t * Generate a new parse exception.\n\t * \n\t * @param e\n\t *            event producing an error\n\t * @param msg\n\t *            message to put in the exception\n\t * @param args\n\t *            arguments of the message\n\t * @return a new parse exception\n\t */\n\tprotected XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\t/**\n\t * Check is an event has an expected type and name.\n\t * \n\t * @param e\n\t *            event to check\n\t * @param type\n\t *            expected type\n\t * @param name\n\t *            expected name\n\t * @return true is type and name are valid\n\t */\n\tprotected boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\t/**\n\t * Check is the event has valid type and name. If not, a new exception is\n\t * thrown.\n\t * \n\t * @param e\n\t *            event to check\n\t * @param type\n\t *            expected type\n\t * @param name\n\t *            expected name\n\t * @throws XMLStreamException\n\t *             if event has invalid type or name\n\t */\n\tprotected void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\t/**\n\t * Open a new xml events stream.\n\t * \n\t * @param stream\n\t * @throws IOException\n\t */\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t\tafterStartDocument();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Close the current opened stream.\n\t * \n\t * @throws IOException\n\t */\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\tbeforeEndDocument();\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\t/**\n\t * Convert an attribute to a valid constant name.\n\t * \n\t * @see #toConstantName(String)\n\t * @param a\n\t * @return\n\t */\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\t/**\n\t * Convert a string to a valid constant name. String is put to upper case\n\t * and all non-word characters are replaced by '_'.\n\t * \n\t * @param value\n\t * @return\n\t */\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * Base for parsers, providing some usefull features.\n\t * \n\t */\n\tprotected class Parser {\n\t\t/**\n\t\t * Read a sequence of characters and return these characters as a\n\t\t * string. Characters are read until a non-character event is reached.\n\t\t * \n\t\t * @return a sequence of characters\n\t\t * @throws IOException\n\t\t * @throws XMLStreamException\n\t\t */\n\t\tprotected String __characters() throws IOException, XMLStreamException {\n\t\t\tXMLEvent e;\n\t\t\tStringBuilder buffer = new StringBuilder();\n\n\t\t\te = getNextEvent();\n\n\t\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\t\tbuffer.append(e.asCharacters());\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\n\t\t\tpushback(e);\n\n\t\t\treturn buffer.toString();\n\t\t}\n\n\t\t/**\n\t\t * Get attributes of a start element in a map. Attributes should be\n\t\t * described in an enumeration such that\n\t\t * {@link FileSourceXML#toConstantName(Attribute)} correspond to names\n\t\t * of enumeration constants.\n\t\t * \n\t\t * @param <T>\n\t\t *            type of the enumeration describing attributes\n\t\t * @param cls\n\t\t *            class of the enumeration T\n\t\t * @param e\n\t\t *            start event from which attributes have to be extracted\n\t\t * @return a mapping between enum constants and attribute values.\n\t\t */\n\t\tprotected <T extends Enum<T>> EnumMap<T, String> getAttributes(\n\t\t\t\tClass<T> cls, StartElement e) {\n\t\t\tEnumMap<T, String> values = new EnumMap<T, String>(cls);\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t\t.getAttributes();\n\n\t\t\twhile (attributes.hasNext()) {\n\t\t\t\tAttribute a = attributes.next();\n\n\t\t\t\tfor (int i = 0; i < cls.getEnumConstants().length; i++) {\n\t\t\t\t\tif (cls.getEnumConstants()[i].name().equals(\n\t\t\t\t\t\t\ttoConstantName(a))) {\n\t\t\t\t\t\tvalues.put(cls.getEnumConstants()[i], a.getValue());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn values;\n\t\t}\n\n\t\t/**\n\t\t * Check if all required attributes are present.\n\t\t * \n\t\t * @param <T>\n\t\t *            type of the enumeration describing attributes\n\t\t * @param e\n\t\t *            the event\n\t\t * @param attributes\n\t\t *            extracted attributes\n\t\t * @param required\n\t\t *            array of required attributes\n\t\t * @throws XMLStreamException\n\t\t *             if at least one required attribute is not found\n\t\t */\n\t\tprotected <T extends Enum<T>> void checkRequiredAttributes(XMLEvent e,\n\t\t\t\tEnumMap<T, String> attributes, T... required)\n\t\t\t\tthrows XMLStreamException {\n\t\t\tif (required != null) {\n\t\t\t\tfor (int i = 0; i < required.length; i++) {\n\t\t\t\t\tif (!attributes.containsKey(required[i]))\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"'%s' attribute is required for <%s> element\",\n\t\t\t\t\t\t\t\trequired[i].name().toLowerCase(), e\n\t\t\t\t\t\t\t\t\t\t.asStartElement().getName()\n\t\t\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "stream", "java.io", "Reader" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "isEvent", "org.graphstream.stream.file", "FileSourceXML", "protected boolean isEvent(XMLEvent e, int type, String name)" ], [ "newParseError", "org.graphstream.stream.file", "FileSourceXML", "protected XMLStreamException newParseError(XMLEvent e, String msg, Object... args)" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceXML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceXML", "public boolean nextStep() throws IOException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceXML", "protected String toConstantName(String value)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceXML", "protected String toConstantName(Attribute a)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceXML", "public abstract boolean nextEvents() throws IOException" ], [ "read", "java.io", "Reader", "public int read(char[] arg0) throws IOException" ], [ "markSupported", "java.io", "Reader", "public boolean markSupported()" ], [ "read", "java.io", "Reader", "public int read(CharBuffer arg0) throws IOException" ], [ "skip", "java.io", "Reader", "public long skip(long arg0) throws IOException" ], [ "transferTo", "java.io", "Reader", "public long transferTo(Writer arg0) throws IOException" ], [ "ready", "java.io", "Reader", "public boolean ready() throws IOException" ], [ "read", "java.io", "Reader", "public int read() throws IOException" ], [ "read", "java.io", "Reader", "public abstract int read(char[] arg0, int arg1, int arg2) throws IOException" ], [ "read", "java.lang", "Readable", "public abstract int read(CharBuffer arg0) throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceXML", "protected XMLEventReader reader;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ], [ "lock", "java.io", "Reader", "protected Object lock;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3484,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceXML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * Close the current opened stream.\n\t * \n\t * @throws IOException\n\t */",
  "methodSourceCode" : "protected void closeStream() throws IOException{\n    try {\n        beforeEndDocument();\n        reader.close();\n    } catch (XMLStreamException e) {\n        throw new IOException(e);\n    } finally {\n        reader = null;\n    }\n}",
  "classJavadoc" : "/**\n * Base for XML-based file format. It uses an xml events stream (\n * {@link javax.xml.streams}). One who want to define a new xml-based fiel\n * source has to define actions after the document start and before the document\n * end. The {@link #nextEvents()}, called between start and end, has to be\n * defined too.\n * \n * @author Guilhelm Savin\n * \n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.EnumMap;\nimport java.util.Iterator;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.StartElement;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * Base for XML-based file format. It uses an xml events stream (\n * {@link javax.xml.streams}). One who want to define a new xml-based fiel\n * source has to define actions after the document start and before the document\n * end. The {@link #nextEvents()}, called between start and end, has to be\n * defined too.\n * \n * @author Guilhelm Savin\n * \n */\npublic abstract class FileSourceXML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\t/**\n\t * XML events stream. Should not be used directly but with\n\t * {@link #getNextEvent()}.\n\t */\n\tprotected XMLEventReader reader;\n\t/*\n\t * Used to allow 'pushback' of events.\n\t */\n\tprivate Stack<XMLEvent> events;\n\n\tprotected FileSourceXML() {\n\t\tevents = new Stack<XMLEvent>();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/**\n\t * Called after the event\n\t * {@link javax.xml.stream.events.XMLEvent.START_DOCUMENT} has been\n\t * received.\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprotected abstract void afterStartDocument() throws IOException,\n\t\t\tXMLStreamException;\n\n\t/**\n\t * Called before trying to receive the events\n\t * {@link javax.xml.stream.event.END_DOCUMENT}.\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprotected abstract void beforeEndDocument() throws IOException,\n\t\t\tXMLStreamException;\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic abstract boolean nextEvents() throws IOException;\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\t/**\n\t * Get a new event from the stream. This method has to be used to allow the\n\t * {@link #pushback(XMLEvent)} method to work.\n\t * \n\t * @return the next event in the stream\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\t/**\n\t * Pushback an event in the stream.\n\t * \n\t * @param e\n\t *            the event\n\t */\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\t/**\n\t * Generate a new parse exception.\n\t * \n\t * @param e\n\t *            event producing an error\n\t * @param msg\n\t *            message to put in the exception\n\t * @param args\n\t *            arguments of the message\n\t * @return a new parse exception\n\t */\n\tprotected XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\t/**\n\t * Check is an event has an expected type and name.\n\t * \n\t * @param e\n\t *            event to check\n\t * @param type\n\t *            expected type\n\t * @param name\n\t *            expected name\n\t * @return true is type and name are valid\n\t */\n\tprotected boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\t/**\n\t * Check is the event has valid type and name. If not, a new exception is\n\t * thrown.\n\t * \n\t * @param e\n\t *            event to check\n\t * @param type\n\t *            expected type\n\t * @param name\n\t *            expected name\n\t * @throws XMLStreamException\n\t *             if event has invalid type or name\n\t */\n\tprotected void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\t/**\n\t * Open a new xml events stream.\n\t * \n\t * @param stream\n\t * @throws IOException\n\t */\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t\tafterStartDocument();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Close the current opened stream.\n\t * \n\t * @throws IOException\n\t */\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\tbeforeEndDocument();\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\t/**\n\t * Convert an attribute to a valid constant name.\n\t * \n\t * @see #toConstantName(String)\n\t * @param a\n\t * @return\n\t */\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\t/**\n\t * Convert a string to a valid constant name. String is put to upper case\n\t * and all non-word characters are replaced by '_'.\n\t * \n\t * @param value\n\t * @return\n\t */\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * Base for parsers, providing some usefull features.\n\t * \n\t */\n\tprotected class Parser {\n\t\t/**\n\t\t * Read a sequence of characters and return these characters as a\n\t\t * string. Characters are read until a non-character event is reached.\n\t\t * \n\t\t * @return a sequence of characters\n\t\t * @throws IOException\n\t\t * @throws XMLStreamException\n\t\t */\n\t\tprotected String __characters() throws IOException, XMLStreamException {\n\t\t\tXMLEvent e;\n\t\t\tStringBuilder buffer = new StringBuilder();\n\n\t\t\te = getNextEvent();\n\n\t\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\t\tbuffer.append(e.asCharacters());\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\n\t\t\tpushback(e);\n\n\t\t\treturn buffer.toString();\n\t\t}\n\n\t\t/**\n\t\t * Get attributes of a start element in a map. Attributes should be\n\t\t * described in an enumeration such that\n\t\t * {@link FileSourceXML#toConstantName(Attribute)} correspond to names\n\t\t * of enumeration constants.\n\t\t * \n\t\t * @param <T>\n\t\t *            type of the enumeration describing attributes\n\t\t * @param cls\n\t\t *            class of the enumeration T\n\t\t * @param e\n\t\t *            start event from which attributes have to be extracted\n\t\t * @return a mapping between enum constants and attribute values.\n\t\t */\n\t\tprotected <T extends Enum<T>> EnumMap<T, String> getAttributes(\n\t\t\t\tClass<T> cls, StartElement e) {\n\t\t\tEnumMap<T, String> values = new EnumMap<T, String>(cls);\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t\t.getAttributes();\n\n\t\t\twhile (attributes.hasNext()) {\n\t\t\t\tAttribute a = attributes.next();\n\n\t\t\t\tfor (int i = 0; i < cls.getEnumConstants().length; i++) {\n\t\t\t\t\tif (cls.getEnumConstants()[i].name().equals(\n\t\t\t\t\t\t\ttoConstantName(a))) {\n\t\t\t\t\t\tvalues.put(cls.getEnumConstants()[i], a.getValue());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn values;\n\t\t}\n\n\t\t/**\n\t\t * Check if all required attributes are present.\n\t\t * \n\t\t * @param <T>\n\t\t *            type of the enumeration describing attributes\n\t\t * @param e\n\t\t *            the event\n\t\t * @param attributes\n\t\t *            extracted attributes\n\t\t * @param required\n\t\t *            array of required attributes\n\t\t * @throws XMLStreamException\n\t\t *             if at least one required attribute is not found\n\t\t */\n\t\tprotected <T extends Enum<T>> void checkRequiredAttributes(XMLEvent e,\n\t\t\t\tEnumMap<T, String> attributes, T... required)\n\t\t\t\tthrows XMLStreamException {\n\t\t\tif (required != null) {\n\t\t\t\tfor (int i = 0; i < required.length; i++) {\n\t\t\t\t\tif (!attributes.containsKey(required[i]))\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"'%s' attribute is required for <%s> element\",\n\t\t\t\t\t\t\t\trequired[i].name().toLowerCase(), e\n\t\t\t\t\t\t\t\t\t\t.asStartElement().getName()\n\t\t\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "isEvent", "org.graphstream.stream.file", "FileSourceXML", "protected boolean isEvent(XMLEvent e, int type, String name)" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceXML", "public boolean nextStep() throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "newParseError", "org.graphstream.stream.file", "FileSourceXML", "protected XMLStreamException newParseError(XMLEvent e, String msg, Object... args)" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceXML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceXML", "protected String toConstantName(Attribute a)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceXML", "protected String toConstantName(String value)" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceXML", "public abstract boolean nextEvents() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceXML", "protected XMLEventReader reader;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3501,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSinkBaseFiltered",
  "javadocTag" : "@return the list of every edge attributes filtered",
  "methodJavadoc" : "    /**\n\t * @return the list of every edge attributes filtered\n\t */",
  "methodSourceCode" : "public ArrayList<String> getEdgeAttributesFiltered(){\n    return edgeAttributesFiltered;\n}",
  "classJavadoc" : "/**\n * Base implementation for filtered graph output to files.\n * \n * <p>\n * This class provides the list of possible filters which could be used by the final user to write graphs into files using a specific file format. \n * Thus, it allows to create an output stream where the dynamic events of addition/deletion/modification can be filtered.\n * </p>\n * \n * <p>\n * Since it extends FileSinkBase, you have to override the same methods in order to implement an output.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.util.ArrayList;\n\nimport org.graphstream.stream.file.FileSinkBase;\n\n/**\n * Base implementation for filtered graph output to files.\n * \n * <p>\n * This class provides the list of possible filters which could be used by the final user to write graphs into files using a specific file format. \n * Thus, it allows to create an output stream where the dynamic events of addition/deletion/modification can be filtered.\n * </p>\n * \n * <p>\n * Since it extends FileSinkBase, you have to override the same methods in order to implement an output.\n * </p>\n */\npublic abstract class FileSinkBaseFiltered extends FileSinkBase {\n\t/*\n\t * List of possible filters\n\t */\n\tprotected boolean noFilterGraphAttributeAdded;\n\tprotected boolean noFilterGraphAttributeChanged;\n\tprotected boolean noFilterGraphAttributeRemoved;\n\tprotected boolean noFilterNodeAttributeAdded;\n\tprotected boolean noFilterNodeAttributeChanged;\n\tprotected boolean noFilterNodeAttributeRemoved;\n\tprotected boolean noFilterNodeAdded;\n\tprotected boolean noFilterNodeRemoved;\n\tprotected boolean noFilterEdgeAttributeAdded;\n\tprotected boolean noFilterEdgeAttributeChanged;\n\tprotected boolean noFilterEdgeAttributeRemoved;\n\tprotected boolean noFilterEdgeAdded;\n\tprotected boolean noFilterEdgeRemoved;\n\tprotected boolean noFilterGraphCleared;\n\tprotected boolean noFilterStepBegins;\n\tprotected ArrayList<String> graphAttributesFiltered;\n\tprotected ArrayList<String> nodeAttributesFiltered;\n\tprotected ArrayList<String> edgeAttributesFiltered;\n\t\n\t/**\n\t * Initialize with no filter \n\t */\n\tpublic FileSinkBaseFiltered(){\n\t\tnoFilterGraphAttributeAdded = true;\n\t\tnoFilterGraphAttributeChanged = true;\n\t\tnoFilterGraphAttributeRemoved = true;\n\t\tnoFilterNodeAttributeAdded = true;\n\t\tnoFilterNodeAttributeChanged = true;\n\t\tnoFilterNodeAttributeRemoved = true;\n\t\tnoFilterNodeAdded = true;\n\t\tnoFilterNodeRemoved = true;\n\t\tnoFilterEdgeAttributeAdded = true;\n\t\tnoFilterEdgeAttributeChanged = true;\n\t\tnoFilterEdgeAttributeRemoved = true;\n\t\tnoFilterEdgeAdded = true;\n\t\tnoFilterEdgeRemoved = true;\n\t\tnoFilterGraphCleared = true;\n\t\tnoFilterStepBegins = true;\n\t\tgraphAttributesFiltered = new ArrayList<String>();\n\t\tnodeAttributesFiltered = new ArrayList<String>();\n\t\tedgeAttributesFiltered = new ArrayList<String>();\n\t}\n\n\t/**\n\t * @return the list of every node attributes filtered\n\t */\n\tpublic ArrayList<String> getGraphAttributesFiltered() {\n\t\treturn graphAttributesFiltered;\n\t}\n\n\t/**\n\t * Set the whole list of graph attributes filtered\n\t * @param graphAttributesFiltered the new list\n\t */\n\tpublic void setGraphAttributesFiltered(ArrayList<String> graphAttributesFiltered) {\n\t\tthis.graphAttributesFiltered = graphAttributesFiltered;\n\t}\n\n\t/**\n\t * Add a new attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been added, false otherwise\n\t */\n\tpublic boolean addGraphAttributeFiltered(String attr){\n\t\treturn graphAttributesFiltered.add(attr);\n\t}\n\n\t/**\n\t * Remove an attribute to filter\n\t * @param attr the no more filtered attribute\n\t * @return true if the attribute has been removed, false otherwise\n\t */\n\tpublic boolean removeGraphAttributeFilter(String attr){\n\t\treturn graphAttributesFiltered.remove(attr);\n\t}\n\n\t/**\n\t * @return the list of every node attributes filtered\n\t */\n\tpublic ArrayList<String> getNodeAttributesFiltered() {\n\t\treturn graphAttributesFiltered;\n\t}\n\n\t/**\n\t * Set the whole list of node attributes filtered\n\t * @param nodeAttributesFiltered the new list\n\t */\n\tpublic void setNodeAttributesFiltered(ArrayList<String> nodeAttributesFiltered) {\n\t\tthis.nodeAttributesFiltered = nodeAttributesFiltered;\n\t}\n\n\t/**\n\t * Add a new attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been added, false otherwise\n\t */\n\tpublic boolean addNodeAttributeFiltered(String attr){\n\t\treturn nodeAttributesFiltered.add(attr);\n\t}\n\n\t/**\n\t * Remove an attribute to filter\n\t * @param attr the no more filtered attribute\n\t * @return true if the attribute has been removed, false otherwise\n\t */\n\tpublic boolean removeNodeAttributeFilter(String attr){\n\t\treturn nodeAttributesFiltered.remove(attr);\n\t}\n\n\t/**\n\t * @return the list of every edge attributes filtered\n\t */\n\tpublic ArrayList<String> getEdgeAttributesFiltered() {\n\t\treturn edgeAttributesFiltered;\n\t}\n\n\t/**\n\t * Set the whole list of edge attributes filtered\n\t * @param edgeAttributesFiltered the new list\n\t */\n\tpublic void setEdgeAttributesFiltered(ArrayList<String> edgeAttributesFiltered) {\n\t\tthis.edgeAttributesFiltered = edgeAttributesFiltered;\n\t}\n\n\t/**\n\t * Add a new attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been added, false otherwise\n\t */\n\tpublic boolean addEdgeAttributeFiltered(String attr){\n\t\treturn edgeAttributesFiltered.add(attr);\n\t}\n\n\t/**\n\t * Remove an attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been removed, false otherwise\n\t */\n\tpublic boolean removeEdgeAttributeFilter(String attr){\n\t\treturn edgeAttributesFiltered.remove(attr);\n\t}\n\t\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphAttributeAdded() {\n\t\treturn noFilterGraphAttributeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphAttributeAdded\n\t */\n\tpublic void setNoFilterGraphAttributeAdded(boolean noFilterGraphAttributeAdded) {\n\t\tthis.noFilterGraphAttributeAdded = noFilterGraphAttributeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphAttributeChanged() {\n\t\treturn noFilterGraphAttributeChanged;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphAttributeChanged\n\t */\n\tpublic void setNoFilterGraphAttributeChanged(\n\t\t\tboolean noFilterGraphAttributeChanged) {\n\t\tthis.noFilterGraphAttributeChanged = noFilterGraphAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphAttributeRemoved() {\n\t\treturn noFilterGraphAttributeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphAttributeRemoved\n\t */\n\tpublic void setNoFilterGraphAttributeRemoved(\n\t\t\tboolean noFilterGraphAttributeRemoved) {\n\t\tthis.noFilterGraphAttributeRemoved = noFilterGraphAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAttributeAdded() {\n\t\treturn noFilterNodeAttributeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAttributeAdded\n\t */\n\tpublic void setNoFilterNodeAttributeAdded(boolean noFilterNodeAttributeAdded) {\n\t\tthis.noFilterNodeAttributeAdded = noFilterNodeAttributeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAttributeChanged() {\n\t\treturn noFilterNodeAttributeChanged;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAttributeChanged\n\t */\n\tpublic void setNoFilterNodeAttributeChanged(boolean noFilterNodeAttributeChanged) {\n\t\tthis.noFilterNodeAttributeChanged = noFilterNodeAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAttributeRemoved() {\n\t\treturn noFilterNodeAttributeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAttributeRemoved\n\t */\n\tpublic void setNoFilterNodeAttributeRemoved(boolean noFilterNodeAttributeRemoved) {\n\t\tthis.noFilterNodeAttributeRemoved = noFilterNodeAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAdded() {\n\t\treturn noFilterNodeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAdded\n\t */\n\tpublic void setNoFilterNodeAdded(boolean noFilterNodeAdded) {\n\t\tthis.noFilterNodeAdded = noFilterNodeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeRemoved() {\n\t\treturn noFilterNodeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeRemoved\n\t */\n\tpublic void setNoFilterNodeRemoved(boolean noFilterNodeRemoved) {\n\t\tthis.noFilterNodeRemoved = noFilterNodeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAttributeAdded() {\n\t\treturn noFilterEdgeAttributeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterEdgeAttributeAdded\n\t */\n\tpublic void setNoFilterEdgeAttributeAdded(boolean noFilterEdgeAttributeAdded) {\n\t\tthis.noFilterEdgeAttributeAdded = noFilterEdgeAttributeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAttributeChanged() {\n\t\treturn noFilterEdgeAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @param noFilterEdgeAttributeChanged\n\t */\n\tpublic void setNoFilterEdgeAttributeChanged(boolean noFilterEdgeAttributeChanged) {\n\t\tthis.noFilterEdgeAttributeChanged = noFilterEdgeAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAttributeRemoved() {\n\t\treturn noFilterEdgeAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @param noFilterEdgeAttributeRemoved\n\t */\n\tpublic void setNoFilterEdgeAttributeRemoved(boolean noFilterEdgeAttributeRemoved) {\n\t\tthis.noFilterEdgeAttributeRemoved = noFilterEdgeAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAdded() {\n\t\treturn noFilterEdgeAdded;\n\t}\n\n\t/**\n\t * \n\t * @param noFilterEdgeAdded\n\t */\n\tpublic void setNoFilterEdgeAdded(boolean noFilterEdgeAdded) {\n\t\tthis.noFilterEdgeAdded = noFilterEdgeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeRemoved() {\n\t\treturn noFilterEdgeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterEdgeRemoved\n\t */\n\tpublic void setNoFilterEdgeRemoved(boolean noFilterEdgeRemoved) {\n\t\tthis.noFilterEdgeRemoved = noFilterEdgeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphCleared() {\n\t\treturn noFilterGraphCleared;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphCleared\n\t */\n\tpublic void setNoFilterGraphCleared(boolean noFilterGraphCleared) {\n\t\tthis.noFilterGraphCleared = noFilterGraphCleared;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterStepBegins() {\n\t\treturn noFilterStepBegins;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterStepBegins\n\t */\n\tpublic void setNoFilterStepBegins(boolean noFilterStepBegins) {\n\t\tthis.noFilterStepBegins = noFilterStepBegins;\n\t}\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addNodeAttributeFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean addNodeAttributeFiltered(String attr)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "isNoFilterStepBegins", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterStepBegins()" ], [ "isNoFilterNodeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAttributeAdded()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "isNoFilterGraphAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphAttributeChanged()" ], [ "isNoFilterNodeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAdded()" ], [ "isNoFilterGraphAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphAttributeAdded()" ], [ "isNoFilterEdgeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAttributeChanged()" ], [ "addGraphAttributeFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean addGraphAttributeFiltered(String attr)" ], [ "isNoFilterEdgeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAttributeRemoved()" ], [ "isNoFilterEdgeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeRemoved()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "isNoFilterNodeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAttributeRemoved()" ], [ "removeEdgeAttributeFilter", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean removeEdgeAttributeFilter(String attr)" ], [ "getEdgeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public ArrayList<String> getEdgeAttributesFiltered()" ], [ "isNoFilterNodeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAttributeChanged()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "isNoFilterGraphCleared", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphCleared()" ], [ "createWriter", "org.graphstream.stream.file", "FileSinkBase", "protected Writer createWriter(String arg0) throws IOException" ], [ "createWriter", "org.graphstream.stream.file", "FileSinkBase", "protected Writer createWriter(OutputStream arg0) throws IOException" ], [ "isNoFilterEdgeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAttributeAdded()" ], [ "isNoFilterNodeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeRemoved()" ], [ "isNoFilterEdgeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAdded()" ], [ "removeNodeAttributeFilter", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean removeNodeAttributeFilter(String attr)" ], [ "isNoFilterGraphAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphAttributeRemoved()" ], [ "removeGraphAttributeFilter", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean removeGraphAttributeFilter(String attr)" ], [ "getNodeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public ArrayList<String> getNodeAttributesFiltered()" ], [ "getGraphAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public ArrayList<String> getGraphAttributesFiltered()" ], [ "createWriter", "org.graphstream.stream.file", "FileSinkBase", "protected Writer createWriter(Writer arg0) throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addEdgeAttributeFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean addEdgeAttributeFiltered(String attr)" ], [ "removeIf", "java.util", "ArrayList", "boolean removeIf(Predicate<? super E> arg0, int arg1, int arg2)" ], [ "indexOf", "java.util", "ArrayList", "public int indexOf(Object arg0)" ], [ "elementData", "java.util", "ArrayList", "E elementData(int arg0)" ], [ "iterator", "java.util", "ArrayList", "public Iterator<E> iterator()" ], [ "addAll", "java.util", "ArrayList", "public boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "lastIndexOfRange", "java.util", "ArrayList", "int lastIndexOfRange(Object arg0, int arg1, int arg2)" ], [ "add", "java.util", "ArrayList", "public boolean add(E arg0)" ], [ "lastIndexOf", "java.util", "ArrayList", "public int lastIndexOf(Object arg0)" ], [ "indexOfRange", "java.util", "ArrayList", "int indexOfRange(Object arg0, int arg1, int arg2)" ], [ "spliterator", "java.util", "ArrayList", "public Spliterator<E> spliterator()" ], [ "removeIf", "java.util", "ArrayList", "public boolean removeIf(Predicate<? super E> arg0)" ], [ "contains", "java.util", "ArrayList", "public boolean contains(Object arg0)" ], [ "batchRemove", "java.util", "ArrayList", "boolean batchRemove(Collection<? extends Object> arg0, boolean arg1, int arg2, int arg3)" ], [ "removeAll", "java.util", "ArrayList", "public boolean removeAll(Collection<? extends Object> arg0)" ], [ "equals", "java.util", "ArrayList", "public boolean equals(Object arg0)" ], [ "toArray", "java.util", "ArrayList", "public <T> T[] toArray(T[] arg0)" ], [ "hashCode", "java.util", "ArrayList", "public int hashCode()" ], [ "clone", "java.util", "ArrayList", "public Object clone()" ], [ "addAll", "java.util", "ArrayList", "public boolean addAll(Collection<? extends E> arg0)" ], [ "listIterator", "java.util", "ArrayList", "public ListIterator<E> listIterator()" ], [ "get", "java.util", "ArrayList", "public E get(int arg0)" ], [ "isEmpty", "java.util", "ArrayList", "public boolean isEmpty()" ], [ "remove", "java.util", "ArrayList", "public boolean remove(Object arg0)" ], [ "listIterator", "java.util", "ArrayList", "public ListIterator<E> listIterator(int arg0)" ], [ "subList", "java.util", "ArrayList", "public List<E> subList(int arg0, int arg1)" ], [ "retainAll", "java.util", "ArrayList", "public boolean retainAll(Collection<? extends Object> arg0)" ], [ "equalsRange", "java.util", "ArrayList", "boolean equalsRange(List<? extends Object> arg0, int arg1, int arg2)" ], [ "toArray", "java.util", "ArrayList", "public Object[] toArray()" ], [ "hashCodeRange", "java.util", "ArrayList", "int hashCodeRange(int arg0, int arg1)" ], [ "set", "java.util", "ArrayList", "public E set(int arg0, E arg1)" ], [ "remove", "java.util", "ArrayList", "public E remove(int arg0)" ], [ "size", "java.util", "ArrayList", "public int size()" ], [ "lastIndexOf", "java.util", "AbstractList", "public int lastIndexOf(Object arg0)" ], [ "equals", "java.util", "AbstractList", "public boolean equals(Object arg0)" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator()" ], [ "indexOf", "java.util", "AbstractList", "public int indexOf(Object arg0)" ], [ "addAll", "java.util", "AbstractList", "public boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "subList", "java.util", "AbstractList", "public List<E> subList(int arg0, int arg1)" ], [ "add", "java.util", "AbstractList", "public boolean add(E arg0)" ], [ "get", "java.util", "AbstractList", "public abstract E get(int arg0)" ], [ "set", "java.util", "AbstractList", "public E set(int arg0, E arg1)" ], [ "remove", "java.util", "AbstractList", "public E remove(int arg0)" ], [ "hashCode", "java.util", "AbstractList", "public int hashCode()" ], [ "iterator", "java.util", "AbstractList", "public Iterator<E> iterator()" ], [ "listIterator", "java.util", "AbstractList", "public ListIterator<E> listIterator(int arg0)" ], [ "contains", "java.util", "AbstractCollection", "public boolean contains(Object arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public Object[] toArray()" ], [ "removeAll", "java.util", "AbstractCollection", "public boolean removeAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "AbstractCollection", "public <T> T[] toArray(T[] arg0)" ], [ "size", "java.util", "AbstractCollection", "public abstract int size()" ], [ "retainAll", "java.util", "AbstractCollection", "public boolean retainAll(Collection<? extends Object> arg0)" ], [ "toString", "java.util", "AbstractCollection", "public String toString()" ], [ "isEmpty", "java.util", "AbstractCollection", "public boolean isEmpty()" ], [ "iterator", "java.util", "AbstractCollection", "public abstract Iterator<E> iterator()" ], [ "remove", "java.util", "AbstractCollection", "public boolean remove(Object arg0)" ], [ "addAll", "java.util", "AbstractCollection", "public boolean addAll(Collection<? extends E> arg0)" ], [ "containsAll", "java.util", "AbstractCollection", "public boolean containsAll(Collection<? extends Object> arg0)" ], [ "add", "java.util", "AbstractCollection", "public boolean add(E arg0)" ], [ "add", "java.util", "Collection", "public abstract boolean add(E arg0)" ], [ "toArray", "java.util", "Collection", "public default <T> T[] toArray(IntFunction<T[]> arg0)" ], [ "contains", "java.util", "Collection", "public abstract boolean contains(Object arg0)" ], [ "toArray", "java.util", "Collection", "public abstract Object[] toArray()" ], [ "equals", "java.util", "Collection", "public abstract boolean equals(Object arg0)" ], [ "size", "java.util", "Collection", "public abstract int size()" ], [ "hashCode", "java.util", "Collection", "public abstract int hashCode()" ], [ "isEmpty", "java.util", "Collection", "public abstract boolean isEmpty()" ], [ "spliterator", "java.util", "Collection", "public default Spliterator<E> spliterator()" ], [ "parallelStream", "java.util", "Collection", "public default Stream<E> parallelStream()" ], [ "iterator", "java.util", "Collection", "public abstract Iterator<E> iterator()" ], [ "containsAll", "java.util", "Collection", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "stream", "java.util", "Collection", "public default Stream<E> stream()" ], [ "removeAll", "java.util", "Collection", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "Collection", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "removeIf", "java.util", "Collection", "public default boolean removeIf(Predicate<? super E> arg0)" ], [ "toArray", "java.util", "Collection", "public abstract <T> T[] toArray(T[] arg0)" ], [ "retainAll", "java.util", "Collection", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "remove", "java.util", "Collection", "public abstract boolean remove(Object arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "toArray", "java.util", "List", "public abstract Object[] toArray()" ], [ "remove", "java.util", "List", "public abstract E remove(int arg0)" ], [ "get", "java.util", "List", "public abstract E get(int arg0)" ], [ "retainAll", "java.util", "List", "public abstract boolean retainAll(Collection<? extends Object> arg0)" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(Collection<? extends E> arg0)" ], [ "size", "java.util", "List", "public abstract int size()" ], [ "isEmpty", "java.util", "List", "public abstract boolean isEmpty()" ], [ "contains", "java.util", "List", "public abstract boolean contains(Object arg0)" ], [ "removeAll", "java.util", "List", "public abstract boolean removeAll(Collection<? extends Object> arg0)" ], [ "toArray", "java.util", "List", "public abstract <T> T[] toArray(T[] arg0)" ], [ "add", "java.util", "List", "public abstract boolean add(E arg0)" ], [ "spliterator", "java.util", "List", "public default Spliterator<E> spliterator()" ], [ "indexOf", "java.util", "List", "public abstract int indexOf(Object arg0)" ], [ "set", "java.util", "List", "public abstract E set(int arg0, E arg1)" ], [ "equals", "java.util", "List", "public abstract boolean equals(Object arg0)" ], [ "hashCode", "java.util", "List", "public abstract int hashCode()" ], [ "containsAll", "java.util", "List", "public abstract boolean containsAll(Collection<? extends Object> arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator()" ], [ "addAll", "java.util", "List", "public abstract boolean addAll(int arg0, Collection<? extends E> arg1)" ], [ "lastIndexOf", "java.util", "List", "public abstract int lastIndexOf(Object arg0)" ], [ "listIterator", "java.util", "List", "public abstract ListIterator<E> listIterator(int arg0)" ], [ "subList", "java.util", "List", "public abstract List<E> subList(int arg0, int arg1)" ], [ "iterator", "java.util", "List", "public abstract Iterator<E> iterator()" ], [ "remove", "java.util", "List", "public abstract boolean remove(Object arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "noFilterGraphAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphAttributeAdded;" ], [ "noFilterGraphAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphAttributeChanged;" ], [ "noFilterGraphAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphAttributeRemoved;" ], [ "noFilterNodeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAttributeAdded;" ], [ "noFilterNodeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAttributeChanged;" ], [ "noFilterNodeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAttributeRemoved;" ], [ "noFilterNodeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAdded;" ], [ "noFilterNodeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeRemoved;" ], [ "noFilterEdgeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAttributeAdded;" ], [ "noFilterEdgeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAttributeChanged;" ], [ "noFilterEdgeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAttributeRemoved;" ], [ "noFilterEdgeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAdded;" ], [ "noFilterEdgeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeRemoved;" ], [ "noFilterGraphCleared", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphCleared;" ], [ "noFilterStepBegins", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterStepBegins;" ], [ "graphAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected ArrayList<String> graphAttributesFiltered;" ], [ "nodeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected ArrayList<String> nodeAttributesFiltered;" ], [ "edgeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected ArrayList<String> edgeAttributesFiltered;" ], [ "output", "org.graphstream.stream.file", "FileSinkBase", "protected Writer output;" ], [ "elementData", "java.util", "ArrayList", "transient Object[] elementData;" ], [ "modCount", "java.util", "AbstractList", "protected transient int modCount;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3520,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSinkBaseFiltered",
  "javadocTag" : "@param noFilterNodeAdded",
  "methodJavadoc" : "    /**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAdded\n\t */",
  "methodSourceCode" : "public void setNoFilterNodeAdded(boolean noFilterNodeAdded){\n    this.noFilterNodeAdded = noFilterNodeAdded;\n}",
  "classJavadoc" : "/**\n * Base implementation for filtered graph output to files.\n * \n * <p>\n * This class provides the list of possible filters which could be used by the final user to write graphs into files using a specific file format. \n * Thus, it allows to create an output stream where the dynamic events of addition/deletion/modification can be filtered.\n * </p>\n * \n * <p>\n * Since it extends FileSinkBase, you have to override the same methods in order to implement an output.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.util.ArrayList;\n\nimport org.graphstream.stream.file.FileSinkBase;\n\n/**\n * Base implementation for filtered graph output to files.\n * \n * <p>\n * This class provides the list of possible filters which could be used by the final user to write graphs into files using a specific file format. \n * Thus, it allows to create an output stream where the dynamic events of addition/deletion/modification can be filtered.\n * </p>\n * \n * <p>\n * Since it extends FileSinkBase, you have to override the same methods in order to implement an output.\n * </p>\n */\npublic abstract class FileSinkBaseFiltered extends FileSinkBase {\n\t/*\n\t * List of possible filters\n\t */\n\tprotected boolean noFilterGraphAttributeAdded;\n\tprotected boolean noFilterGraphAttributeChanged;\n\tprotected boolean noFilterGraphAttributeRemoved;\n\tprotected boolean noFilterNodeAttributeAdded;\n\tprotected boolean noFilterNodeAttributeChanged;\n\tprotected boolean noFilterNodeAttributeRemoved;\n\tprotected boolean noFilterNodeAdded;\n\tprotected boolean noFilterNodeRemoved;\n\tprotected boolean noFilterEdgeAttributeAdded;\n\tprotected boolean noFilterEdgeAttributeChanged;\n\tprotected boolean noFilterEdgeAttributeRemoved;\n\tprotected boolean noFilterEdgeAdded;\n\tprotected boolean noFilterEdgeRemoved;\n\tprotected boolean noFilterGraphCleared;\n\tprotected boolean noFilterStepBegins;\n\tprotected ArrayList<String> graphAttributesFiltered;\n\tprotected ArrayList<String> nodeAttributesFiltered;\n\tprotected ArrayList<String> edgeAttributesFiltered;\n\t\n\t/**\n\t * Initialize with no filter \n\t */\n\tpublic FileSinkBaseFiltered(){\n\t\tnoFilterGraphAttributeAdded = true;\n\t\tnoFilterGraphAttributeChanged = true;\n\t\tnoFilterGraphAttributeRemoved = true;\n\t\tnoFilterNodeAttributeAdded = true;\n\t\tnoFilterNodeAttributeChanged = true;\n\t\tnoFilterNodeAttributeRemoved = true;\n\t\tnoFilterNodeAdded = true;\n\t\tnoFilterNodeRemoved = true;\n\t\tnoFilterEdgeAttributeAdded = true;\n\t\tnoFilterEdgeAttributeChanged = true;\n\t\tnoFilterEdgeAttributeRemoved = true;\n\t\tnoFilterEdgeAdded = true;\n\t\tnoFilterEdgeRemoved = true;\n\t\tnoFilterGraphCleared = true;\n\t\tnoFilterStepBegins = true;\n\t\tgraphAttributesFiltered = new ArrayList<String>();\n\t\tnodeAttributesFiltered = new ArrayList<String>();\n\t\tedgeAttributesFiltered = new ArrayList<String>();\n\t}\n\n\t/**\n\t * @return the list of every node attributes filtered\n\t */\n\tpublic ArrayList<String> getGraphAttributesFiltered() {\n\t\treturn graphAttributesFiltered;\n\t}\n\n\t/**\n\t * Set the whole list of graph attributes filtered\n\t * @param graphAttributesFiltered the new list\n\t */\n\tpublic void setGraphAttributesFiltered(ArrayList<String> graphAttributesFiltered) {\n\t\tthis.graphAttributesFiltered = graphAttributesFiltered;\n\t}\n\n\t/**\n\t * Add a new attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been added, false otherwise\n\t */\n\tpublic boolean addGraphAttributeFiltered(String attr){\n\t\treturn graphAttributesFiltered.add(attr);\n\t}\n\n\t/**\n\t * Remove an attribute to filter\n\t * @param attr the no more filtered attribute\n\t * @return true if the attribute has been removed, false otherwise\n\t */\n\tpublic boolean removeGraphAttributeFilter(String attr){\n\t\treturn graphAttributesFiltered.remove(attr);\n\t}\n\n\t/**\n\t * @return the list of every node attributes filtered\n\t */\n\tpublic ArrayList<String> getNodeAttributesFiltered() {\n\t\treturn graphAttributesFiltered;\n\t}\n\n\t/**\n\t * Set the whole list of node attributes filtered\n\t * @param nodeAttributesFiltered the new list\n\t */\n\tpublic void setNodeAttributesFiltered(ArrayList<String> nodeAttributesFiltered) {\n\t\tthis.nodeAttributesFiltered = nodeAttributesFiltered;\n\t}\n\n\t/**\n\t * Add a new attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been added, false otherwise\n\t */\n\tpublic boolean addNodeAttributeFiltered(String attr){\n\t\treturn nodeAttributesFiltered.add(attr);\n\t}\n\n\t/**\n\t * Remove an attribute to filter\n\t * @param attr the no more filtered attribute\n\t * @return true if the attribute has been removed, false otherwise\n\t */\n\tpublic boolean removeNodeAttributeFilter(String attr){\n\t\treturn nodeAttributesFiltered.remove(attr);\n\t}\n\n\t/**\n\t * @return the list of every edge attributes filtered\n\t */\n\tpublic ArrayList<String> getEdgeAttributesFiltered() {\n\t\treturn edgeAttributesFiltered;\n\t}\n\n\t/**\n\t * Set the whole list of edge attributes filtered\n\t * @param edgeAttributesFiltered the new list\n\t */\n\tpublic void setEdgeAttributesFiltered(ArrayList<String> edgeAttributesFiltered) {\n\t\tthis.edgeAttributesFiltered = edgeAttributesFiltered;\n\t}\n\n\t/**\n\t * Add a new attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been added, false otherwise\n\t */\n\tpublic boolean addEdgeAttributeFiltered(String attr){\n\t\treturn edgeAttributesFiltered.add(attr);\n\t}\n\n\t/**\n\t * Remove an attribute to filter\n\t * @param attr the filtered attribute\n\t * @return true if the attribute has been removed, false otherwise\n\t */\n\tpublic boolean removeEdgeAttributeFilter(String attr){\n\t\treturn edgeAttributesFiltered.remove(attr);\n\t}\n\t\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphAttributeAdded() {\n\t\treturn noFilterGraphAttributeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphAttributeAdded\n\t */\n\tpublic void setNoFilterGraphAttributeAdded(boolean noFilterGraphAttributeAdded) {\n\t\tthis.noFilterGraphAttributeAdded = noFilterGraphAttributeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphAttributeChanged() {\n\t\treturn noFilterGraphAttributeChanged;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphAttributeChanged\n\t */\n\tpublic void setNoFilterGraphAttributeChanged(\n\t\t\tboolean noFilterGraphAttributeChanged) {\n\t\tthis.noFilterGraphAttributeChanged = noFilterGraphAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphAttributeRemoved() {\n\t\treturn noFilterGraphAttributeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphAttributeRemoved\n\t */\n\tpublic void setNoFilterGraphAttributeRemoved(\n\t\t\tboolean noFilterGraphAttributeRemoved) {\n\t\tthis.noFilterGraphAttributeRemoved = noFilterGraphAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAttributeAdded() {\n\t\treturn noFilterNodeAttributeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAttributeAdded\n\t */\n\tpublic void setNoFilterNodeAttributeAdded(boolean noFilterNodeAttributeAdded) {\n\t\tthis.noFilterNodeAttributeAdded = noFilterNodeAttributeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAttributeChanged() {\n\t\treturn noFilterNodeAttributeChanged;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAttributeChanged\n\t */\n\tpublic void setNoFilterNodeAttributeChanged(boolean noFilterNodeAttributeChanged) {\n\t\tthis.noFilterNodeAttributeChanged = noFilterNodeAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAttributeRemoved() {\n\t\treturn noFilterNodeAttributeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAttributeRemoved\n\t */\n\tpublic void setNoFilterNodeAttributeRemoved(boolean noFilterNodeAttributeRemoved) {\n\t\tthis.noFilterNodeAttributeRemoved = noFilterNodeAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeAdded() {\n\t\treturn noFilterNodeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeAdded\n\t */\n\tpublic void setNoFilterNodeAdded(boolean noFilterNodeAdded) {\n\t\tthis.noFilterNodeAdded = noFilterNodeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterNodeRemoved() {\n\t\treturn noFilterNodeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterNodeRemoved\n\t */\n\tpublic void setNoFilterNodeRemoved(boolean noFilterNodeRemoved) {\n\t\tthis.noFilterNodeRemoved = noFilterNodeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAttributeAdded() {\n\t\treturn noFilterEdgeAttributeAdded;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterEdgeAttributeAdded\n\t */\n\tpublic void setNoFilterEdgeAttributeAdded(boolean noFilterEdgeAttributeAdded) {\n\t\tthis.noFilterEdgeAttributeAdded = noFilterEdgeAttributeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAttributeChanged() {\n\t\treturn noFilterEdgeAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @param noFilterEdgeAttributeChanged\n\t */\n\tpublic void setNoFilterEdgeAttributeChanged(boolean noFilterEdgeAttributeChanged) {\n\t\tthis.noFilterEdgeAttributeChanged = noFilterEdgeAttributeChanged;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAttributeRemoved() {\n\t\treturn noFilterEdgeAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @param noFilterEdgeAttributeRemoved\n\t */\n\tpublic void setNoFilterEdgeAttributeRemoved(boolean noFilterEdgeAttributeRemoved) {\n\t\tthis.noFilterEdgeAttributeRemoved = noFilterEdgeAttributeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeAdded() {\n\t\treturn noFilterEdgeAdded;\n\t}\n\n\t/**\n\t * \n\t * @param noFilterEdgeAdded\n\t */\n\tpublic void setNoFilterEdgeAdded(boolean noFilterEdgeAdded) {\n\t\tthis.noFilterEdgeAdded = noFilterEdgeAdded;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterEdgeRemoved() {\n\t\treturn noFilterEdgeRemoved;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterEdgeRemoved\n\t */\n\tpublic void setNoFilterEdgeRemoved(boolean noFilterEdgeRemoved) {\n\t\tthis.noFilterEdgeRemoved = noFilterEdgeRemoved;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterGraphCleared() {\n\t\treturn noFilterGraphCleared;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterGraphCleared\n\t */\n\tpublic void setNoFilterGraphCleared(boolean noFilterGraphCleared) {\n\t\tthis.noFilterGraphCleared = noFilterGraphCleared;\n\t}\n\n\t/**\n\t * \n\t * @return true if this filter is disable, false otherwise\n\t */\n\tpublic boolean isNoFilterStepBegins() {\n\t\treturn noFilterStepBegins;\n\t}\n\n\t/**\n\t * Disable or enable this filter\n\t * @param noFilterStepBegins\n\t */\n\tpublic void setNoFilterStepBegins(boolean noFilterStepBegins) {\n\t\tthis.noFilterStepBegins = noFilterStepBegins;\n\t}\n\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "noFilterNodeAdded", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeEdgeAttributeFilter", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean removeEdgeAttributeFilter(String attr)" ], [ "isNoFilterEdgeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAttributeAdded()" ], [ "getEdgeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public ArrayList<String> getEdgeAttributesFiltered()" ], [ "isNoFilterGraphAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphAttributeChanged()" ], [ "isNoFilterNodeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAttributeRemoved()" ], [ "isNoFilterGraphAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphAttributeAdded()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "isNoFilterEdgeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAdded()" ], [ "getGraphAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public ArrayList<String> getGraphAttributesFiltered()" ], [ "isNoFilterEdgeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeRemoved()" ], [ "isNoFilterGraphCleared", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphCleared()" ], [ "createWriter", "org.graphstream.stream.file", "FileSinkBase", "protected Writer createWriter(String arg0) throws IOException" ], [ "isNoFilterEdgeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAttributeChanged()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "createWriter", "org.graphstream.stream.file", "FileSinkBase", "protected Writer createWriter(OutputStream arg0) throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getNodeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public ArrayList<String> getNodeAttributesFiltered()" ], [ "isNoFilterGraphAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterGraphAttributeRemoved()" ], [ "createWriter", "org.graphstream.stream.file", "FileSinkBase", "protected Writer createWriter(Writer arg0) throws IOException" ], [ "isNoFilterStepBegins", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterStepBegins()" ], [ "removeGraphAttributeFilter", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean removeGraphAttributeFilter(String attr)" ], [ "addEdgeAttributeFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean addEdgeAttributeFiltered(String attr)" ], [ "isNoFilterEdgeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterEdgeAttributeRemoved()" ], [ "addGraphAttributeFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean addGraphAttributeFiltered(String attr)" ], [ "isNoFilterNodeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeRemoved()" ], [ "isNoFilterNodeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAttributeChanged()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeNodeAttributeFilter", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean removeNodeAttributeFilter(String attr)" ], [ "addNodeAttributeFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean addNodeAttributeFiltered(String attr)" ], [ "isNoFilterNodeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAdded()" ], [ "isNoFilterNodeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "public boolean isNoFilterNodeAttributeAdded()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "noFilterGraphAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphAttributeAdded;" ], [ "noFilterGraphAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphAttributeChanged;" ], [ "noFilterGraphAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphAttributeRemoved;" ], [ "noFilterNodeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAttributeAdded;" ], [ "noFilterNodeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAttributeChanged;" ], [ "noFilterNodeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAttributeRemoved;" ], [ "noFilterNodeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeAdded;" ], [ "noFilterNodeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterNodeRemoved;" ], [ "noFilterEdgeAttributeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAttributeAdded;" ], [ "noFilterEdgeAttributeChanged", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAttributeChanged;" ], [ "noFilterEdgeAttributeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAttributeRemoved;" ], [ "noFilterEdgeAdded", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeAdded;" ], [ "noFilterEdgeRemoved", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterEdgeRemoved;" ], [ "noFilterGraphCleared", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterGraphCleared;" ], [ "noFilterStepBegins", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected boolean noFilterStepBegins;" ], [ "graphAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected ArrayList<String> graphAttributesFiltered;" ], [ "nodeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected ArrayList<String> nodeAttributesFiltered;" ], [ "edgeAttributesFiltered", "org.graphstream.stream.file", "FileSinkBaseFiltered", "protected ArrayList<String> edgeAttributesFiltered;" ], [ "output", "org.graphstream.stream.file", "FileSinkBase", "protected Writer output;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3539,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __graphml() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        pushback(e);\n        __desc();\n        e = getNextEvent();\n    }\n    while (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n        pushback(e);\n        __key();\n        e = getNextEvent();\n    }\n    while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n        pushback(e);\n        if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n            __data();\n        } else {\n            __graph();\n        }\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3540,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __graphml() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        pushback(e);\n        __desc();\n        e = getNextEvent();\n    }\n    while (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n        pushback(e);\n        __key();\n        e = getNextEvent();\n    }\n    while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n        pushback(e);\n        if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n            __data();\n        } else {\n            __graph();\n        }\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3543,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private String __desc() throws IOException, XMLStreamException{\n    XMLEvent e;\n    String desc;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"desc\");\n    desc = __characters();\n    e = getNextEvent();\n    checkValid(e, XMLEvent.END_ELEMENT, \"desc\");\n    return desc;\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3546,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private Locator __locator() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"locator\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    Locator loc = new Locator();\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            LocatorAttribute attribute = LocatorAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case XMLNS_XLINK:\n                    loc.xlink = a.getValue();\n                    break;\n                case XLINK_HREF:\n                    loc.href = a.getValue();\n                    break;\n                case XLINK_TYPE:\n                    loc.type = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid locator attribute '%s'\", a.getName().getLocalPart());\n        }\n    }\n    e = getNextEvent();\n    checkValid(e, XMLEvent.END_ELEMENT, \"locator\");\n    if (loc.href == null)\n        throw newParseError(e, \"locator requires an href\");\n    return loc;\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "3", "int" ], [ "2000", "int" ], [ "-20001220", "int" ], [ "\"http://www.w3.org/TR/2000/PR-xlink-20001220/\"", "String" ], [ "\"simple\"", "String" ] ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ], [ "href", "org.graphstream.stream.file", "FileSourceGraphML.Locator", "String href;" ], [ "xlink", "org.graphstream.stream.file", "FileSourceGraphML.Locator", "String xlink;" ], [ "type", "org.graphstream.stream.file", "FileSourceGraphML.Locator", "String type;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3550,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private Port __port() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"port\");\n    Port port = new Port();\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            PortAttribute attribute = PortAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case NAME:\n                    port.name = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid attribute '%s' for '<port>'\", a.getName().getLocalPart());\n        }\n    }\n    if (port.name == null)\n        throw newParseError(e, \"'<port>' element requires a 'name' attribute\");\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        pushback(e);\n        port.desc = __desc();\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n            if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n                Data data;\n                pushback(e);\n                data = __data();\n                port.datas.add(data);\n            } else {\n                Port portChild;\n                pushback(e);\n                portChild = __port();\n                port.ports.add(portChild);\n            }\n            e = getNextEvent();\n        }\n    }\n    e = getNextEvent();\n    checkValid(e, XMLEvent.END_ELEMENT, \"port\");\n    return port;\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ], [ "name", "org.graphstream.stream.file", "FileSourceGraphML.Port", "String name;" ], [ "desc", "org.graphstream.stream.file", "FileSourceGraphML.Port", "String desc;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML.Port", "LinkedList<Data> datas;" ], [ "ports", "org.graphstream.stream.file", "FileSourceGraphML.Port", "LinkedList<Port> ports;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3551,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private Port __port() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"port\");\n    Port port = new Port();\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            PortAttribute attribute = PortAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case NAME:\n                    port.name = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid attribute '%s' for '<port>'\", a.getName().getLocalPart());\n        }\n    }\n    if (port.name == null)\n        throw newParseError(e, \"'<port>' element requires a 'name' attribute\");\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        pushback(e);\n        port.desc = __desc();\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n            if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n                Data data;\n                pushback(e);\n                data = __data();\n                port.datas.add(data);\n            } else {\n                Port portChild;\n                pushback(e);\n                portChild = __port();\n                port.ports.add(portChild);\n            }\n            e = getNextEvent();\n        }\n    }\n    e = getNextEvent();\n    checkValid(e, XMLEvent.END_ELEMENT, \"port\");\n    return port;\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ], [ "name", "org.graphstream.stream.file", "FileSourceGraphML.Port", "String name;" ], [ "desc", "org.graphstream.stream.file", "FileSourceGraphML.Port", "String desc;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML.Port", "LinkedList<Data> datas;" ], [ "ports", "org.graphstream.stream.file", "FileSourceGraphML.Port", "LinkedList<Port> ports;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3554,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private EndPoint __endpoint() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    EndPoint ep = new EndPoint();\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            EndPointAttribute attribute = EndPointAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case NODE:\n                    ep.node = a.getValue();\n                    break;\n                case ID:\n                    ep.id = a.getValue();\n                    break;\n                case PORT:\n                    ep.port = a.getValue();\n                    break;\n                case TYPE:\n                    try {\n                        ep.type = EndPointType.valueOf(toConstantName(a.getValue()));\n                    } catch (IllegalArgumentException ex) {\n                        throw newParseError(e, \"invalid end point type '%s'\", a.getValue());\n                    }\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid attribute '%s' for '<endpoint>'\", a.getName().getLocalPart());\n        }\n    }\n    if (ep.node == null)\n        throw newParseError(e, \"'<endpoint>' element requires a 'node' attribute\");\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        pushback(e);\n        ep.desc = __desc();\n    }\n    e = getNextEvent();\n    checkValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n    return ep;\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "\"undir\"", "String" ] ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ], [ "id", "org.graphstream.stream.file", "FileSourceGraphML.EndPoint", "String id;" ], [ "node", "org.graphstream.stream.file", "FileSourceGraphML.EndPoint", "String node;" ], [ "port", "org.graphstream.stream.file", "FileSourceGraphML.EndPoint", "String port;" ], [ "desc", "org.graphstream.stream.file", "FileSourceGraphML.EndPoint", "String desc;" ], [ "type", "org.graphstream.stream.file", "FileSourceGraphML.EndPoint", "EndPointType type;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3556,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private Data __data() throws IOException, XMLStreamException{\n    XMLEvent e;\n    StringBuilder buffer = new StringBuilder();\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"data\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    String key = null, id = null;\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            DataAttribute attribute = DataAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case KEY:\n                    key = a.getValue();\n                    break;\n                case ID:\n                    id = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid attribute '%s' for '<data>'\", a.getName().getLocalPart());\n        }\n    }\n    if (key == null)\n        throw newParseError(e, \"'<data>' element must have a 'key' attribute\");\n    e = getNextEvent();\n    while (e.getEventType() == XMLEvent.CHARACTERS) {\n        buffer.append(e.asCharacters());\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"data\");\n    if (keys.containsKey(key))\n        newParseError(e, \"unknown key '%s'\", key);\n    Data d = new Data();\n    d.key = keys.get(key);\n    d.id = id;\n    d.value = buffer.toString();\n    return d;\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ], [ "key", "org.graphstream.stream.file", "FileSourceGraphML.Data", "Key key;" ], [ "id", "org.graphstream.stream.file", "FileSourceGraphML.Data", "String id;" ], [ "value", "org.graphstream.stream.file", "FileSourceGraphML.Data", "String value;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3557,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private Data __data() throws IOException, XMLStreamException{\n    XMLEvent e;\n    StringBuilder buffer = new StringBuilder();\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"data\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    String key = null, id = null;\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            DataAttribute attribute = DataAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case KEY:\n                    key = a.getValue();\n                    break;\n                case ID:\n                    id = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid attribute '%s' for '<data>'\", a.getName().getLocalPart());\n        }\n    }\n    if (key == null)\n        throw newParseError(e, \"'<data>' element must have a 'key' attribute\");\n    e = getNextEvent();\n    while (e.getEventType() == XMLEvent.CHARACTERS) {\n        buffer.append(e.asCharacters());\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"data\");\n    if (keys.containsKey(key))\n        newParseError(e, \"unknown key '%s'\", key);\n    Data d = new Data();\n    d.key = keys.get(key);\n    d.id = id;\n    d.value = buffer.toString();\n    return d;\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ], [ "key", "org.graphstream.stream.file", "FileSourceGraphML.Data", "Key key;" ], [ "id", "org.graphstream.stream.file", "FileSourceGraphML.Data", "String id;" ], [ "value", "org.graphstream.stream.file", "FileSourceGraphML.Data", "String value;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3558,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __graph() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"graph\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    String id = null;\n    String desc = null;\n    boolean directed = false;\n    boolean directedSet = false;\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            GraphAttribute attribute = GraphAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case ID:\n                    id = a.getValue();\n                    break;\n                case EDGEDEFAULT:\n                    if (a.getValue().equals(\"directed\"))\n                        directed = true;\n                    else if (a.getValue().equals(\"undirected\"))\n                        directed = false;\n                    else\n                        throw newParseError(e, \"invalid 'edgefault' value '%s'\", a.getValue());\n                    directedSet = true;\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid node attribute '%s'\", a.getName().getLocalPart());\n        }\n    }\n    if (!directedSet)\n        throw newParseError(e, \"graph requires attribute 'edgedefault'\");\n    String gid = \"\";\n    if (graphId.size() > 0)\n        gid = graphId.peek() + \":\";\n    if (id != null)\n        gid += id;\n    else\n        gid += Integer.toString(graphCounter++);\n    graphId.push(gid);\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        pushback(e);\n        desc = __desc();\n        sendGraphAttributeAdded(sourceId, \"desc\", desc);\n        e = getNextEvent();\n    }\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n        pushback(e);\n        __locator();\n        // TODO\n        e = getNextEvent();\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"node\") || isEvent(e, XMLEvent.START_ELEMENT, \"edge\") || isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n            pushback(e);\n            if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n                datas.add(__data());\n            } else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n                __node();\n            } else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n                __edge(directed);\n            } else {\n                __hyperedge();\n            }\n            e = getNextEvent();\n        }\n    }\n    graphId.pop();\n    checkValid(e, XMLEvent.END_ELEMENT, \"graph\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3560,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __node() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"node\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    String id = null;\n    HashSet<Key> sentAttributes = new HashSet<Key>();\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            NodeAttribute attribute = NodeAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case ID:\n                    id = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid node attribute '%s'\", a.getName().getLocalPart());\n        }\n    }\n    if (id == null)\n        throw newParseError(e, \"node requires an id\");\n    sendNodeAdded(sourceId, id);\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        String desc;\n        pushback(e);\n        desc = __desc();\n        sendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n    } else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n        // TODO\n        pushback(e);\n        __locator();\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n            if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n                Data data;\n                pushback(e);\n                data = __data();\n                sendNodeAttributeAdded(sourceId, id, data.key.name, getValue(data));\n                sentAttributes.add(data.key);\n            } else {\n                pushback(e);\n                __port();\n            }\n            e = getNextEvent();\n        }\n    }\n    for (Key k : keys.values()) {\n        if ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL) && !sentAttributes.contains(k))\n            sendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n    }\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n        Location loc = e.getLocation();\n        System.err.printf(\"[WARNING] %d:%d graph inside node is not implemented\", loc.getLineNumber(), loc.getColumnNumber());\n        pushback(e);\n        __graph();\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"node\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3561,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __node() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"node\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    String id = null;\n    HashSet<Key> sentAttributes = new HashSet<Key>();\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            NodeAttribute attribute = NodeAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case ID:\n                    id = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid node attribute '%s'\", a.getName().getLocalPart());\n        }\n    }\n    if (id == null)\n        throw newParseError(e, \"node requires an id\");\n    sendNodeAdded(sourceId, id);\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        String desc;\n        pushback(e);\n        desc = __desc();\n        sendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n    } else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n        // TODO\n        pushback(e);\n        __locator();\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n            if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n                Data data;\n                pushback(e);\n                data = __data();\n                sendNodeAttributeAdded(sourceId, id, data.key.name, getValue(data));\n                sentAttributes.add(data.key);\n            } else {\n                pushback(e);\n                __port();\n            }\n            e = getNextEvent();\n        }\n    }\n    for (Key k : keys.values()) {\n        if ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL) && !sentAttributes.contains(k))\n            sendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n    }\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n        Location loc = e.getLocation();\n        System.err.printf(\"[WARNING] %d:%d graph inside node is not implemented\", loc.getLineNumber(), loc.getColumnNumber());\n        pushback(e);\n        __graph();\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"node\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3563,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __edge(boolean edgedefault) throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"edge\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    HashSet<Key> sentAttributes = new HashSet<Key>();\n    String id = null;\n    boolean directed = edgedefault;\n    String source = null;\n    String target = null;\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            EdgeAttribute attribute = EdgeAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case ID:\n                    id = a.getValue();\n                    break;\n                case DIRECTED:\n                    directed = Boolean.parseBoolean(a.getValue());\n                    break;\n                case SOURCE:\n                    source = a.getValue();\n                    break;\n                case TARGET:\n                    target = a.getValue();\n                    break;\n                case SOURCEPORT:\n                case TARGETPORT:\n                    throw newParseError(e, \"sourceport and targetport not implemented\");\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid graph attribute '%s'\", a.getName().getLocalPart());\n        }\n    }\n    if (id == null)\n        throw newParseError(e, \"edge must have an id\");\n    if (source == null || target == null)\n        throw newParseError(e, \"edge must have a source and a target\");\n    sendEdgeAdded(sourceId, id, source, target, directed);\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        String desc;\n        pushback(e);\n        desc = __desc();\n        sendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n            Data data;\n            pushback(e);\n            data = __data();\n            sendEdgeAttributeAdded(sourceId, id, data.key.name, getValue(data));\n            sentAttributes.add(data.key);\n            e = getNextEvent();\n        }\n    }\n    for (Key k : keys.values()) {\n        if ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL) && !sentAttributes.contains(k))\n            sendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n    }\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n        Location loc = e.getLocation();\n        System.err.printf(\"[WARNING] %d:%d graph inside node is not implemented\", loc.getLineNumber(), loc.getColumnNumber());\n        pushback(e);\n        __graph();\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"edge\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "edgedefault", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3564,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws XMLStreamException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __edge(boolean edgedefault) throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"edge\");\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    HashSet<Key> sentAttributes = new HashSet<Key>();\n    String id = null;\n    boolean directed = edgedefault;\n    String source = null;\n    String target = null;\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            EdgeAttribute attribute = EdgeAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case ID:\n                    id = a.getValue();\n                    break;\n                case DIRECTED:\n                    directed = Boolean.parseBoolean(a.getValue());\n                    break;\n                case SOURCE:\n                    source = a.getValue();\n                    break;\n                case TARGET:\n                    target = a.getValue();\n                    break;\n                case SOURCEPORT:\n                case TARGETPORT:\n                    throw newParseError(e, \"sourceport and targetport not implemented\");\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid graph attribute '%s'\", a.getName().getLocalPart());\n        }\n    }\n    if (id == null)\n        throw newParseError(e, \"edge must have an id\");\n    if (source == null || target == null)\n        throw newParseError(e, \"edge must have a source and a target\");\n    sendEdgeAdded(sourceId, id, source, target, directed);\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        String desc;\n        pushback(e);\n        desc = __desc();\n        sendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n            Data data;\n            pushback(e);\n            data = __data();\n            sendEdgeAttributeAdded(sourceId, id, data.key.name, getValue(data));\n            sentAttributes.add(data.key);\n            e = getNextEvent();\n        }\n    }\n    for (Key k : keys.values()) {\n        if ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL) && !sentAttributes.contains(k))\n            sendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n    }\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n        Location loc = e.getLocation();\n        System.err.printf(\"[WARNING] %d:%d graph inside node is not implemented\", loc.getLineNumber(), loc.getColumnNumber());\n        pushback(e);\n        __graph();\n        e = getNextEvent();\n    }\n    checkValid(e, XMLEvent.END_ELEMENT, \"edge\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "edgedefault", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3565,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceGraphML",
  "javadocTag" : "@throws IOException",
  "methodJavadoc" : "    /**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */",
  "methodSourceCode" : "private void __hyperedge() throws IOException, XMLStreamException{\n    XMLEvent e;\n    e = getNextEvent();\n    checkValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n    Location loc = e.getLocation();\n    System.err.printf(\"[WARNING] %d:%d hyperedge feature is not implemented\", loc.getLineNumber(), loc.getColumnNumber());\n    String id = null;\n    @SuppressWarnings(\"unchecked\")\n    Iterator<? extends Attribute> attributes = e.asStartElement().getAttributes();\n    while (attributes.hasNext()) {\n        Attribute a = attributes.next();\n        try {\n            HyperEdgeAttribute attribute = HyperEdgeAttribute.valueOf(toConstantName(a));\n            switch(attribute) {\n                case ID:\n                    id = a.getValue();\n                    break;\n            }\n        } catch (IllegalArgumentException ex) {\n            throw newParseError(e, \"invalid attribute '%s' for '<endpoint>'\", a.getName().getLocalPart());\n        }\n    }\n    if (id == null)\n        throw newParseError(e, \"'<hyperedge>' element requires a 'node' attribute\");\n    e = getNextEvent();\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n        pushback(e);\n        __desc();\n    } else {\n        while (isEvent(e, XMLEvent.START_ELEMENT, \"data\") || isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n            if (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n                pushback(e);\n                __data();\n            } else {\n                pushback(e);\n                __endpoint();\n            }\n            e = getNextEvent();\n        }\n    }\n    if (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n        loc = e.getLocation();\n        System.err.printf(\"[WARNING] %d:%d graph inside node is not implemented\", loc.getLineNumber(), loc.getColumnNumber());\n        pushback(e);\n        __graph();\n        e = getNextEvent();\n    }\n    e = getNextEvent();\n    checkValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n}",
  "classJavadoc" : "/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Stack;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.Location;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\nimport org.graphstream.stream.SourceBase;\n\n/**\n * GraphML is a comprehensive and easy-to-use file format for graphs. It\n * consists of a language core to describe the structural properties of a graph\n * and a flexible extension mechanism to add application-specific data. Its main\n * features include support of\n * <ul>\n * <li>directed, undirected, and mixed graphs,</li>\n * <li>hypergraphs,</li>\n * <li>hierarchical graphs,</li>\n * <li>graphical representations,</li>\n * <li>references to external data,</li>\n * <li>application-specific attribute data, and</li>\n * <li>light-weight parsers.</li>\n * </ul>\n * \n * Unlike many other file formats for graphs, GraphML does not use a custom\n * syntax. Instead, it is based on XML and hence ideally suited as a common\n * denominator for all kinds of services generating, archiving, or processing\n * graphs.\n * \n * <a href=\"http://graphml.graphdrawing.org/index.html\">Source</a>\n */\npublic class FileSourceGraphML extends SourceBase implements FileSource,\n\t\tXMLStreamConstants {\n\n\tprotected static enum Balise {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, DESC, DATA, LOCATOR, PORT, KEY, DEFAULT\n\t}\n\n\tprotected static enum GraphAttribute {\n\t\tID, EDGEDEFAULT\n\t}\n\n\tprotected static enum LocatorAttribute {\n\t\tXMLNS_XLINK, XLINK_HREF, XLINK_TYPE\n\t}\n\n\tprotected static enum NodeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum EdgeAttribute {\n\t\tID, SOURCE, SOURCEPORT, TARGET, TARGETPORT, DIRECTED\n\t}\n\n\tprotected static enum DataAttribute {\n\t\tKEY, ID\n\t}\n\n\tprotected static enum PortAttribute {\n\t\tNAME\n\t}\n\n\tprotected static enum EndPointAttribute {\n\t\tID, NODE, PORT, TYPE\n\t}\n\n\tprotected static enum EndPointType {\n\t\tIN, OUT, UNDIR\n\t}\n\n\tprotected static enum HyperEdgeAttribute {\n\t\tID\n\t}\n\n\tprotected static enum KeyAttribute {\n\t\tID, FOR, ATTR_NAME, ATTR_TYPE\n\t}\n\n\tprotected static enum KeyDomain {\n\t\tGRAPHML, GRAPH, NODE, EDGE, HYPEREDGE, PORT, ENDPOINT, ALL\n\t}\n\n\tprotected static enum KeyAttrType {\n\t\tBOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING\n\t}\n\n\tprotected static class Key {\n\t\tKeyDomain domain;\n\t\tString name;\n\t\tKeyAttrType type;\n\t\tString def = null;\n\n\t\tKey() {\n\t\t\tdomain = KeyDomain.ALL;\n\t\t\tname = null;\n\t\t\ttype = KeyAttrType.STRING;\n\t\t}\n\n\t\tObject getKeyValue(String value) {\n\t\t\tif (value == null)\n\t\t\t\treturn null;\n\n\t\t\tswitch (type) {\n\t\t\tcase STRING:\n\t\t\t\treturn value;\n\t\t\tcase INT:\n\t\t\t\treturn Integer.valueOf(value);\n\t\t\tcase LONG:\n\t\t\t\treturn Long.valueOf(value);\n\t\t\tcase FLOAT:\n\t\t\t\treturn Float.valueOf(value);\n\t\t\tcase DOUBLE:\n\t\t\t\treturn Double.valueOf(value);\n\t\t\tcase BOOLEAN:\n\t\t\t\treturn Boolean.valueOf(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tObject getDefaultValue() {\n\t\t\treturn getKeyValue(def);\n\t\t}\n\t}\n\n\tprotected static class Data {\n\t\tKey key;\n\t\tString id;\n\t\tString value;\n\t}\n\n\tprotected static class Locator {\n\t\tString href;\n\t\tString xlink;\n\t\tString type;\n\n\t\tLocator() {\n\t\t\txlink = \"http://www.w3.org/TR/2000/PR-xlink-20001220/\";\n\t\t\ttype = \"simple\";\n\t\t\thref = null;\n\t\t}\n\t}\n\n\tprotected static class Port {\n\t\tString name;\n\t\tString desc;\n\n\t\tLinkedList<Data> datas;\n\t\tLinkedList<Port> ports;\n\n\t\tPort() {\n\t\t\tname = null;\n\t\t\tdesc = null;\n\n\t\t\tdatas = new LinkedList<Data>();\n\t\t\tports = new LinkedList<Port>();\n\t\t}\n\t}\n\n\tprotected static class EndPoint {\n\t\tString id;\n\t\tString node;\n\t\tString port;\n\t\tString desc;\n\t\tEndPointType type;\n\n\t\tEndPoint() {\n\t\t\tid = null;\n\t\t\tnode = null;\n\t\t\tport = null;\n\t\t\tdesc = null;\n\t\t\ttype = EndPointType.UNDIR;\n\t\t}\n\t}\n\n\tprotected XMLEventReader reader;\n\tprotected HashMap<String, Key> keys;\n\tprotected LinkedList<Data> datas;\n\tprotected Stack<XMLEvent> events;\n\tprotected Stack<String> graphId;\n\tprotected int graphCounter;\n\n\t/**\n\t * Build a new source to parse an xml stream in GraphML format.\n\t */\n\tpublic FileSourceGraphML() {\n\t\tevents = new Stack<XMLEvent>();\n\t\tkeys = new HashMap<String, Key>();\n\t\tdatas = new LinkedList<Data>();\n\t\tgraphId = new Stack<String>();\n\t\tgraphCounter = 0;\n\t\tsourceId = String.format(\"<GraphML stream %x>\", System.nanoTime());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.lang.String)\n\t */\n\tpublic void readAll(String fileName) throws IOException {\n\t\treadAll(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.net.URL)\n\t */\n\tpublic void readAll(URL url) throws IOException {\n\t\treadAll(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.InputStream)\n\t */\n\tpublic void readAll(InputStream stream) throws IOException {\n\t\treadAll(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#readAll(java.io.Reader)\n\t */\n\tpublic void readAll(Reader reader) throws IOException {\n\t\tbegin(reader);\n\t\twhile (nextEvents())\n\t\t\t;\n\t\tend();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.lang.String)\n\t */\n\tpublic void begin(String fileName) throws IOException {\n\t\tbegin(new FileReader(fileName));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.net.URL)\n\t */\n\tpublic void begin(URL url) throws IOException {\n\t\tbegin(url.openStream());\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.InputStream)\n\t */\n\tpublic void begin(InputStream stream) throws IOException {\n\t\tbegin(new InputStreamReader(stream));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#begin(java.io.Reader)\n\t */\n\tpublic void begin(Reader reader) throws IOException {\n\t\topenStream(reader);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextEvents()\n\t */\n\tpublic boolean nextEvents() throws IOException {\n\t\ttry {\n\t\t\t__graphml();\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#nextStep()\n\t */\n\tpublic boolean nextStep() throws IOException {\n\t\treturn nextEvents();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSource#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tcloseStream();\n\t}\n\n\tprotected XMLEvent getNextEvent() throws IOException, XMLStreamException {\n\t\tskipWhiteSpaces();\n\n\t\tif (events.size() > 0)\n\t\t\treturn events.pop();\n\n\t\treturn reader.nextEvent();\n\t}\n\n\tprotected void pushback(XMLEvent e) {\n\t\tevents.push(e);\n\t}\n\n\tprivate XMLStreamException newParseError(XMLEvent e, String msg,\n\t\t\tObject... args) {\n\t\treturn new XMLStreamException(String.format(msg, args), e.getLocation());\n\t}\n\n\tprivate boolean isEvent(XMLEvent e, int type, String name) {\n\t\tboolean valid = e.getEventType() == type;\n\n\t\tif (valid) {\n\t\t\tswitch (type) {\n\t\t\tcase START_ELEMENT:\n\t\t\t\tvalid = e.asStartElement().getName().getLocalPart()\n\t\t\t\t\t\t.equals(name);\n\t\t\t\tbreak;\n\t\t\tcase END_ELEMENT:\n\t\t\t\tvalid = e.asEndElement().getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase ATTRIBUTE:\n\t\t\t\tvalid = ((Attribute) e).getName().getLocalPart().equals(name);\n\t\t\t\tbreak;\n\t\t\tcase CHARACTERS:\n\t\t\tcase NAMESPACE:\n\t\t\tcase PROCESSING_INSTRUCTION:\n\t\t\tcase COMMENT:\n\t\t\tcase START_DOCUMENT:\n\t\t\tcase END_DOCUMENT:\n\t\t\tcase DTD:\n\t\t\t}\n\t\t}\n\n\t\treturn valid;\n\t}\n\n\tprivate void checkValid(XMLEvent e, int type, String name)\n\t\t\tthrows XMLStreamException {\n\t\tboolean valid = isEvent(e, type, name);\n\n\t\tif (!valid)\n\t\t\tthrow newParseError(e, \"expecting %s, got %s\", gotWhat(type, name),\n\t\t\t\t\tgotWhat(e));\n\t}\n\n\tprivate String gotWhat(XMLEvent e) {\n\t\tString v = null;\n\n\t\tswitch (e.getEventType()) {\n\t\tcase START_ELEMENT:\n\t\t\tv = e.asStartElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase END_ELEMENT:\n\t\t\tv = e.asEndElement().getName().getLocalPart();\n\t\t\tbreak;\n\t\tcase ATTRIBUTE:\n\t\t\tv = ((Attribute) e).getName().getLocalPart();\n\t\t\tbreak;\n\t\t}\n\n\t\treturn gotWhat(e.getEventType(), v);\n\t}\n\n\tprivate String gotWhat(int type, String v) {\n\t\tswitch (type) {\n\t\tcase START_ELEMENT:\n\t\t\treturn String.format(\"'<%s>'\", v);\n\t\tcase END_ELEMENT:\n\t\t\treturn String.format(\"'</%s>'\", v);\n\t\tcase ATTRIBUTE:\n\t\t\treturn String.format(\"attribute '%s'\", v);\n\t\tcase NAMESPACE:\n\t\t\treturn \"namespace\";\n\t\tcase PROCESSING_INSTRUCTION:\n\t\t\treturn \"processing instruction\";\n\t\tcase COMMENT:\n\t\t\treturn \"comment\";\n\t\tcase START_DOCUMENT:\n\t\t\treturn \"document start\";\n\t\tcase END_DOCUMENT:\n\t\t\treturn \"document end\";\n\t\tcase DTD:\n\t\t\treturn \"dtd\";\n\t\tcase CHARACTERS:\n\t\t\treturn \"characters\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n\n\tprivate Object getValue(Data data) {\n\t\tswitch (data.key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.parseBoolean(data.value);\n\t\tcase INT:\n\t\t\treturn Integer.parseInt(data.value);\n\t\tcase LONG:\n\t\t\treturn Long.parseLong(data.value);\n\t\tcase FLOAT:\n\t\t\treturn Float.parseFloat(data.value);\n\t\tcase DOUBLE:\n\t\t\treturn Double.parseDouble(data.value);\n\t\tcase STRING:\n\t\t\treturn data.value;\n\t\t}\n\n\t\treturn data.value;\n\t}\n\n\tprivate Object getDefaultValue(Key key) {\n\t\tswitch (key.type) {\n\t\tcase BOOLEAN:\n\t\t\treturn Boolean.TRUE;\n\t\tcase INT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Integer.valueOf(key.def);\n\n\t\t\treturn Integer.valueOf(0);\n\t\tcase LONG:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Long.valueOf(key.def);\n\n\t\t\treturn Long.valueOf(0);\n\t\tcase FLOAT:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Float.valueOf(key.def);\n\n\t\t\treturn Float.valueOf(0.0f);\n\t\tcase DOUBLE:\n\t\t\tif (key.def != null)\n\t\t\t\treturn Double.valueOf(key.def);\n\n\t\t\treturn Double.valueOf(0.0);\n\t\tcase STRING:\n\t\t\tif (key.def != null)\n\t\t\t\treturn key.def;\n\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn key.def != null ? key.def : Boolean.TRUE;\n\t}\n\n\tprivate void skipWhiteSpaces() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\tdo {\n\t\t\tif (events.size() > 0)\n\t\t\t\te = events.pop();\n\t\t\telse\n\t\t\t\te = reader.nextEvent();\n\t\t} while (isEvent(e, XMLEvent.CHARACTERS, null)\n\t\t\t\t&& e.asCharacters().getData().matches(\"^\\\\s*$\"));\n\n\t\tpushback(e);\n\t}\n\n\tprotected void openStream(Reader stream) throws IOException {\n\t\tif (reader != null)\n\t\t\tcloseStream();\n\n\t\ttry {\n\t\t\tXMLEvent e;\n\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.START_DOCUMENT, null);\n\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} catch (FactoryConfigurationError e) {\n\t\t\tthrow new IOException(e);\n\t\t}\n\t}\n\n\tprotected void closeStream() throws IOException {\n\t\ttry {\n\t\t\treader.close();\n\t\t} catch (XMLStreamException e) {\n\t\t\tthrow new IOException(e);\n\t\t} finally {\n\t\t\treader = null;\n\t\t}\n\t}\n\n\tprotected String toConstantName(Attribute a) {\n\t\treturn toConstantName(a.getName().getLocalPart());\n\t}\n\n\tprotected String toConstantName(String value) {\n\t\treturn value.toUpperCase().replaceAll(\"\\\\W\", \"_\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graphml  ((desc)?,(key)*,((data)|(graph))*)>\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graphml() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graphml\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"key\")) {\n\t\t\tpushback(e);\n\t\t\t__key();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tpushback(e);\n\n\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t__data();\n\t\t\t} else {\n\t\t\t\t__graph();\n\t\t\t}\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graphml\");\n\t}\n\n\tprivate String __characters() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tpushback(e);\n\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT desc (#PCDATA)>\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate String __desc() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tString desc;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"desc\");\n\n\t\tdesc = __characters();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"desc\");\n\n\t\treturn desc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT locator EMPTY>\n\t * <!ATTLIST locator \n\t *           xmlns:xlink   CDATA    #FIXED    \"http://www.w3.org/TR/2000/PR-xlink-20001220/\"\n\t *           xlink:href    CDATA    #REQUIRED\n\t *           xlink:type    (simple) #FIXED    \"simple\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Locator __locator() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"locator\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tLocator loc = new Locator();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tLocatorAttribute attribute = LocatorAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase XMLNS_XLINK:\n\t\t\t\t\tloc.xlink = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_HREF:\n\t\t\t\t\tloc.href = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase XLINK_TYPE:\n\t\t\t\t\tloc.type = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid locator attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"locator\");\n\n\t\tif (loc.href == null)\n\t\t\tthrow newParseError(e, \"locator requires an href\");\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT key (#PCDATA)>\n\t * <!ATTLIST key \n\t *           id  ID                                            #REQUIRED\n\t *           for (graphml|graph|node|edge|hyperedge|port|endpoint|all) \"all\"\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __key() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"key\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tKeyDomain domain = KeyDomain.ALL;\n\t\tKeyAttrType type = KeyAttrType.STRING;\n\t\tString name = null;\n\t\tString def = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tKeyAttribute attribute = KeyAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase FOR:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdomain = KeyDomain\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key domain '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttype = KeyAttrType\n\t\t\t\t\t\t\t\t.valueOf(toConstantName(a.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid key type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_NAME:\n\t\t\t\t\tname = a.getValue();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid key attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"default\")) {\n\t\t\tdef = __characters();\n\n\t\t\te = getNextEvent();\n\t\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"default\");\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"key\");\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"key requires an id\");\n\n\t\tif (name == null)\n\t\t\tname = id;\n\n\t\tSystem.out.printf(\"add key \\\"%s\\\"\\n\", id);\n\n\t\tKey k = new Key();\n\t\tk.name = name;\n\t\tk.domain = domain;\n\t\tk.type = type;\n\t\tk.def = def;\n\n\t\tkeys.put(id, k);\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT port ((desc)?,((data)|(port))*)>\n\t * <!ATTLIST port\n\t *           name    NMTOKEN  #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Port __port() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"port\");\n\n\t\tPort port = new Port();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tPortAttribute attribute = PortAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NAME:\n\t\t\t\t\tport.name = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<port>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (port.name == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<port>' element requires a 'name' attribute\");\n\n\t\te = getNextEvent();\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tport.desc = __desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tport.datas.add(data);\n\t\t\t\t} else {\n\t\t\t\t\tPort portChild;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tportChild = __port();\n\n\t\t\t\t\tport.ports.add(portChild);\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"port\");\n\n\t\treturn port;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT endpoint ((desc)?)>\n\t * <!ATTLIST endpoint \n\t *           id    ID             #IMPLIED\n\t *           node  IDREF          #REQUIRED\n\t *           port  NMTOKEN        #IMPLIED\n\t *           type  (in|out|undir) \"undir\"\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate EndPoint __endpoint() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"endpoint\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tEndPoint ep = new EndPoint();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEndPointAttribute attribute = EndPointAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase NODE:\n\t\t\t\t\tep.node = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tep.id = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase PORT:\n\t\t\t\t\tep.port = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tep.type = EndPointType.valueOf(toConstantName(a\n\t\t\t\t\t\t\t\t.getValue()));\n\t\t\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\t\t\tthrow newParseError(e, \"invalid end point type '%s'\",\n\t\t\t\t\t\t\t\ta.getValue());\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (ep.node == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<endpoint>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tep.desc = __desc();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"endpoint\");\n\n\t\treturn ep;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT data  (#PCDATA)>\n\t * <!ATTLIST data \n\t *           key      IDREF        #REQUIRED\n\t *           id       ID           #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @return\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate Data __data() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"data\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\t\tString key = null, id = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tDataAttribute attribute = DataAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase KEY:\n\t\t\t\t\tkey = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid attribute '%s' for '<data>'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (key == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<data>' element must have a 'key' attribute\");\n\n\t\te = getNextEvent();\n\n\t\twhile (e.getEventType() == XMLEvent.CHARACTERS) {\n\t\t\tbuffer.append(e.asCharacters());\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"data\");\n\n\t\tif (keys.containsKey(key))\n\t\t\tnewParseError(e, \"unknown key '%s'\", key);\n\n\t\tData d = new Data();\n\n\t\td.key = keys.get(key);\n\t\td.id = id;\n\t\td.value = buffer.toString();\n\n\t\treturn d;\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT graph    ((desc)?,((((data)|(node)|(edge)|(hyperedge))*)|(locator)))>\n\t * <!ATTLIST graph    \n\t *     id          ID                    #IMPLIED\n\t *     edgedefault (directed|undirected) #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __graph() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"graph\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tString desc = null;\n\t\tboolean directed = false;\n\t\tboolean directedSet = false;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tGraphAttribute attribute = GraphAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EDGEDEFAULT:\n\t\t\t\t\tif (a.getValue().equals(\"directed\"))\n\t\t\t\t\t\tdirected = true;\n\t\t\t\t\telse if (a.getValue().equals(\"undirected\"))\n\t\t\t\t\t\tdirected = false;\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\t\"invalid 'edgefault' value '%s'\", a.getValue());\n\n\t\t\t\t\tdirectedSet = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (!directedSet)\n\t\t\tthrow newParseError(e, \"graph requires attribute 'edgedefault'\");\n\n\t\tString gid = \"\";\n\n\t\tif (graphId.size() > 0)\n\t\t\tgid = graphId.peek() + \":\";\n\n\t\tif (id != null)\n\t\t\tgid += id;\n\t\telse\n\t\t\tgid += Integer.toString(graphCounter++);\n\n\t\tgraphId.push(gid);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendGraphAttributeAdded(sourceId, \"desc\", desc);\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t\t// TODO\n\t\t\te = getNextEvent();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"node\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"edge\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"hyperedge\")) {\n\t\t\t\tpushback(e);\n\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tdatas.add(__data());\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"node\")) {\n\t\t\t\t\t__node();\n\t\t\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"edge\")) {\n\t\t\t\t\t__edge(directed);\n\t\t\t\t} else {\n\t\t\t\t\t__hyperedge();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tgraphId.pop();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"graph\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT node   (desc?,(((data|port)*,graph?)|locator))>\n\t * <!ATTLIST node   \n\t *     \t\t id        ID      #REQUIRED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __node() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"node\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tString id = null;\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tNodeAttribute attribute = NodeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid node attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"node requires an id\");\n\n\t\tsendNodeAdded(sourceId, id);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendNodeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else if (isEvent(e, XMLEvent.START_ELEMENT, \"locator\")) {\n\t\t\t// TODO\n\t\t\tpushback(e);\n\t\t\t__locator();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"port\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tData data;\n\n\t\t\t\t\tpushback(e);\n\t\t\t\t\tdata = __data();\n\n\t\t\t\t\tsendNodeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\t\tsentAttributes.add(data.key);\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__port();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.NODE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendNodeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"node\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT edge ((desc)?,(data)*,(graph)?)>\n\t * <!ATTLIST edge \n\t *           id         ID           #IMPLIED\n\t *           source     IDREF        #REQUIRED\n\t *           sourceport NMTOKEN      #IMPLIED\n\t *           target     IDREF        #REQUIRED\n\t *           targetport NMTOKEN      #IMPLIED\n\t *           directed   (true|false) #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @param edgedefault\n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __edge(boolean edgedefault) throws IOException,\n\t\t\tXMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"edge\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\tHashSet<Key> sentAttributes = new HashSet<Key>();\n\t\tString id = null;\n\t\tboolean directed = edgedefault;\n\t\tString source = null;\n\t\tString target = null;\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tEdgeAttribute attribute = EdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DIRECTED:\n\t\t\t\t\tdirected = Boolean.parseBoolean(a.getValue());\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCE:\n\t\t\t\t\tsource = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase TARGET:\n\t\t\t\t\ttarget = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SOURCEPORT:\n\t\t\t\tcase TARGETPORT:\n\t\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\t\"sourceport and targetport not implemented\");\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e, \"invalid graph attribute '%s'\", a\n\t\t\t\t\t\t.getName().getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e, \"edge must have an id\");\n\n\t\tif (source == null || target == null)\n\t\t\tthrow newParseError(e, \"edge must have a source and a target\");\n\n\t\tsendEdgeAdded(sourceId, id, source, target, directed);\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tString desc;\n\n\t\t\tpushback(e);\n\t\t\tdesc = __desc();\n\n\t\t\tsendEdgeAttributeAdded(sourceId, id, \"desc\", desc);\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\tData data;\n\n\t\t\t\tpushback(e);\n\t\t\t\tdata = __data();\n\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, data.key.name,\n\t\t\t\t\t\tgetValue(data));\n\n\t\t\t\tsentAttributes.add(data.key);\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tfor (Key k : keys.values()) {\n\t\t\tif ((k.domain == KeyDomain.EDGE || k.domain == KeyDomain.ALL)\n\t\t\t\t\t&& !sentAttributes.contains(k))\n\t\t\t\tsendEdgeAttributeAdded(sourceId, id, k.name, getDefaultValue(k));\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tLocation loc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"edge\");\n\t}\n\n\t/**\n\t * <pre>\n\t * <!ELEMENT hyperedge  ((desc)?,((data)|(endpoint))*,(graph)?)>\n\t * <!ATTLIST hyperedge \n\t *           id     ID      #IMPLIED\n\t * >\n\t * </pre>\n\t * \n\t * @throws IOException\n\t * @throws XMLStreamException\n\t */\n\tprivate void __hyperedge() throws IOException, XMLStreamException {\n\t\tXMLEvent e;\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.START_ELEMENT, \"hyperedge\");\n\n\t\tLocation loc = e.getLocation();\n\n\t\tSystem.err.printf(\n\t\t\t\t\"[WARNING] %d:%d hyperedge feature is not implemented\",\n\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\tString id = null;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIterator<? extends Attribute> attributes = e.asStartElement()\n\t\t\t\t.getAttributes();\n\n\t\twhile (attributes.hasNext()) {\n\t\t\tAttribute a = attributes.next();\n\n\t\t\ttry {\n\t\t\t\tHyperEdgeAttribute attribute = HyperEdgeAttribute\n\t\t\t\t\t\t.valueOf(toConstantName(a));\n\n\t\t\t\tswitch (attribute) {\n\t\t\t\tcase ID:\n\t\t\t\t\tid = a.getValue();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (IllegalArgumentException ex) {\n\t\t\t\tthrow newParseError(e,\n\t\t\t\t\t\t\"invalid attribute '%s' for '<endpoint>'\", a.getName()\n\t\t\t\t\t\t\t\t.getLocalPart());\n\t\t\t}\n\t\t}\n\n\t\tif (id == null)\n\t\t\tthrow newParseError(e,\n\t\t\t\t\t\"'<hyperedge>' element requires a 'node' attribute\");\n\n\t\te = getNextEvent();\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"desc\")) {\n\t\t\tpushback(e);\n\t\t\t__desc();\n\t\t} else {\n\t\t\twhile (isEvent(e, XMLEvent.START_ELEMENT, \"data\")\n\t\t\t\t\t|| isEvent(e, XMLEvent.START_ELEMENT, \"endpoint\")) {\n\t\t\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"data\")) {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__data();\n\t\t\t\t} else {\n\t\t\t\t\tpushback(e);\n\t\t\t\t\t__endpoint();\n\t\t\t\t}\n\n\t\t\t\te = getNextEvent();\n\t\t\t}\n\t\t}\n\n\t\tif (isEvent(e, XMLEvent.START_ELEMENT, \"graph\")) {\n\t\t\tloc = e.getLocation();\n\n\t\t\tSystem.err.printf(\n\t\t\t\t\t\"[WARNING] %d:%d graph inside node is not implemented\",\n\t\t\t\t\tloc.getLineNumber(), loc.getColumnNumber());\n\n\t\t\tpushback(e);\n\t\t\t__graph();\n\n\t\t\te = getNextEvent();\n\t\t}\n\n\t\te = getNextEvent();\n\t\tcheckValid(e, XMLEvent.END_ELEMENT, \"hyperedge\");\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "nextEvents", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextEvents() throws IOException" ], [ "nextStep", "org.graphstream.stream.file", "FileSourceGraphML", "public boolean nextStep() throws IOException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(String value)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getNextEvent", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEvent getNextEvent() throws IOException, XMLStreamException" ], [ "toConstantName", "org.graphstream.stream.file", "FileSourceGraphML", "protected String toConstantName(Attribute a)" ], [ "elementSinks", "org.graphstream.stream", "SourceBase", "public Iterable<ElementSink> elementSinks()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "attributeSinks", "org.graphstream.stream", "SourceBase", "public Iterable<AttributeSink> attributeSinks()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "reader", "org.graphstream.stream.file", "FileSourceGraphML", "protected XMLEventReader reader;" ], [ "keys", "org.graphstream.stream.file", "FileSourceGraphML", "protected HashMap<String,Key> keys;" ], [ "datas", "org.graphstream.stream.file", "FileSourceGraphML", "protected LinkedList<Data> datas;" ], [ "events", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<XMLEvent> events;" ], [ "graphId", "org.graphstream.stream.file", "FileSourceGraphML", "protected Stack<String> graphId;" ], [ "graphCounter", "org.graphstream.stream.file", "FileSourceGraphML", "protected int graphCounter;" ], [ "attrSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<AttributeSink> attrSinks;" ], [ "eltsSinks", "org.graphstream.stream", "SourceBase", "protected ArrayList<ElementSink> eltsSinks;" ], [ "eventQueue", "org.graphstream.stream", "SourceBase", "protected LinkedList<SourceBase.GraphEvent> eventQueue;" ], [ "eventProcessing", "org.graphstream.stream", "SourceBase", "protected boolean eventProcessing;" ], [ "sourceId", "org.graphstream.stream", "SourceBase", "protected String sourceId;" ], [ "sourceTime", "org.graphstream.stream", "SourceBase", "protected SourceTime sourceTime;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3569,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSourceFactory",
  "javadocTag" : "@throws IOException If the file is not readable or accessible.",
  "methodJavadoc" : "    /**\n\t * Create a file input for the given file name.\n\t * \n\t * <p>\n\t * This method first tests if the file is a regular file and is readable. If\n\t * so, it opens it and reads the magic cookie to test the known file formats\n\t * that can be inferred from their header. If it works, it returns a file\n\t * input for the format. Else it looks at the file name extension, and\n\t * returns a file input for the extension. Finally if all fail, it throws a\n\t * NotFoundException.\n\t * </p>\n\t * \n\t * <p>\n\t * Notice that this method only creates the file input and does not connect\n\t * it to a graph.\n\t * </p>\n\t * \n\t * @param fileName\n\t *            Name of the graph file.\n\t * @return A graph reader suitable for the fileName graph format.\n\t * @throws IOException\n\t *             If the file is not readable or accessible.\n\t */",
  "methodSourceCode" : "public static FileSource sourceFor(String fileName) throws IOException{\n    File file = new File(fileName);\n    if (!file.isFile())\n        throw new IOException(\"not a regular file '\" + fileName + \"'\");\n    if (!file.canRead())\n        throw new IOException(\"not a readable file '\" + fileName + \"'\");\n    // Try to read the beginning of the file.\n    RandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n    byte[] b = new byte[10];\n    int n = in.read(b, 0, 10);\n    // System.err.printf( \"[\" );\n    // for( int i=0; i<n; ++i )\n    // {\n    // System.err.printf( \"%c\", (char)b[i] );\n    // }\n    // System.err.printf( \"]%n\" );\n    in.close();\n    // Surely match a DGS file, as DGS files are well done and have a\n    // signature.\n    if (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n        if (n >= 6 && b[3] == '0' && b[4] == '0') {\n            if (b[5] == '1' || b[5] == '2') {\n                return new FileSourceDGS1And2();\n            } else if (b[5] == '3' || b[5] == '4') {\n                return new FileSourceDGS();\n            }\n        }\n    }\n    // Maybe match a GML file as most GML files begin by the line \"graph [\",\n    // but not sure, you may create a GML file that starts by a comment, an\n    // empty line, with any kind of spaces, etc.\n    if (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p' && b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n        return new FileSourceTLP();\n    // The web reader.\n    String flc = fileName.toLowerCase();\n    // If we did not found anything, we try with the filename extension ...\n    if (flc.endsWith(\".dgs\")) {\n        return new FileSourceDGS();\n    }\n    if (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n        return new org.graphstream.stream.file.FileSourceGML();\n    }\n    if (flc.endsWith(\".net\")) {\n        return new FileSourcePajek();\n    }\n    if (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n        // return new GraphReaderChaco();\n    }\n    if (flc.endsWith(\".dot\")) {\n        return new org.graphstream.stream.file.FileSourceDOT();\n    }\n    if (flc.endsWith(\".edge\")) {\n        return new FileSourceEdge();\n    }\n    if (flc.endsWith(\".lgl\")) {\n        return new FileSourceLGL();\n    }\n    if (flc.endsWith(\".ncol\")) {\n        return new FileSourceNCol();\n    }\n    if (flc.endsWith(\".tlp\")) {\n        return new FileSourceTLP();\n    }\n    if (flc.endsWith(\".xml\")) {\n        String root = getXMLRootElement(fileName);\n        if (root.equalsIgnoreCase(\"gexf\"))\n            return new FileSourceGEXF();\n        return new FileSourceGraphML();\n    }\n    if (flc.endsWith(\".gexf\")) {\n        return new FileSourceGEXF();\n    }\n    return null;\n}",
  "classJavadoc" : "/**\n * File source factory.\n * \n * <p>\n * A graph reader factory allow to create readers according to a given file. It\n * both tries to read the start of the file to infer its type (works well for\n * file formats with a magic cookie or header), and if it fails it tries to look\n * at the file name extension.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\nimport javax.xml.stream.FactoryConfigurationError;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.XMLEvent;\n\n/**\n * File source factory.\n * \n * <p>\n * A graph reader factory allow to create readers according to a given file. It\n * both tries to read the start of the file to infer its type (works well for\n * file formats with a magic cookie or header), and if it fails it tries to look\n * at the file name extension.\n * </p>\n */\npublic class FileSourceFactory {\n\t/**\n\t * Create a file input for the given file name.\n\t * \n\t * <p>\n\t * This method first tests if the file is a regular file and is readable. If\n\t * so, it opens it and reads the magic cookie to test the known file formats\n\t * that can be inferred from their header. If it works, it returns a file\n\t * input for the format. Else it looks at the file name extension, and\n\t * returns a file input for the extension. Finally if all fail, it throws a\n\t * NotFoundException.\n\t * </p>\n\t * \n\t * <p>\n\t * Notice that this method only creates the file input and does not connect\n\t * it to a graph.\n\t * </p>\n\t * \n\t * @param fileName\n\t *            Name of the graph file.\n\t * @return A graph reader suitable for the fileName graph format.\n\t * @throws IOException\n\t *             If the file is not readable or accessible.\n\t */\n\tpublic static FileSource sourceFor(String fileName) throws IOException {\n\t\tFile file = new File(fileName);\n\n\t\tif (!file.isFile())\n\t\t\tthrow new IOException(\"not a regular file '\" + fileName + \"'\");\n\n\t\tif (!file.canRead())\n\t\t\tthrow new IOException(\"not a readable file '\" + fileName + \"'\");\n\n\t\t// Try to read the beginning of the file.\n\n\t\tRandomAccessFile in = new RandomAccessFile(fileName, \"r\");\n\n\t\tbyte b[] = new byte[10];\n\t\tint n = in.read(b, 0, 10);\n\n\t\t// System.err.printf( \"[\" );\n\t\t// for( int i=0; i<n; ++i )\n\t\t// {\n\t\t// System.err.printf( \"%c\", (char)b[i] );\n\t\t// }\n\t\t// System.err.printf( \"]%n\" );\n\n\t\tin.close();\n\n\t\t// Surely match a DGS file, as DGS files are well done and have a\n\t\t// signature.\n\n\t\tif (n >= 3 && b[0] == 'D' && b[1] == 'G' && b[2] == 'S') {\n\t\t\tif (n >= 6 && b[3] == '0' && b[4] == '0') {\n\t\t\t\tif (b[5] == '1' || b[5] == '2') {\n\t\t\t\t\treturn new FileSourceDGS1And2();\n\t\t\t\t} else if (b[5] == '3' || b[5] == '4') {\n\t\t\t\t\treturn new FileSourceDGS();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Maybe match a GML file as most GML files begin by the line \"graph [\",\n\t\t// but not sure, you may create a GML file that starts by a comment, an\n\t\t// empty line, with any kind of spaces, etc.\n\n\t\tif (n >= 7 && b[0] == 'g' && b[1] == 'r' && b[2] == 'a' && b[3] == 'p'\n\t\t\t\t&& b[4] == 'h' && b[5] == ' ' && b[6] == '[') {\n\t\t\treturn new org.graphstream.stream.file.FileSourceGML();\n\t\t}\n\n\t\tif (n >= 4 && b[0] == '(' && b[1] == 't' && b[2] == 'l' && b[3] == 'p')\n\t\t\treturn new FileSourceTLP();\n\n\t\t// The web reader.\n\n\t\tString flc = fileName.toLowerCase();\n\n\t\t// If we did not found anything, we try with the filename extension ...\n\n\t\tif (flc.endsWith(\".dgs\")) {\n\t\t\treturn new FileSourceDGS();\n\t\t}\n\n\t\tif (flc.endsWith(\".gml\") || flc.endsWith(\".dgml\")) {\n\t\t\treturn new org.graphstream.stream.file.FileSourceGML();\n\t\t}\n\n\t\tif (flc.endsWith(\".net\")) {\n\t\t\treturn new FileSourcePajek();\n\t\t}\n\n\t\tif (flc.endsWith(\".chaco\") || flc.endsWith(\".graph\")) {\n\t\t\t// return new GraphReaderChaco();\n\t\t}\n\n\t\tif (flc.endsWith(\".dot\")) {\n\t\t\treturn new org.graphstream.stream.file.FileSourceDOT();\n\t\t}\n\n\t\tif (flc.endsWith(\".edge\")) {\n\t\t\treturn new FileSourceEdge();\n\t\t}\n\n\t\tif (flc.endsWith(\".lgl\")) {\n\t\t\treturn new FileSourceLGL();\n\t\t}\n\n\t\tif (flc.endsWith(\".ncol\")) {\n\t\t\treturn new FileSourceNCol();\n\t\t}\n\n\t\tif (flc.endsWith(\".tlp\")) {\n\t\t\treturn new FileSourceTLP();\n\t\t}\n\n\t\tif (flc.endsWith(\".xml\")) {\n\t\t\tString root = getXMLRootElement(fileName);\n\n\t\t\tif (root.equalsIgnoreCase(\"gexf\"))\n\t\t\t\treturn new FileSourceGEXF();\n\t\t\t\n\t\t\treturn new FileSourceGraphML();\n\t\t}\n\n\t\tif (flc.endsWith(\".gexf\")) {\n\t\t\treturn new FileSourceGEXF();\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic static String getXMLRootElement(String fileName) throws IOException {\n\t\tFileReader stream = new FileReader(fileName);\n\t\tXMLEventReader reader;\n\t\tXMLEvent e;\n\t\tString root;\n\n\t\ttry {\n\t\t\treader = XMLInputFactory.newInstance().createXMLEventReader(stream);\n\n\t\t\tdo {\n\t\t\t\te = reader.nextEvent();\n\t\t\t} while (!e.isStartElement() && !e.isEndDocument());\n\n\t\t\tif (e.isEndDocument())\n\t\t\t\tthrow new IOException(\n\t\t\t\t\t\t\"document ended before catching root element\");\n\n\t\t\troot = e.asStartElement().getName().getLocalPart();\n\t\t\treader.close();\n\t\t\tstream.close();\n\n\t\t\treturn root;\n\t\t} catch (XMLStreamException ex) {\n\t\t\tthrow new IOException(ex);\n\t\t} catch (FactoryConfigurationError ex) {\n\t\t\tthrow new IOException(ex);\n\t\t}\n\t}\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "fileName", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ], [ "nextEvents", "org.graphstream.stream.file", "FileSource", "public abstract boolean nextEvents() throws IOException" ], [ "nextStep", "org.graphstream.stream.file", "FileSource", "public abstract boolean nextStep() throws IOException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 3573,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.stream.file",
  "className" : "FileSinkImages",
  "javadocTag" : "@param height",
  "methodJavadoc" : "    /**\n\t * Set a custom resolution.\n\t * \n\t * @param width\n\t * @param height\n\t */",
  "methodSourceCode" : "public void setResolution(int width, int height){\n    if (resolution == null || resolution.getWidth() != width || resolution.getHeight() != height) {\n        resolution = new CustomResolution(width, height);\n        initImage();\n    }\n}",
  "classJavadoc" : "/**\n * Output graph in image files.\n * \n * <p>\n * Given a prefix \"dir/prefix_\" and an output policy, this sink will output\n * graph in an image file which name is prefix + a growing counter.\n * </p>\n * <p>\n * Then images can be processed to produce a movie. For example, with mencoder,\n * the following produce high quality movie :\n * </p>\n * \n * <pre>\n * \n * #!/bin/bash\n * \n * EXT=png\n * CODEC=msmpeg4v2\n * BITRATE=6000\n * OPT=\"vcodec=mpeg4:vqscale=2:vhq:v4mv:trell:autoaspect\"\n * FPS=15\n * PREFIX=$1\n * OUTPUT=$2\n * \n * mencoder \"mf://$PREFIX*.$EXT\" -mf fps=$FPS:type=$EXT -ovc lavc -lavcopts $OPTS -o $OUTPUT -nosound -vf scale\n * \n * </pre>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.stream.file;\n\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.imageio.ImageIO;\n\nimport org.graphstream.graph.Graph;\nimport org.graphstream.stream.GraphReplay;\nimport org.graphstream.stream.ProxyPipe;\nimport org.graphstream.stream.Sink;\nimport org.graphstream.stream.file.FileSourceDGS;\nimport org.graphstream.stream.thread.ThreadProxyPipe;\nimport org.graphstream.ui.geom.Point3;\nimport org.graphstream.ui.graphicGraph.GraphicGraph;\nimport org.graphstream.ui.layout.Layout;\nimport org.graphstream.ui.layout.LayoutRunner;\nimport org.graphstream.ui.layout.Layouts;\nimport org.graphstream.ui.swingViewer.GraphRenderer;\n\n/**\n * Output graph in image files.\n * \n * <p>\n * Given a prefix \"dir/prefix_\" and an output policy, this sink will output\n * graph in an image file which name is prefix + a growing counter.\n * </p>\n * <p>\n * Then images can be processed to produce a movie. For example, with mencoder,\n * the following produce high quality movie :\n * </p>\n * \n * <pre>\n * \n * #!/bin/bash\n * \n * EXT=png\n * CODEC=msmpeg4v2\n * BITRATE=6000\n * OPT=\"vcodec=mpeg4:vqscale=2:vhq:v4mv:trell:autoaspect\"\n * FPS=15\n * PREFIX=$1\n * OUTPUT=$2\n * \n * mencoder \"mf://$PREFIX*.$EXT\" -mf fps=$FPS:type=$EXT -ovc lavc -lavcopts $OPTS -o $OUTPUT -nosound -vf scale\n * \n * </pre>\n */\npublic class FileSinkImages implements FileSink {\n\t/**\n\t * Output resolutions.\n\t */\n\tpublic static interface Resolution {\n\t\tint getWidth();\n\n\t\tint getHeight();\n\t}\n\n\t/**\n\t * Common resolutions.\n\t */\n\tpublic static enum Resolutions implements Resolution {\n\t\tQVGA(320, 240), CGA(320, 200), VGA(640, 480), NTSC(720, 480), PAL(768,\n\t\t\t\t576), WVGA_5by3(800, 480), SVGA(800, 600), WVGA_16by9(854, 480), WSVGA(\n\t\t\t\t1024, 600), XGA(1024, 768), HD720(1280, 720), WXGA_5by3(1280,\n\t\t\t\t768), WXGA_8by5(1280, 800), SXGA(1280, 1024), FWXGA(1366, 768), SXGAp(\n\t\t\t\t1400, 1050), WSXGAp(1680, 1050), UXGA(1600, 1200), HD1080(1920,\n\t\t\t\t1080), WUXGA(1920, 1200), TwoK(2048, 1080), QXGA(2048, 1536), WQXGA(\n\t\t\t\t2560, 1600), QSXGA(2560, 2048), UHD_4K(3840, 2160), UHD_8K_16by9(\n\t\t\t\t7680, 4320), UHD_8K_17by8(8192, 4320), UHD_8K_1by1(8192, 8192)\n\n\t\t;\n\n\t\tfinal int width, height;\n\n\t\tResolutions(int width, int height) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t}\n\n\t\tpublic int getWidth() {\n\t\t\treturn width;\n\t\t}\n\n\t\tpublic int getHeight() {\n\t\t\treturn height;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%s (%dx%d)\", name(), width, height);\n\t\t}\n\t}\n\n\t/**\n\t * User-defined resolution.\n\t */\n\tpublic static class CustomResolution implements Resolution {\n\t\tfinal int width, height;\n\n\t\tpublic CustomResolution(int width, int height) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t}\n\n\t\tpublic int getWidth() {\n\t\t\treturn width;\n\t\t}\n\n\t\tpublic int getHeight() {\n\t\t\treturn height;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%dx%d\", width, height);\n\t\t}\n\t}\n\n\t/**\n\t * Output image type.\n\t */\n\tpublic static enum OutputType {\n\t\tPNG(BufferedImage.TYPE_INT_ARGB, \"png\"), JPG(\n\t\t\t\tBufferedImage.TYPE_INT_RGB, \"jpg\"), png(\n\t\t\t\tBufferedImage.TYPE_INT_ARGB, \"png\"), jpg(\n\t\t\t\tBufferedImage.TYPE_INT_RGB, \"jpg\")\n\n\t\t;\n\n\t\tfinal int imageType;\n\t\tfinal String ext;\n\n\t\tOutputType(int imageType, String ext) {\n\t\t\tthis.imageType = imageType;\n\t\t\tthis.ext = ext;\n\t\t}\n\t}\n\n\t/**\n\t * Output policy. Specify when an image is written. This is an important\n\t * choice. Best choice is to divide the graph in steps and choose the\n\t * *ByStepOutput*. Remember that if your graph has x nodes and\n\t * *ByEventOutput* or *ByNodeEventOutput* is chosen, this will produce x\n\t * images just for nodes creation.\n\t */\n\tpublic static enum OutputPolicy {\n\t\tBY_EVENT, BY_ELEMENT_EVENT, BY_ATTRIBUTE_EVENT, BY_NODE_EVENT, BY_EDGE_EVENT, BY_GRAPH_EVENT, BY_STEP, BY_NODE_ADDED_REMOVED, BY_EDGE_ADDED_REMOVED, BY_NODE_ATTRIBUTE, BY_EDGE_ATTRIBUTE, BY_GRAPH_ATTRIBUTE, BY_LAYOUT_STEP, BY_NODE_MOVED, ON_RUNNER, NONE\n\t}\n\n\t/**\n\t * Layout policy. Specify how layout is computed. It can be computed in its\n\t * own thread with a LayoutRunner but if image rendering takes too much\n\t * time, node positions will be very different between two images. To have a\n\t * better result, we can choose to compute layout when a new image is\n\t * rendered. This will smooth the move of nodes in the movie.\n\t */\n\tpublic static enum LayoutPolicy {\n\t\tNO_LAYOUT, COMPUTED_IN_LAYOUT_RUNNER, COMPUTED_ONCE_AT_NEW_IMAGE, COMPUTED_FULLY_AT_NEW_IMAGE\n\t}\n\n\t/**\n\t * Defines post rendering action on images.\n\t */\n\tpublic static interface PostRenderer {\n\t\tvoid render(Graphics2D g);\n\t}\n\n\t/**\n\t * Post rendering action allowing to add a logo-picture on images.\n\t */\n\tprotected static class AddLogoRenderer implements PostRenderer {\n\t\t/**\n\t\t * The logo.\n\t\t */\n\t\tBufferedImage logo;\n\t\t/**\n\t\t * Logo position on images.\n\t\t */\n\t\tint x, y;\n\n\t\tpublic AddLogoRenderer(String logoFile, int x, int y)\n\t\t\t\tthrows IOException {\n\t\t\tFile f = new File(logoFile);\n\n\t\t\tif (f.exists())\n\t\t\t\tthis.logo = ImageIO.read(f);\n\t\t\telse\n\t\t\t\tthis.logo = ImageIO.read(ClassLoader\n\t\t\t\t\t\t.getSystemResource(logoFile));\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic void render(Graphics2D g) {\n\t\t\tg.drawImage(logo, x, y, null);\n\t\t}\n\t}\n\n\t/**\n\t * Experimental. Allows to choose which renderer will be used.\n\t */\n\tpublic static enum RendererType {\n\t\tBASIC(\n\t\t\t\t\"org.graphstream.ui.swingViewer.basicRenderer.SwingBasicGraphRenderer\"), SCALA(\n\t\t\t\t\"org.graphstream.ui.j2dviewer.J2DGraphRenderer\")\n\n\t\t;\n\n\t\tfinal String classname;\n\n\t\tRendererType(String cn) {\n\t\t\tthis.classname = cn;\n\t\t}\n\t}\n\n\tpublic static enum Quality {\n\t\tLOW, MEDIUM, HIGH\n\t}\n\n\tprivate static final Logger LOGGER = Logger.getLogger(FileSinkImages.class\n\t\t\t.getName());\n\n\tprotected Resolution resolution;\n\tprotected OutputType outputType;\n\tprotected GraphRenderer renderer;\n\tprotected String filePrefix;\n\tprotected BufferedImage image;\n\tprotected Graphics2D g2d;\n\tprotected final GraphicGraph gg;\n\tprotected Sink sink;\n\tprotected int counter;\n\tprotected OutputPolicy outputPolicy;\n\tprotected LinkedList<PostRenderer> postRenderers;\n\tprotected LayoutPolicy layoutPolicy;\n\tprotected LayoutRunner optLayout;\n\tprotected ProxyPipe layoutPipeIn;\n\tprotected Layout layout;\n\tprotected float layoutStabilizationLimit = 0.9f;\n\tprotected int layoutStepAfterStabilization = 10;\n\tprotected int layoutStepPerFrame = 4;\n\tprotected int layoutStepWithoutFrame = 0;\n\tprotected long outputRunnerDelay = 10;\n\tprotected boolean outputRunnerAlive = false;\n\tprotected OutputRunner outputRunner;\n\tprotected ThreadProxyPipe outputRunnerProxy;\n\tprotected boolean clearImageBeforeOutput = false;\n\tprotected boolean hasBegan = false;\n\tprotected boolean autofit = true;\n\tprotected String styleSheet = null;\n\n\tpublic FileSinkImages() {\n\t\tthis(OutputType.PNG, Resolutions.HD720);\n\t}\n\n\tpublic FileSinkImages(OutputType type, Resolution resolution) {\n\t\tthis(\"frame_\", type, resolution, OutputPolicy.NONE);\n\t}\n\n\tpublic FileSinkImages(String prefix, OutputType type,\n\t\t\tResolution resolution, OutputPolicy outputPolicy) {\n\t\tthis.resolution = resolution;\n\t\tthis.outputType = type;\n\t\tthis.filePrefix = prefix;\n\t\tthis.counter = 0;\n\t\tthis.gg = new GraphicGraph(prefix);\n\t\tthis.postRenderers = new LinkedList<PostRenderer>();\n\t\tthis.layoutPolicy = LayoutPolicy.NO_LAYOUT;\n\t\tthis.layout = null;\n\t\tthis.optLayout = null;\n\t\tthis.layoutPipeIn = null;\n\t\tthis.sink = gg;\n\n\t\tsetOutputPolicy(outputPolicy);\n\t\tsetRenderer(RendererType.BASIC);\n\n\t\tinitImage();\n\t}\n\n\t/**\n\t * Enable high-quality rendering and anti-aliasing.\n\t */\n\tpublic void setQuality(Quality q) {\n\t\tswitch (q) {\n\t\tcase LOW:\n\t\t\tif (gg.hasAttribute(\"ui.quality\"))\n\t\t\t\tgg.removeAttribute(\"ui.quality\");\n\t\t\tif (gg.hasAttribute(\"ui.antialias\"))\n\t\t\t\tgg.removeAttribute(\"ui.antialias\");\n\n\t\t\tbreak;\n\t\tcase MEDIUM:\n\t\t\tif (!gg.hasAttribute(\"ui.quality\"))\n\t\t\t\tgg.addAttribute(\"ui.quality\");\n\t\t\tif (gg.hasAttribute(\"ui.antialias\"))\n\t\t\t\tgg.removeAttribute(\"ui.antialias\");\n\n\t\t\tbreak;\n\t\tcase HIGH:\n\t\t\tif (!gg.hasAttribute(\"ui.quality\"))\n\t\t\t\tgg.addAttribute(\"ui.quality\");\n\t\t\tif (!gg.hasAttribute(\"ui.antialias\"))\n\t\t\t\tgg.addAttribute(\"ui.antialias\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Defines style of the graph as a css stylesheet.\n\t * \n\t * @param styleSheet\n\t *            the style sheet\n\t */\n\tpublic void setStyleSheet(String styleSheet) {\n\t\tthis.styleSheet = styleSheet;\n\t\tgg.addAttribute(\"ui.stylesheet\", styleSheet);\n\t}\n\n\t/**\n\t * Set resolution of images.\n\t * \n\t * @param r\n\t *            resolution\n\t */\n\tpublic void setResolution(Resolution r) {\n\t\tif (r != resolution) {\n\t\t\tresolution = r;\n\t\t\tinitImage();\n\t\t}\n\t}\n\n\t/**\n\t * Set a custom resolution.\n\t * \n\t * @param width\n\t * @param height\n\t */\n\tpublic void setResolution(int width, int height) {\n\t\tif (resolution == null || resolution.getWidth() != width\n\t\t\t\t|| resolution.getHeight() != height) {\n\t\t\tresolution = new CustomResolution(width, height);\n\t\t\tinitImage();\n\t\t}\n\t}\n\n\t/**\n\t * Set the renderer type. This is experimental.\n\t * \n\t * @param rendererType\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void setRenderer(RendererType rendererType) {\n\t\ttry {\n\t\t\tClass<? extends GraphRenderer> clazz = (Class<? extends GraphRenderer>) Class\n\t\t\t\t\t.forName(rendererType.classname);\n\n\t\t\tGraphRenderer obj = clazz.newInstance();\n\n\t\t\tif (this.renderer != null)\n\t\t\t\tthis.renderer.close();\n\n\t\t\tthis.renderer = obj;\n\t\t\tthis.renderer.open(gg, null);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (ClassCastException e) {\n\t\t\tLOGGER.warning(String.format(\"not a renderer \\\"%s\\\"%n\",\n\t\t\t\t\trendererType.classname));\n\t\t} catch (InstantiationException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * Set the output policy.\n\t * \n\t * @param policy\n\t *            policy defining when images are produced\n\t */\n\tpublic void setOutputPolicy(OutputPolicy policy) {\n\t\tthis.outputPolicy = policy;\n\t}\n\n\t/**\n\t * Set the layout policy.\n\t * \n\t * @param policy\n\t *            policy defining how the layout is computed\n\t */\n\tpublic synchronized void setLayoutPolicy(LayoutPolicy policy) {\n\t\tif (policy != layoutPolicy) {\n\t\t\tswitch (layoutPolicy) {\n\t\t\tcase COMPUTED_IN_LAYOUT_RUNNER:\n\t\t\t\t// layout.removeListener(this);\n\t\t\t\toptLayout.release();\n\t\t\t\toptLayout = null;\n\t\t\t\tlayoutPipeIn.removeAttributeSink(gg);\n\t\t\t\tlayoutPipeIn = null;\n\t\t\t\tlayout = null;\n\t\t\t\tbreak;\n\t\t\tcase COMPUTED_ONCE_AT_NEW_IMAGE:\n\t\t\t\t// layout.removeListener(this);\n\t\t\t\tgg.removeSink(layout);\n\t\t\t\tlayout.removeAttributeSink(gg);\n\t\t\t\tlayout = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (policy) {\n\t\t\tcase COMPUTED_IN_LAYOUT_RUNNER:\n\t\t\t\tlayout = Layouts.newLayoutAlgorithm();\n\t\t\t\toptLayout = new InnerLayoutRunner();\n\t\t\t\tbreak;\n\t\t\tcase COMPUTED_FULLY_AT_NEW_IMAGE:\n\t\t\tcase COMPUTED_ONCE_AT_NEW_IMAGE:\n\t\t\t\tlayout = Layouts.newLayoutAlgorithm();\n\t\t\t\tgg.addSink(layout);\n\t\t\t\tlayout.addAttributeSink(gg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// layout.addListener(this);\n\t\t\tlayoutPolicy = policy;\n\t\t}\n\t}\n\n\t/**\n\t * Set the amount of step before output a new image. This is used only in\n\t * ByLayoutStepOutput output policy.\n\t * \n\t * @param spf\n\t *            step per frame\n\t */\n\tpublic void setLayoutStepPerFrame(int spf) {\n\t\tthis.layoutStepPerFrame = spf;\n\t}\n\n\t/**\n\t * Set the amount of steps after the stabilization of the algorithm.\n\t * \n\t * @param sas\n\t *            step after stabilization.\n\t */\n\tpublic void setLayoutStepAfterStabilization(int sas) {\n\t\tthis.layoutStepAfterStabilization = sas;\n\t}\n\n\t/**\n\t * Set the stabilization limit of the layout used to compute coordinates of\n\t * nodes. See\n\t * {@link org.graphstream.ui.layout.Layout#setStabilizationLimit(double)}\n\t * for more informations about this limit.\n\t * \n\t * @param limit\n\t */\n\tpublic void setLayoutStabilizationLimit(double limit) {\n\t\tif (layout == null)\n\t\t\tthrow new NullPointerException(\"did you enable layout ?\");\n\n\t\tlayout.setStabilizationLimit(limit);\n\t}\n\n\t/**\n\t * Add a logo on images.\n\t * \n\t * @param logoFile\n\t *            path to the logo picture-file\n\t * @param x\n\t *            x position of the logo (top-left corner is (0;0))\n\t * @param y\n\t *            y position of the logo\n\t */\n\tpublic void addLogo(String logoFile, int x, int y) {\n\t\tPostRenderer pr;\n\n\t\ttry {\n\t\t\tpr = new AddLogoRenderer(logoFile, x, y);\n\t\t\tpostRenderers.add(pr);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic synchronized void setOutputRunnerEnabled(boolean on) {\n\t\tif (!on && outputRunnerAlive) {\n\t\t\toutputRunnerAlive = false;\n\n\t\t\ttry {\n\t\t\t\tif (outputRunner != null)\n\t\t\t\t\toutputRunner.join();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// ... ?\n\t\t\t}\n\n\t\t\toutputRunner = null;\n\t\t\tsink = gg;\n\n\t\t\tif (outputRunnerProxy != null)\n\t\t\t\toutputRunnerProxy.pump();\n\t\t}\n\n\t\toutputRunnerAlive = on;\n\n\t\tif (outputRunnerAlive) {\n\t\t\tif (outputRunnerProxy == null) {\n\t\t\t\toutputRunnerProxy = new ThreadProxyPipe();\n\t\t\t\toutputRunnerProxy.init(gg);\n\t\t\t}\n\n\t\t\tsink = outputRunnerProxy;\n\t\t\toutputRunner = new OutputRunner();\n\t\t\toutputRunner.start();\n\t\t}\n\t}\n\n\tpublic void setOutputRunnerDelay(long delay) {\n\t\toutputRunnerDelay = delay;\n\t}\n\n\tpublic void stabilizeLayout(double limit) {\n\t\tif (layout != null) {\n\t\t\twhile (layout.getStabilization() < limit)\n\t\t\t\tlayout.compute();\n\t\t}\n\t}\n\n\tpublic Point3 getViewCenter() {\n\t\treturn renderer.getCamera().getViewCenter();\n\t}\n\n\tpublic void setViewCenter(double x, double y) {\n\t\trenderer.getCamera().setViewCenter(x, y, 0);\n\t}\n\n\tpublic double getViewPercent() {\n\t\treturn renderer.getCamera().getViewPercent();\n\t}\n\n\tpublic void setViewPercent(double zoom) {\n\t\trenderer.getCamera().setViewPercent(zoom);\n\t}\n\n\tpublic void setGraphViewport(double minx, double miny, double maxx,\n\t\t\tdouble maxy) {\n\t\trenderer.getCamera().setGraphViewport(minx, miny, maxx, maxy);\n\t}\n\n\tpublic void setClearImageBeforeOutputEnabled(boolean on) {\n\t\tclearImageBeforeOutput = on;\n\t}\n\n\tpublic void setAutofit(boolean on) {\n\t\tautofit = on;\n\t}\n\n\tprotected void initImage() {\n\t\timage = new BufferedImage(resolution.getWidth(),\n\t\t\t\tresolution.getHeight(), outputType.imageType);\n\n\t\tg2d = image.createGraphics();\n\t}\n\n\tprotected void clearGG() {\n\t\tgg.clear();\n\n\t\tif (styleSheet != null)\n\t\t\tgg.setAttribute(\"ui.stylesheet\", styleSheet);\n\n\t\tif (layout != null)\n\t\t\tlayout.clear();\n\t}\n\n\t/**\n\t * Produce a new image.\n\t */\n\tpublic void outputNewImage() {\n\t\toutputNewImage(String.format(\"%s%06d.%s\", filePrefix, counter++,\n\t\t\t\toutputType.ext));\n\t}\n\n\tpublic synchronized void outputNewImage(String filename) {\n\t\tswitch (layoutPolicy) {\n\t\tcase COMPUTED_IN_LAYOUT_RUNNER:\n\t\t\tlayoutPipeIn.pump();\n\t\t\tbreak;\n\t\tcase COMPUTED_ONCE_AT_NEW_IMAGE:\n\t\t\tif (layout != null)\n\t\t\t\tlayout.compute();\n\t\t\tbreak;\n\t\tcase COMPUTED_FULLY_AT_NEW_IMAGE:\n\t\t\tstabilizeLayout(layout.getStabilizationLimit());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (resolution.getWidth() != image.getWidth()\n\t\t\t\t|| resolution.getHeight() != image.getHeight())\n\t\t\tinitImage();\n\n\t\tif (clearImageBeforeOutput) {\n\t\t\tfor (int x = 0; x < resolution.getWidth(); x++)\n\t\t\t\tfor (int y = 0; y < resolution.getHeight(); y++)\n\t\t\t\t\timage.setRGB(x, y, 0x00000000);\n\t\t}\n\n\t\tif (gg.getNodeCount() > 0) {\n\t\t\tif (autofit) {\n\t\t\t\tgg.computeBounds();\n\n\t\t\t\tPoint3 lo = gg.getMinPos();\n\t\t\t\tPoint3 hi = gg.getMaxPos();\n\n\t\t\t\trenderer.getCamera().setBounds(lo.x, lo.y, lo.z, hi.x, hi.y,\n\t\t\t\t\t\thi.z);\n\t\t\t}\n\n\t\t\trenderer.render(g2d, 0, 0, resolution.getWidth(),\n\t\t\t\t\tresolution.getHeight());\n\t\t}\n\n\t\tfor (PostRenderer action : postRenderers)\n\t\t\taction.render(g2d);\n\n\t\timage.flush();\n\n\t\ttry {\n\t\t\tFile out = new File(filename);\n\n\t\t\tif (out.getParent() != null && !out.getParentFile().exists())\n\t\t\t\tout.getParentFile().mkdirs();\n\n\t\t\tImageIO.write(image, outputType.name(), out);\n\n\t\t\tprintProgress();\n\t\t} catch (IOException e) {\n\t\t\t// ?\n\t\t}\n\t}\n\n\tprotected void printProgress() {\n\t\tLOGGER.info(String.format(\"\\033[s\\033[K%d images written\\033[u\",\n\t\t\t\tcounter));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSink#begin(java.io.OutputStream)\n\t */\n\tpublic void begin(OutputStream stream) throws IOException {\n\t\tthrow new IOException(\"not implemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSink#begin(java.io.Writer)\n\t */\n\tpublic void begin(Writer writer) throws IOException {\n\t\tthrow new IOException(\"not implemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSink#begin(java.lang.String)\n\t */\n\tpublic void begin(String prefix) throws IOException {\n\t\tthis.filePrefix = prefix;\n\t\tthis.hasBegan = true;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSink#flush()\n\t */\n\tpublic void flush() throws IOException {\n\t\t// Nothing to do\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.graphstream.stream.file.FileSink#end()\n\t */\n\tpublic void end() throws IOException {\n\t\tflush();\n\t\tthis.hasBegan = false;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.file.FileSink#writeAll(org.graphstream.graph.Graph\n\t * , java.io.OutputStream)\n\t */\n\tpublic void writeAll(Graph g, OutputStream stream) throws IOException {\n\t\tthrow new IOException(\"not implemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.file.FileSink#writeAll(org.graphstream.graph.Graph\n\t * , java.io.Writer)\n\t */\n\tpublic void writeAll(Graph g, Writer writer) throws IOException {\n\t\tthrow new IOException(\"not implemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * org.graphstream.stream.file.FileSink#writeAll(org.graphstream.graph.Graph\n\t * , java.lang.String)\n\t */\n\tpublic synchronized void writeAll(Graph g, String filename)\n\t\t\tthrows IOException {\n\t\tclearGG();\n\n\t\tGraphReplay replay = new GraphReplay(String.format(\n\t\t\t\t\"file_sink_image-write_all-replay-%x\", System.nanoTime()));\n\n\t\treplay.addSink(gg);\n\t\treplay.replay(g);\n\t\treplay.removeSink(gg);\n\n\t\toutputNewImage(filename);\n\n\t\tclearGG();\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void edgeAttributeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString attribute, Object value) {\n\t\tsink.edgeAttributeAdded(sourceId, timeId, edgeId, attribute, value);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_EDGE_EVENT:\n\t\tcase BY_EDGE_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void edgeAttributeChanged(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute, Object oldValue, Object newValue) {\n\t\tsink.edgeAttributeChanged(sourceId, timeId, edgeId, attribute,\n\t\t\t\toldValue, newValue);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_EDGE_EVENT:\n\t\tcase BY_EDGE_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void edgeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString edgeId, String attribute) {\n\t\tsink.edgeAttributeRemoved(sourceId, timeId, edgeId, attribute);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_EDGE_EVENT:\n\t\tcase BY_EDGE_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void graphAttributeAdded(String sourceId, long timeId,\n\t\t\tString attribute, Object value) {\n\t\tsink.graphAttributeAdded(sourceId, timeId, attribute, value);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_GRAPH_EVENT:\n\t\tcase BY_GRAPH_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void graphAttributeChanged(String sourceId, long timeId,\n\t\t\tString attribute, Object oldValue, Object newValue) {\n\t\tsink.graphAttributeChanged(sourceId, timeId, attribute, oldValue,\n\t\t\t\tnewValue);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_GRAPH_EVENT:\n\t\tcase BY_GRAPH_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void graphAttributeRemoved(String sourceId, long timeId,\n\t\t\tString attribute) {\n\t\tsink.graphAttributeRemoved(sourceId, timeId, attribute);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_GRAPH_EVENT:\n\t\tcase BY_GRAPH_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void nodeAttributeAdded(String sourceId, long timeId, String nodeId,\n\t\t\tString attribute, Object value) {\n\t\tsink.nodeAttributeAdded(sourceId, timeId, nodeId, attribute, value);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_NODE_EVENT:\n\t\tcase BY_NODE_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void nodeAttributeChanged(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute, Object oldValue, Object newValue) {\n\t\tsink.nodeAttributeChanged(sourceId, timeId, nodeId, attribute,\n\t\t\t\toldValue, newValue);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_NODE_EVENT:\n\t\tcase BY_NODE_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void nodeAttributeRemoved(String sourceId, long timeId,\n\t\t\tString nodeId, String attribute) {\n\t\tsink.nodeAttributeRemoved(sourceId, timeId, nodeId, attribute);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_NODE_EVENT:\n\t\tcase BY_NODE_ATTRIBUTE:\n\t\tcase BY_ATTRIBUTE_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void edgeAdded(String sourceId, long timeId, String edgeId,\n\t\t\tString fromNodeId, String toNodeId, boolean directed) {\n\t\tsink.edgeAdded(sourceId, timeId, edgeId, fromNodeId, toNodeId, directed);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_EDGE_EVENT:\n\t\tcase BY_EDGE_ADDED_REMOVED:\n\t\tcase BY_ELEMENT_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void edgeRemoved(String sourceId, long timeId, String edgeId) {\n\t\tsink.edgeRemoved(sourceId, timeId, edgeId);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_EDGE_EVENT:\n\t\tcase BY_EDGE_ADDED_REMOVED:\n\t\tcase BY_ELEMENT_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void graphCleared(String sourceId, long timeId) {\n\t\tsink.graphCleared(sourceId, timeId);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_GRAPH_EVENT:\n\t\tcase BY_NODE_ADDED_REMOVED:\n\t\tcase BY_EDGE_ADDED_REMOVED:\n\t\tcase BY_ELEMENT_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void nodeAdded(String sourceId, long timeId, String nodeId) {\n\t\tsink.nodeAdded(sourceId, timeId, nodeId);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_NODE_EVENT:\n\t\tcase BY_NODE_ADDED_REMOVED:\n\t\tcase BY_ELEMENT_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void nodeRemoved(String sourceId, long timeId, String nodeId) {\n\t\tsink.nodeRemoved(sourceId, timeId, nodeId);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_NODE_EVENT:\n\t\tcase BY_NODE_ADDED_REMOVED:\n\t\tcase BY_ELEMENT_EVENT:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * @see org.graphstream.stream.Sink\n\t */\n\tpublic void stepBegins(String sourceId, long timeId, double step) {\n\t\tsink.stepBegins(sourceId, timeId, step);\n\n\t\tswitch (outputPolicy) {\n\t\tcase BY_EVENT:\n\t\tcase BY_STEP:\n\t\t\tif (hasBegan)\n\t\t\t\toutputNewImage();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// public void nodeMoved(String id, double x, double y, double z) {\n\t// switch (outputPolicy) {\n\t// case BY_NODE_MOVED:\n\t// if (hasBegan)\n\t// outputNewImage();\n\t// break;\n\t// }\n\t// }\n\n\t// public void nodeInfos(String id, double dx, double dy, double dz) {\n\t// }\n\n\t// public void edgeChanged(String id, double[] points) {\n\t// }\n\n\t// public void nodesMoved(Map<String, double[]> nodes) {\n\t// switch (outputPolicy) {\n\t// case BY_NODE_MOVED:\n\t// if (hasBegan)\n\t// outputNewImage();\n\t// break;\n\t// }\n\t// }\n\n\t// public void edgesChanged(Map<String, double[]> edges) {\n\t// }\n\n\t// public void stepCompletion(double percent) {\n\t// switch (outputPolicy) {\n\t// case BY_LAYOUT_STEP:\n\t// layoutStepWithoutFrame++;\n\t//\n\t// if (layoutStepWithoutFrame >= layoutStepPerFrame) {\n\t// if (hasBegan)\n\t// outputNewImage();\n\t// layoutStepWithoutFrame = 0;\n\t// }\n\t//\n\t// break;\n\t// }\n\t// }\n\n\tpublic static enum Option {\n\t\tIMAGE_PREFIX(\"image-prefix\", 'p', \"prefix of outputted images\", true,\n\t\t\t\ttrue, \"image_\"), IMAGE_TYPE(\"image-type\", 't',\n\t\t\t\t\"image type. one of \" + Arrays.toString(OutputType.values()),\n\t\t\t\ttrue, true, \"PNG\"), IMAGE_RESOLUTION(\"image-resolution\", 'r',\n\t\t\t\t\"defines images resolution. \\\"width x height\\\" or one of \"\n\t\t\t\t\t\t+ Arrays.toString(Resolutions.values()), true, true,\n\t\t\t\t\"HD720\"), OUTPUT_POLICY(\"output-policy\", 'e',\n\t\t\t\t\"defines when images are outputted. one of \"\n\t\t\t\t\t\t+ Arrays.toString(OutputPolicy.values()), true, true,\n\t\t\t\t\"ByStepOutput\"), LOGO(\"logo\", 'l', \"add a logo to images\",\n\t\t\t\ttrue, true, null), STYLESHEET(\"stylesheet\", 's',\n\t\t\t\t\"defines stylesheet of graph. can be a file or a string.\",\n\t\t\t\ttrue, true, null), QUALITY(\"quality\", 'q',\n\t\t\t\t\"defines quality of rendering. one of \"\n\t\t\t\t\t\t+ Arrays.toString(Quality.values()), true, true, \"HIGH\");\n\t\tString fullopts;\n\t\tchar shortopts;\n\t\tString description;\n\t\tboolean optional;\n\t\tboolean valuable;\n\t\tString defaultValue;\n\n\t\tOption(String fullopts, char shortopts, String description,\n\t\t\t\tboolean optional, boolean valuable, String defaultValue) {\n\t\t\tthis.fullopts = fullopts;\n\t\t\tthis.shortopts = shortopts;\n\t\t\tthis.description = description;\n\t\t\tthis.optional = optional;\n\t\t\tthis.valuable = valuable;\n\t\t\tthis.defaultValue = defaultValue;\n\t\t}\n\t}\n\n\tprotected class InnerLayoutRunner extends LayoutRunner {\n\n\t\tpublic InnerLayoutRunner() {\n\t\t\tsuper(FileSinkImages.this.gg, FileSinkImages.this.layout, true,\n\t\t\t\t\ttrue);\n\n\t\t\tFileSinkImages.this.layoutPipeIn = newLayoutPipe();\n\t\t\tFileSinkImages.this.layoutPipeIn\n\t\t\t\t\t.addAttributeSink(FileSinkImages.this.gg);\n\t\t}\n\n\t\tpublic void run() {\n\n\t\t\tint stepAfterStabilization = 0;\n\n\t\t\tdo {\n\t\t\t\tpumpPipe.pump();\n\t\t\t\tlayout.compute();\n\n\t\t\t\tif (layout.getStabilization() > layout.getStabilizationLimit())\n\t\t\t\t\tstepAfterStabilization++;\n\t\t\t\telse\n\t\t\t\t\tstepAfterStabilization = 0;\n\n\t\t\t\tnap(80);\n\n\t\t\t\tif (stepAfterStabilization > layoutStepAfterStabilization)\n\t\t\t\t\tloop = false;\n\t\t\t} while (loop);\n\t\t}\n\t}\n\n\tprotected class OutputRunner extends Thread {\n\t\tpublic OutputRunner() {\n\t\t\tsetDaemon(true);\n\t\t}\n\n\t\tpublic void run() {\n\t\t\twhile (outputRunnerAlive && outputPolicy == OutputPolicy.ON_RUNNER) {\n\t\t\t\toutputRunnerProxy.pump();\n\t\t\t\tif (hasBegan)\n\t\t\t\t\toutputNewImage();\n\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(outputRunnerDelay);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\toutputRunnerAlive = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void usage() {\n\t\tLOGGER.info(String.format(\"usage: java %s [options] fichier.dgs%n\",\n\t\t\t\tFileSinkImages.class.getName()));\n\t\tLOGGER.info(String.format(\"where options in:%n\"));\n\t\tfor (Option option : Option.values()) {\n\t\t\tLOGGER.info(String.format(\"%n --%s%s , -%s %s%n%s%n\",\n\t\t\t\t\toption.fullopts, option.valuable ? \"=...\" : \"\",\n\t\t\t\t\toption.shortopts, option.valuable ? \"...\" : \"\",\n\t\t\t\t\toption.description));\n\t\t}\n\t}\n\n\tpublic static void main(String... args) throws IOException {\n\n\t\tHashMap<Option, String> options = new HashMap<Option, String>();\n\t\tLinkedList<String> others = new LinkedList<String>();\n\n\t\tfor (Option option : Option.values())\n\t\t\tif (option.defaultValue != null)\n\t\t\t\toptions.put(option, option.defaultValue);\n\n\t\tif (args != null && args.length > 0) {\n\t\t\tPattern valueGetter = Pattern\n\t\t\t\t\t.compile(\"^--\\\\w[\\\\w-]*\\\\w?(?:=(?:\\\"([^\\\"]*)\\\"|([^\\\\s]*)))$\");\n\n\t\t\tfor (int i = 0; i < args.length; i++) {\n\n\t\t\t\tif (args[i]\n\t\t\t\t\t\t.matches(\"^--\\\\w[\\\\w-]*\\\\w?(=(\\\"[^\\\"]*\\\"|[^\\\\s]*))?$\")) {\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tfor (Option option : Option.values()) {\n\t\t\t\t\t\tif (args[i].startsWith(\"--\" + option.fullopts + \"=\")) {\n\t\t\t\t\t\t\tMatcher m = valueGetter.matcher(args[i]);\n\n\t\t\t\t\t\t\tif (m.matches()) {\n\t\t\t\t\t\t\t\toptions.put(\n\t\t\t\t\t\t\t\t\t\toption,\n\t\t\t\t\t\t\t\t\t\tm.group(1) == null ? m.group(2) : m\n\t\t\t\t\t\t\t\t\t\t\t\t.group(1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tLOGGER.severe(String.format(\"unknown option: %s%n\",\n\t\t\t\t\t\t\t\targs[i].substring(0, args[i].indexOf('='))));\n\t\t\t\t\t\tSystem.exit(1);\n\t\t\t\t\t}\n\t\t\t\t} else if (args[i].matches(\"^-\\\\w$\")) {\n\t\t\t\t\tboolean found = false;\n\n\t\t\t\t\tfor (Option option : Option.values()) {\n\t\t\t\t\t\tif (args[i].equals(\"-\" + option.shortopts)) {\n\t\t\t\t\t\t\toptions.put(option, args[++i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tLOGGER.severe(String.format(\"unknown option: %s%n\",\n\t\t\t\t\t\t\t\targs[i]));\n\t\t\t\t\t\tSystem.exit(1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tothers.addLast(args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tusage();\n\t\t\tSystem.exit(0);\n\t\t}\n\n\t\tLinkedList<String> errors = new LinkedList<String>();\n\n\t\tif (others.size() == 0) {\n\t\t\terrors.add(\"dgs file name missing.\");\n\t\t}\n\n\t\tString imagePrefix;\n\t\tOutputType outputType = null;\n\t\tOutputPolicy outputPolicy = null;\n\t\tResolution resolution = null;\n\t\tQuality quality = null;\n\t\tString logo;\n\t\tString stylesheet;\n\n\t\timagePrefix = options.get(Option.IMAGE_PREFIX);\n\n\t\ttry {\n\t\t\toutputType = OutputType.valueOf(options.get(Option.IMAGE_TYPE));\n\t\t} catch (IllegalArgumentException e) {\n\t\t\terrors.add(\"bad image type: \" + options.get(Option.IMAGE_TYPE));\n\t\t}\n\n\t\ttry {\n\t\t\toutputPolicy = OutputPolicy.valueOf(options\n\t\t\t\t\t.get(Option.OUTPUT_POLICY));\n\t\t} catch (IllegalArgumentException e) {\n\t\t\terrors.add(\"bad output policy: \"\n\t\t\t\t\t+ options.get(Option.OUTPUT_POLICY));\n\t\t}\n\n\t\ttry {\n\t\t\tquality = Quality.valueOf(options.get(Option.QUALITY));\n\t\t} catch (IllegalArgumentException e) {\n\t\t\terrors.add(\"bad quality: \" + options.get(Option.QUALITY));\n\t\t}\n\n\t\tlogo = options.get(Option.LOGO);\n\t\tstylesheet = options.get(Option.STYLESHEET);\n\n\t\ttry {\n\t\t\tresolution = Resolutions.valueOf(options\n\t\t\t\t\t.get(Option.IMAGE_RESOLUTION));\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tPattern p = Pattern.compile(\"^\\\\s*(\\\\d+)\\\\s*x\\\\s*(\\\\d+)\\\\s*$\");\n\t\t\tMatcher m = p.matcher(options.get(Option.IMAGE_RESOLUTION));\n\n\t\t\tif (m.matches()) {\n\t\t\t\tresolution = new CustomResolution(Integer.parseInt(m.group(1)),\n\t\t\t\t\t\tInteger.parseInt(m.group(2)));\n\t\t\t} else {\n\t\t\t\terrors.add(\"bad resolution: \"\n\t\t\t\t\t\t+ options.get(Option.IMAGE_RESOLUTION));\n\t\t\t}\n\t\t}\n\n\t\tif (stylesheet != null && stylesheet.length() < 1024) {\n\t\t\tFile test = new File(stylesheet);\n\n\t\t\tif (test.exists()) {\n\t\t\t\tFileReader in = new FileReader(test);\n\t\t\t\tchar[] buffer = new char[128];\n\t\t\t\tString content = \"\";\n\n\t\t\t\twhile (in.ready()) {\n\t\t\t\t\tint c = in.read(buffer, 0, 128);\n\t\t\t\t\tcontent += new String(buffer, 0, c);\n\t\t\t\t}\n\n\t\t\t\tstylesheet = content;\n\t\t\t\tin.close();\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tFile test = new File(others.peek());\n\t\t\tif (!test.exists())\n\t\t\t\terrors.add(String.format(\"file \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tothers.peek()));\n\t\t}\n\n\t\tif (errors.size() > 0) {\n\t\t\tLOGGER.info(String.format(\"error:%n\"));\n\n\t\t\tfor (String error : errors)\n\t\t\t\tLOGGER.info(String.format(\"- %s%n\", error));\n\n\t\t\tSystem.exit(1);\n\t\t}\n\n\t\tFileSourceDGS dgs = new FileSourceDGS();\n\t\tFileSinkImages fsi = new FileSinkImages(imagePrefix, outputType,\n\t\t\t\tresolution, outputPolicy);\n\n\t\tdgs.addSink(fsi);\n\n\t\tif (logo != null)\n\t\t\tfsi.addLogo(logo, 0, 0);\n\n\t\tfsi.setQuality(quality);\n\t\tif (stylesheet != null)\n\t\t\tfsi.setStyleSheet(stylesheet);\n\n\t\tboolean next = true;\n\n\t\tdgs.begin(others.get(0));\n\n\t\twhile (next)\n\t\t\tnext = dgs.nextStep();\n\n\t\tdgs.end();\n\t}\n}\n",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "width", "", "int" ], [ "height", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getViewCenter", "org.graphstream.stream.file", "FileSinkImages", "public Point3 getViewCenter()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getViewPercent", "org.graphstream.stream.file", "FileSinkImages", "public double getViewPercent()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ [ "resolution", "org.graphstream.stream.file", "FileSinkImages", "protected Resolution resolution;" ], [ "outputType", "org.graphstream.stream.file", "FileSinkImages", "protected OutputType outputType;" ], [ "renderer", "org.graphstream.stream.file", "FileSinkImages", "protected GraphRenderer renderer;" ], [ "filePrefix", "org.graphstream.stream.file", "FileSinkImages", "protected String filePrefix;" ], [ "image", "org.graphstream.stream.file", "FileSinkImages", "protected BufferedImage image;" ], [ "g2d", "org.graphstream.stream.file", "FileSinkImages", "protected Graphics2D g2d;" ], [ "gg", "org.graphstream.stream.file", "FileSinkImages", "protected final GraphicGraph gg;" ], [ "sink", "org.graphstream.stream.file", "FileSinkImages", "protected Sink sink;" ], [ "counter", "org.graphstream.stream.file", "FileSinkImages", "protected int counter;" ], [ "outputPolicy", "org.graphstream.stream.file", "FileSinkImages", "protected OutputPolicy outputPolicy;" ], [ "postRenderers", "org.graphstream.stream.file", "FileSinkImages", "protected LinkedList<PostRenderer> postRenderers;" ], [ "layoutPolicy", "org.graphstream.stream.file", "FileSinkImages", "protected LayoutPolicy layoutPolicy;" ], [ "optLayout", "org.graphstream.stream.file", "FileSinkImages", "protected LayoutRunner optLayout;" ], [ "layoutPipeIn", "org.graphstream.stream.file", "FileSinkImages", "protected ProxyPipe layoutPipeIn;" ], [ "layout", "org.graphstream.stream.file", "FileSinkImages", "protected Layout layout;" ], [ "layoutStabilizationLimit", "org.graphstream.stream.file", "FileSinkImages", "protected float layoutStabilizationLimit = 0.9f;" ], [ "layoutStepAfterStabilization", "org.graphstream.stream.file", "FileSinkImages", "protected int layoutStepAfterStabilization = 10;" ], [ "layoutStepPerFrame", "org.graphstream.stream.file", "FileSinkImages", "protected int layoutStepPerFrame = 4;" ], [ "layoutStepWithoutFrame", "org.graphstream.stream.file", "FileSinkImages", "protected int layoutStepWithoutFrame = 0;" ], [ "outputRunnerDelay", "org.graphstream.stream.file", "FileSinkImages", "protected long outputRunnerDelay = 10;" ], [ "outputRunnerAlive", "org.graphstream.stream.file", "FileSinkImages", "protected boolean outputRunnerAlive = false;" ], [ "outputRunner", "org.graphstream.stream.file", "FileSinkImages", "protected OutputRunner outputRunner;" ], [ "outputRunnerProxy", "org.graphstream.stream.file", "FileSinkImages", "protected ThreadProxyPipe outputRunnerProxy;" ], [ "clearImageBeforeOutput", "org.graphstream.stream.file", "FileSinkImages", "protected boolean clearImageBeforeOutput = false;" ], [ "hasBegan", "org.graphstream.stream.file", "FileSinkImages", "protected boolean hasBegan = false;" ], [ "autofit", "org.graphstream.stream.file", "FileSinkImages", "protected boolean autofit = true;" ], [ "styleSheet", "org.graphstream.stream.file", "FileSinkImages", "protected String styleSheet = null;" ] ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]