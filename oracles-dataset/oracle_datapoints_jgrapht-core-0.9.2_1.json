[
    {
        "id": 25835,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.util",
        "className": "ModifiableInteger",
        "javadocTag": "@return an <code>Integer</code> representation of the value of this\nobject.",
        "methodJavadoc": "    /**\n     * Returns an <code>Integer</code> object representing this <code>\n     * ModifiableInteger</code>'s value.\n     *\n     * @return an <code>Integer</code> representation of the value of this\n     * object.\n     */",
        "methodSourceCode": "public Integer toInteger(){\n    return Integer.valueOf(this.value);\n}",
        "classJavadoc": "/**\n * The <code>ModifiableInteger</code> class wraps a value of the primitive type\n * <code>int</code> in an object, similarly to {@link java.lang.Integer}. An\n * object of type <code>ModifiableInteger</code> contains a single field whose\n * type is <code>int</code>.\n *\n * <p>Unlike <code>java.lang.Integer</code>, the int value which the\n * ModifiableInteger represents can be modified. It becomes useful when used\n * together with the collection framework. For example, if you want to have a\n * {@link java.util.List} of counters. You could use <code>Integer</code> but\n * that would have became wasteful and inefficient if you frequently had to\n * update the counters.</p>\n *\n * <p>WARNING: Because instances of this class are mutable, great care must be\n * exercised if used as keys of a {@link java.util.Map} or as values in a {@link\n * java.util.Set} in a manner that affects equals comparisons while the\n * instances are keys in the map (or values in the set). For more see\n * documentation of <code>Map</code> and <code>Set</code>.</p>\n *\n * @author Barak Naveh\n * @since May 27, 2004\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------------\n * ModifiableInteger.java\n * ----------------------\n *\n * (C) Copyright 2002-2004, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n * 2004-05-27 : Initial version (BN);\n *\n */\npackage org.jgrapht.util;\n\n/**\n * The <code>ModifiableInteger</code> class wraps a value of the primitive type\n * <code>int</code> in an object, similarly to {@link java.lang.Integer}. An\n * object of type <code>ModifiableInteger</code> contains a single field whose\n * type is <code>int</code>.\n *\n * <p>Unlike <code>java.lang.Integer</code>, the int value which the\n * ModifiableInteger represents can be modified. It becomes useful when used\n * together with the collection framework. For example, if you want to have a\n * {@link java.util.List} of counters. You could use <code>Integer</code> but\n * that would have became wasteful and inefficient if you frequently had to\n * update the counters.</p>\n *\n * <p>WARNING: Because instances of this class are mutable, great care must be\n * exercised if used as keys of a {@link java.util.Map} or as values in a {@link\n * java.util.Set} in a manner that affects equals comparisons while the\n * instances are keys in the map (or values in the set). For more see\n * documentation of <code>Map</code> and <code>Set</code>.</p>\n *\n * @author Barak Naveh\n * @since May 27, 2004\n */\npublic class ModifiableInteger\n    extends Number\n    implements Comparable<ModifiableInteger>\n{\n    private static final long serialVersionUID = 3618698612851422261L;\n\n    /**\n     * The int value represented by this <code>ModifiableInteger</code>.\n     */\n    public int value;\n\n    /**\n     * <b>!!! DON'T USE - Use the {@link #ModifiableInteger(int)} constructor\n     * instead !!!</b>\n     *\n     * <p>This constructor is for the use of java.beans.XMLDecoder\n     * deserialization. The constructor is marked as 'deprecated' to indicate to\n     * the programmer against using it by mistake.</p>\n     *\n     * @deprecated not really deprecated, just marked so to avoid mistaken use.\n     */\n    @Deprecated public ModifiableInteger()\n    {\n    }\n\n    /**\n     * Constructs a newly allocated <code>ModifiableInteger</code> object that\n     * represents the specified <code>int</code> value.\n     *\n     * @param value the value to be represented by the <code>\n     * ModifiableInteger</code> object.\n     */\n    public ModifiableInteger(int value)\n    {\n        this.value = value;\n    }\n\n    /**\n     * Sets a new value for this modifiable integer.\n     *\n     * @param value the new value to set.\n     */\n    public void setValue(int value)\n    {\n        this.value = value;\n    }\n\n    /**\n     * Returns the value of this object, similarly to {@link #intValue()}. This\n     * getter is NOT redundant. It is used for serialization by\n     * java.beans.XMLEncoder.\n     *\n     * @return the value.\n     */\n    public int getValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Adds one to the value of this modifiable integer.\n     */\n    public void increment()\n    {\n        this.value++;\n    }\n\n    /**\n     * Subtracts one from the value of this modifiable integer.\n     */\n    public void decrement()\n    {\n        this.value--;\n    }\n\n    /**\n     * Compares two <code>ModifiableInteger</code> objects numerically.\n     *\n     * @param anotherInteger the <code>ModifiableInteger</code> to be compared.\n     *\n     * @return the value <code>0</code> if this <code>ModifiableInteger</code>\n     * is equal to the argument <code>ModifiableInteger</code>; a value less\n     * than <code>0</code> if this <code>ModifiableInteger</code> is numerically\n     * less than the argument <code>ModifiableInteger</code>; and a value\n     * greater than <code>0</code> if this <code>ModifiableInteger</code> is\n     * numerically greater than the argument <code>ModifiableInteger</code>\n     * (signed comparison).\n     */\n    @Override public int compareTo(ModifiableInteger anotherInteger)\n    {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n\n        return (thisVal < anotherVal) ? -1 : ((thisVal == anotherVal) ? 0 : 1);\n    }\n\n    /**\n     * @see Number#doubleValue()\n     */\n    @Override public double doubleValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Compares this object to the specified object. The result is <code>\n     * true</code> if and only if the argument is not <code>null</code> and is\n     * an <code>ModifiableInteger</code> object that contains the same <code>\n     * int</code> value as this object.\n     *\n     * @param o the object to compare with.\n     *\n     * @return <code>true</code> if the objects are the same; <code>false</code>\n     * otherwise.\n     */\n    @Override public boolean equals(Object o)\n    {\n        if (o instanceof ModifiableInteger) {\n            return this.value == ((ModifiableInteger) o).value;\n        }\n\n        return false;\n    }\n\n    /**\n     * @see Number#floatValue()\n     */\n    @Override public float floatValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Returns a hash code for this <code>ModifiableInteger</code>.\n     *\n     * @return a hash code value for this object, equal to the primitive <code>\n     * int</code> value represented by this <code>ModifiableInteger</code>\n     * object.\n     */\n    @Override public int hashCode()\n    {\n        return this.value;\n    }\n\n    /**\n     * @see Number#intValue()\n     */\n    @Override public int intValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * @see Number#longValue()\n     */\n    @Override public long longValue()\n    {\n        return this.value;\n    }\n\n    /**\n     * Returns an <code>Integer</code> object representing this <code>\n     * ModifiableInteger</code>'s value.\n     *\n     * @return an <code>Integer</code> representation of the value of this\n     * object.\n     */\n    public Integer toInteger()\n    {\n        return Integer.valueOf(this.value);\n    }\n\n    /**\n     * Returns a <code>String</code> object representing this <code>\n     * ModifiableInteger</code>'s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if the\n     * integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return a string representation of the value of this object in\n     * base&nbsp;10.\n     */\n    @Override public String toString()\n    {\n        return String.valueOf(this.value);\n    }\n}\n\n// End ModifiableInteger.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "intValue",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * @see Number#intValue()\n */\n@Override\npublic int intValue() {\n    return this.value;\n}"
            ],
            [
                "byteValue",
                "java.lang",
                "Number",
                "public byte byteValue()"
            ],
            [
                "longValue",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * @see Number#longValue()\n */\n@Override\npublic long longValue() {\n    return this.value;\n}"
            ],
            [
                "doubleValue",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * @see Number#doubleValue()\n */\n@Override\npublic double doubleValue() {\n    return this.value;\n}"
            ],
            [
                "equals",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * Compares this object to the specified object. The result is <code>\n * true</code> if and only if the argument is not <code>null</code> and is\n * an <code>ModifiableInteger</code> object that contains the same <code>\n * int</code> value as this object.\n *\n * @param o the object to compare with.\n *\n * @return <code>true</code> if the objects are the same; <code>false</code>\n * otherwise.\n */\n@Override\npublic boolean equals(Object o) {\n    if (o instanceof ModifiableInteger) {\n        return this.value == ((ModifiableInteger) o).value;\n    }\n    return false;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getValue",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * Returns the value of this object, similarly to {@link #intValue()}. This\n * getter is NOT redundant. It is used for serialization by\n * java.beans.XMLEncoder.\n *\n * @return the value.\n */\npublic int getValue() {\n    return this.value;\n}"
            ],
            [
                "shortValue",
                "java.lang",
                "Number",
                "public short shortValue()"
            ],
            [
                "floatValue",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * @see Number#floatValue()\n */\n@Override\npublic float floatValue() {\n    return this.value;\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "hashCode",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * Returns a hash code for this <code>ModifiableInteger</code>.\n *\n * @return a hash code value for this object, equal to the primitive <code>\n * int</code> value represented by this <code>ModifiableInteger</code>\n * object.\n */\n@Override\npublic int hashCode() {\n    return this.value;\n}"
            ],
            [
                "toString",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * Returns a <code>String</code> object representing this <code>\n * ModifiableInteger</code>'s value. The value is converted to signed\n * decimal representation and returned as a string, exactly as if the\n * integer value were given as an argument to the {@link\n * java.lang.Integer#toString(int)} method.\n *\n * @return a string representation of the value of this object in\n * base&nbsp;10.\n */\n@Override\npublic String toString() {\n    return String.valueOf(this.value);\n}"
            ],
            [
                "toInteger",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * Returns an <code>Integer</code> object representing this <code>\n * ModifiableInteger</code>'s value.\n *\n * @return an <code>Integer</code> representation of the value of this\n * object.\n */\npublic Integer toInteger() {\n    return Integer.valueOf(this.value);\n}"
            ],
            [
                "compareTo",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * Compares two <code>ModifiableInteger</code> objects numerically.\n *\n * @param anotherInteger the <code>ModifiableInteger</code> to be compared.\n *\n * @return the value <code>0</code> if this <code>ModifiableInteger</code>\n * is equal to the argument <code>ModifiableInteger</code>; a value less\n * than <code>0</code> if this <code>ModifiableInteger</code> is numerically\n * less than the argument <code>ModifiableInteger</code>; and a value\n * greater than <code>0</code> if this <code>ModifiableInteger</code> is\n * numerically greater than the argument <code>ModifiableInteger</code>\n * (signed comparison).\n */\n@Override\npublic int compareTo(ModifiableInteger anotherInteger) {\n    int thisVal = this.value;\n    int anotherVal = anotherInteger.value;\n    return (thisVal < anotherVal) ? -1 : ((thisVal == anotherVal) ? 0 : 1);\n}"
            ],
            [
                "shortValue",
                "java.lang",
                "Integer",
                "public short shortValue()"
            ],
            [
                "floatValue",
                "java.lang",
                "Integer",
                "public float floatValue()"
            ],
            [
                "longValue",
                "java.lang",
                "Integer",
                "public long longValue()"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "Integer",
                "public Integer resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "describeConstable",
                "java.lang",
                "Integer",
                "public Optional<Integer> describeConstable()"
            ],
            [
                "equals",
                "java.lang",
                "Integer",
                "public boolean equals(Object arg0)"
            ],
            [
                "doubleValue",
                "java.lang",
                "Integer",
                "public double doubleValue()"
            ],
            [
                "byteValue",
                "java.lang",
                "Integer",
                "public byte byteValue()"
            ],
            [
                "toString",
                "java.lang",
                "Integer",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Integer",
                "public int hashCode()"
            ],
            [
                "intValue",
                "java.lang",
                "Integer",
                "public int intValue()"
            ],
            [
                "compareTo",
                "java.lang",
                "Integer",
                "public int compareTo(Integer arg0)"
            ],
            [
                "longValue",
                "java.lang",
                "Number",
                "public abstract long longValue()"
            ],
            [
                "doubleValue",
                "java.lang",
                "Number",
                "public abstract double doubleValue()"
            ],
            [
                "intValue",
                "java.lang",
                "Number",
                "public abstract int intValue()"
            ],
            [
                "floatValue",
                "java.lang",
                "Number",
                "public abstract float floatValue()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "value",
                "org.jgrapht.util",
                "ModifiableInteger",
                "/**\n * The int value represented by this <code>ModifiableInteger</code>.\n */\npublic int value;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25857,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.util",
        "className": "FibonacciHeap",
        "javadocTag": "@return String of this.",
        "methodJavadoc": "    /**\n     * Creates a String representation of this Fibonacci heap.\n     *\n     * @return String of this.\n     */",
        "methodSourceCode": "public String toString(){\n    if (minNode == null) {\n        return \"FibonacciHeap=[]\";\n    }\n    // create a new stack and put root on it\n    Stack<FibonacciHeapNode<T>> stack = new Stack<FibonacciHeapNode<T>>();\n    stack.push(minNode);\n    StringBuffer buf = new StringBuffer(512);\n    buf.append(\"FibonacciHeap=[\");\n    // do a simple breadth-first traversal on the tree\n    while (!stack.empty()) {\n        FibonacciHeapNode<T> curr = stack.pop();\n        buf.append(curr);\n        buf.append(\", \");\n        if (curr.child != null) {\n            stack.push(curr.child);\n        }\n        FibonacciHeapNode<T> start = curr;\n        curr = curr.right;\n        while (curr != start) {\n            buf.append(curr);\n            buf.append(\", \");\n            if (curr.child != null) {\n                stack.push(curr.child);\n            }\n            curr = curr.right;\n        }\n    }\n    buf.append(']');\n    return buf.toString();\n}",
        "classJavadoc": "/**\n * This class implements a Fibonacci heap data structure. Much of the code in\n * this class is based on the algorithms in the \"Introduction to Algorithms\"by\n * Cormen, Leiserson, and Rivest in Chapter 21. The amortized running time of\n * most of these methods is O(1), making it a very fast data structure. Several\n * have an actual running time of O(1). removeMin() and delete() have O(log n)\n * amortized running times because they do the heap consolidation. If you\n * attempt to store nodes in this heap with key values of -Infinity\n * (Double.NEGATIVE_INFINITY) the <code>delete()</code> operation may fail to\n * remove the correct element.\n *\n * <p><b>Note that this implementation is not synchronized.</b> If multiple\n * threads access a set concurrently, and at least one of the threads modifies\n * the set, it <i>must</i> be synchronized externally. This is typically\n * accomplished by synchronizing on some object that naturally encapsulates the\n * set.</p>\n *\n * <p>This class was originally developed by Nathan Fiedler for the GraphMaker\n * project. It was imported to JGraphT with permission, courtesy of Nathan\n * Fiedler.</p>\n *\n * @author Nathan Fiedler\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (barak_naveh@users.sourceforge.net)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* --------------------------\n * FibonnaciHeap.java\n * --------------------------\n * (C) Copyright 1999-2003, by Nathan Fiedler and Contributors.\n *\n * Original Author:  Nathan Fiedler\n * Contributor(s):   John V. Sichi\n *\n * $Id$\n *\n * Changes\n * -------\n * 03-Sept-2003 : Adapted from Nathan Fiedler (JVS);\n *\n *      Name    Date            Description\n *      ----    ----            -----------\n *      nf      08/31/97        Initial version\n *      nf      09/07/97        Removed FibHeapData interface\n *      nf      01/20/01        Added synchronization\n *      nf      01/21/01        Made Node an inner class\n *      nf      01/05/02        Added clear(), renamed empty() to\n *                              isEmpty(), and renamed printHeap()\n *                              to toString()\n *      nf      01/06/02        Removed all synchronization\n *\n */\npackage org.jgrapht.util;\n\nimport java.util.*;\n\n\n/**\n * This class implements a Fibonacci heap data structure. Much of the code in\n * this class is based on the algorithms in the \"Introduction to Algorithms\"by\n * Cormen, Leiserson, and Rivest in Chapter 21. The amortized running time of\n * most of these methods is O(1), making it a very fast data structure. Several\n * have an actual running time of O(1). removeMin() and delete() have O(log n)\n * amortized running times because they do the heap consolidation. If you\n * attempt to store nodes in this heap with key values of -Infinity\n * (Double.NEGATIVE_INFINITY) the <code>delete()</code> operation may fail to\n * remove the correct element.\n *\n * <p><b>Note that this implementation is not synchronized.</b> If multiple\n * threads access a set concurrently, and at least one of the threads modifies\n * the set, it <i>must</i> be synchronized externally. This is typically\n * accomplished by synchronizing on some object that naturally encapsulates the\n * set.</p>\n *\n * <p>This class was originally developed by Nathan Fiedler for the GraphMaker\n * project. It was imported to JGraphT with permission, courtesy of Nathan\n * Fiedler.</p>\n *\n * @author Nathan Fiedler\n */\npublic class FibonacciHeap<T>\n{\n    private static final double oneOverLogPhi =\n        1.0 / Math.log((1.0 + Math.sqrt(5.0)) / 2.0);\n\n    /**\n     * Points to the minimum node in the heap.\n     */\n    private FibonacciHeapNode<T> minNode;\n\n    /**\n     * Number of nodes in the heap.\n     */\n    private int nNodes;\n\n    /**\n     * Constructs a FibonacciHeap object that contains no elements.\n     */\n    public FibonacciHeap()\n    {\n    } // FibonacciHeap\n\n    /**\n     * Tests if the Fibonacci heap is empty or not. Returns true if the heap is\n     * empty, false otherwise.\n     *\n     * <p>Running time: O(1) actual</p>\n     *\n     * @return true if the heap is empty, false otherwise\n     */\n    public boolean isEmpty()\n    {\n        return minNode == null;\n    }\n\n    // isEmpty\n\n    /**\n     * Removes all elements from this heap.\n     */\n    public void clear()\n    {\n        minNode = null;\n        nNodes = 0;\n    }\n\n    // clear\n\n    /**\n     * Decreases the key value for a heap node, given the new value to take on.\n     * The structure of the heap may be changed and will not be consolidated.\n     *\n     * <p>Running time: O(1) amortized</p>\n     *\n     * @param x node to decrease the key of\n     * @param k new key value for node x\n     *\n     * @exception IllegalArgumentException Thrown if k is larger than x.key\n     * value.\n     */\n    public void decreaseKey(FibonacciHeapNode<T> x, double k)\n    {\n        if (k > x.key) {\n            throw new IllegalArgumentException(\n                \"decreaseKey() got larger key value. Current key: \" + x.key\n                + \" new key: \" + k);\n        }\n\n        x.key = k;\n\n        FibonacciHeapNode<T> y = x.parent;\n\n        if ((y != null) && (x.key < y.key)) {\n            cut(x, y);\n            cascadingCut(y);\n        }\n\n        if (x.key < minNode.key) {\n            minNode = x;\n        }\n    }\n\n    // decreaseKey\n\n    /**\n     * Deletes a node from the heap given the reference to the node. The trees\n     * in the heap will be consolidated, if necessary. This operation may fail\n     * to remove the correct element if there are nodes with key value\n     * -Infinity.\n     *\n     * <p>Running time: O(log n) amortized</p>\n     *\n     * @param x node to remove from heap\n     */\n    public void delete(FibonacciHeapNode<T> x)\n    {\n        // make x as small as possible\n        decreaseKey(x, Double.NEGATIVE_INFINITY);\n\n        // remove the smallest, which decreases n also\n        removeMin();\n    }\n\n    // delete\n\n    /**\n     * Inserts a new data element into the heap. No heap consolidation is\n     * performed at this time, the new node is simply inserted into the root\n     * list of this heap.\n     *\n     * <p>Running time: O(1) actual</p>\n     *\n     * @param node new node to insert into heap\n     * @param key key value associated with data object\n     */\n    public void insert(FibonacciHeapNode<T> node, double key)\n    {\n        node.key = key;\n\n        // concatenate node into min list\n        if (minNode != null) {\n            node.left = minNode;\n            node.right = minNode.right;\n            minNode.right = node;\n            node.right.left = node;\n\n            if (key < minNode.key) {\n                minNode = node;\n            }\n        } else {\n            minNode = node;\n        }\n\n        nNodes++;\n    }\n\n    // insert\n\n    /**\n     * Returns the smallest element in the heap. This smallest element is the\n     * one with the minimum key value.\n     *\n     * <p>Running time: O(1) actual</p>\n     *\n     * @return heap node with the smallest key\n     */\n    public FibonacciHeapNode<T> min()\n    {\n        return minNode;\n    }\n\n    // min\n\n    /**\n     * Removes the smallest element from the heap. This will cause the trees in\n     * the heap to be consolidated, if necessary.\n     *\n     * <p>Running time: O(log n) amortized</p>\n     *\n     * @return node with the smallest key\n     */\n    public FibonacciHeapNode<T> removeMin()\n    {\n        FibonacciHeapNode<T> z = minNode;\n\n        if (z != null) {\n            int numKids = z.degree;\n            FibonacciHeapNode<T> x = z.child;\n            FibonacciHeapNode<T> tempRight;\n\n            // for each child of z do...\n            while (numKids > 0) {\n                tempRight = x.right;\n\n                // remove x from child list\n                x.left.right = x.right;\n                x.right.left = x.left;\n\n                // add x to root list of heap\n                x.left = minNode;\n                x.right = minNode.right;\n                minNode.right = x;\n                x.right.left = x;\n\n                // set parent[x] to null\n                x.parent = null;\n                x = tempRight;\n                numKids--;\n            }\n\n            // remove z from root list of heap\n            z.left.right = z.right;\n            z.right.left = z.left;\n\n            if (z == z.right) {\n                minNode = null;\n            } else {\n                minNode = z.right;\n                consolidate();\n            }\n\n            // decrement size of heap\n            nNodes--;\n        }\n\n        return z;\n    }\n\n    // removeMin\n\n    /**\n     * Returns the size of the heap which is measured in the number of elements\n     * contained in the heap.\n     *\n     * <p>Running time: O(1) actual</p>\n     *\n     * @return number of elements in the heap\n     */\n    public int size()\n    {\n        return nNodes;\n    }\n\n    // size\n\n    /**\n     * Joins two Fibonacci heaps into a new one. No heap consolidation is\n     * performed at this time. The two root lists are simply joined together.\n     *\n     * <p>Running time: O(1) actual</p>\n     *\n     * @param h1 first heap\n     * @param h2 second heap\n     *\n     * @return new heap containing h1 and h2\n     */\n    public static <T> FibonacciHeap<T> union(\n        FibonacciHeap<T> h1,\n        FibonacciHeap<T> h2)\n    {\n        FibonacciHeap<T> h = new FibonacciHeap<T>();\n\n        if ((h1 != null) && (h2 != null)) {\n            h.minNode = h1.minNode;\n\n            if (h.minNode != null) {\n                if (h2.minNode != null) {\n                    h.minNode.right.left = h2.minNode.left;\n                    h2.minNode.left.right = h.minNode.right;\n                    h.minNode.right = h2.minNode;\n                    h2.minNode.left = h.minNode;\n\n                    if (h2.minNode.key < h1.minNode.key) {\n                        h.minNode = h2.minNode;\n                    }\n                }\n            } else {\n                h.minNode = h2.minNode;\n            }\n\n            h.nNodes = h1.nNodes + h2.nNodes;\n        }\n\n        return h;\n    }\n\n    // union\n\n    /**\n     * Creates a String representation of this Fibonacci heap.\n     *\n     * @return String of this.\n     */\n    @Override public String toString()\n    {\n        if (minNode == null) {\n            return \"FibonacciHeap=[]\";\n        }\n\n        // create a new stack and put root on it\n        Stack<FibonacciHeapNode<T>> stack = new Stack<FibonacciHeapNode<T>>();\n        stack.push(minNode);\n\n        StringBuffer buf = new StringBuffer(512);\n        buf.append(\"FibonacciHeap=[\");\n\n        // do a simple breadth-first traversal on the tree\n        while (!stack.empty()) {\n            FibonacciHeapNode<T> curr = stack.pop();\n            buf.append(curr);\n            buf.append(\", \");\n\n            if (curr.child != null) {\n                stack.push(curr.child);\n            }\n\n            FibonacciHeapNode<T> start = curr;\n            curr = curr.right;\n\n            while (curr != start) {\n                buf.append(curr);\n                buf.append(\", \");\n\n                if (curr.child != null) {\n                    stack.push(curr.child);\n                }\n\n                curr = curr.right;\n            }\n        }\n\n        buf.append(']');\n\n        return buf.toString();\n    }\n\n    // toString\n\n    /**\n     * Performs a cascading cut operation. This cuts y from its parent and then\n     * does the same for its parent, and so on up the tree.\n     *\n     * <p>Running time: O(log n); O(1) excluding the recursion</p>\n     *\n     * @param y node to perform cascading cut on\n     */\n    protected void cascadingCut(FibonacciHeapNode<T> y)\n    {\n        FibonacciHeapNode<T> z = y.parent;\n\n        // if there's a parent...\n        if (z != null) {\n            // if y is unmarked, set it marked\n            if (!y.mark) {\n                y.mark = true;\n            } else {\n                // it's marked, cut it from parent\n                cut(y, z);\n\n                // cut its parent as well\n                cascadingCut(z);\n            }\n        }\n    }\n\n    // cascadingCut\n\n    protected void consolidate()\n    {\n        int arraySize =\n            ((int) Math.floor(Math.log(nNodes) * oneOverLogPhi)) + 1;\n\n        List<FibonacciHeapNode<T>> array =\n            new ArrayList<FibonacciHeapNode<T>>(arraySize);\n\n        // Initialize degree array\n        for (int i = 0; i < arraySize; i++) {\n            array.add(null);\n        }\n\n        // Find the number of root nodes.\n        int numRoots = 0;\n        FibonacciHeapNode<T> x = minNode;\n\n        if (x != null) {\n            numRoots++;\n            x = x.right;\n\n            while (x != minNode) {\n                numRoots++;\n                x = x.right;\n            }\n        }\n\n        // For each node in root list do...\n        while (numRoots > 0) {\n            // Access this node's degree..\n            int d = x.degree;\n            FibonacciHeapNode<T> next = x.right;\n\n            // ..and see if there's another of the same degree.\n            for (;;) {\n                FibonacciHeapNode<T> y = array.get(d);\n                if (y == null) {\n                    // Nope.\n                    break;\n                }\n\n                // There is, make one of the nodes a child of the other.\n                // Do this based on the key value.\n                if (x.key > y.key) {\n                    FibonacciHeapNode<T> temp = y;\n                    y = x;\n                    x = temp;\n                }\n\n                // FibonacciHeapNode<T> y disappears from root list.\n                link(y, x);\n\n                // We've handled this degree, go to next one.\n                array.set(d, null);\n                d++;\n            }\n\n            // Save this node for later when we might encounter another\n            // of the same degree.\n            array.set(d, x);\n\n            // Move forward through list.\n            x = next;\n            numRoots--;\n        }\n\n        // Set min to null (effectively losing the root list) and\n        // reconstruct the root list from the array entries in array[].\n        minNode = null;\n\n        for (int i = 0; i < arraySize; i++) {\n            FibonacciHeapNode<T> y = array.get(i);\n            if (y == null) {\n                continue;\n            }\n\n            // We've got a live one, add it to root list.\n            if (minNode != null) {\n                // First remove node from root list.\n                y.left.right = y.right;\n                y.right.left = y.left;\n\n                // Now add to root list, again.\n                y.left = minNode;\n                y.right = minNode.right;\n                minNode.right = y;\n                y.right.left = y;\n\n                // Check if this is a new min.\n                if (y.key < minNode.key) {\n                    minNode = y;\n                }\n            } else {\n                minNode = y;\n            }\n        }\n    }\n\n    // consolidate\n\n    /**\n     * The reverse of the link operation: removes x from the child list of y.\n     * This method assumes that min is non-null.\n     *\n     * <p>Running time: O(1)</p>\n     *\n     * @param x child of y to be removed from y's child list\n     * @param y parent of x about to lose a child\n     */\n    protected void cut(FibonacciHeapNode<T> x, FibonacciHeapNode<T> y)\n    {\n        // remove x from childlist of y and decrement degree[y]\n        x.left.right = x.right;\n        x.right.left = x.left;\n        y.degree--;\n\n        // reset y.child if necessary\n        if (y.child == x) {\n            y.child = x.right;\n        }\n\n        if (y.degree == 0) {\n            y.child = null;\n        }\n\n        // add x to root list of heap\n        x.left = minNode;\n        x.right = minNode.right;\n        minNode.right = x;\n        x.right.left = x;\n\n        // set parent[x] to nil\n        x.parent = null;\n\n        // set mark[x] to false\n        x.mark = false;\n    }\n\n    // cut\n\n    /**\n     * Make node y a child of node x.\n     *\n     * <p>Running time: O(1) actual</p>\n     *\n     * @param y node to become child\n     * @param x node to become parent\n     */\n    protected void link(FibonacciHeapNode<T> y, FibonacciHeapNode<T> x)\n    {\n        // remove y from root list of heap\n        y.left.right = y.right;\n        y.right.left = y.left;\n\n        // make y a child of x\n        y.parent = x;\n\n        if (x.child == null) {\n            x.child = y;\n            y.right = y;\n            y.left = y;\n        } else {\n            y.left = x.child;\n            y.right = x.child.right;\n            x.child.right = y;\n            y.right.left = y;\n        }\n\n        // increase degree[x]\n        x.degree++;\n\n        // set mark[y] false\n        y.mark = false;\n    }\n\n    // link\n}\n\n// FibonacciHeap\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "isEmpty",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// FibonacciHeap\n/**\n * Tests if the Fibonacci heap is empty or not. Returns true if the heap is\n * empty, false otherwise.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @return true if the heap is empty, false otherwise\n */\npublic boolean isEmpty() {\n    return minNode == null;\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// union\n/**\n * Creates a String representation of this Fibonacci heap.\n *\n * @return String of this.\n */\n@Override\npublic String toString() {\n    if (minNode == null) {\n        return \"FibonacciHeap=[]\";\n    }\n    // create a new stack and put root on it\n    Stack<FibonacciHeapNode<T>> stack = new Stack<FibonacciHeapNode<T>>();\n    stack.push(minNode);\n    StringBuffer buf = new StringBuffer(512);\n    buf.append(\"FibonacciHeap=[\");\n    // do a simple breadth-first traversal on the tree\n    while (!stack.empty()) {\n        FibonacciHeapNode<T> curr = stack.pop();\n        buf.append(curr);\n        buf.append(\", \");\n        if (curr.child != null) {\n            stack.push(curr.child);\n        }\n        FibonacciHeapNode<T> start = curr;\n        curr = curr.right;\n        while (curr != start) {\n            buf.append(curr);\n            buf.append(\", \");\n            if (curr.child != null) {\n                stack.push(curr.child);\n            }\n            curr = curr.right;\n        }\n    }\n    buf.append(']');\n    return buf.toString();\n}"
            ],
            [
                "size",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// removeMin\n/**\n * Returns the size of the heap which is measured in the number of elements\n * contained in the heap.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @return number of elements in the heap\n */\npublic int size() {\n    return nNodes;\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "min",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// insert\n/**\n * Returns the smallest element in the heap. This smallest element is the\n * one with the minimum key value.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @return heap node with the smallest key\n */\npublic FibonacciHeapNode<T> min() {\n    return minNode;\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "removeMin",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// min\n/**\n * Removes the smallest element from the heap. This will cause the trees in\n * the heap to be consolidated, if necessary.\n *\n * <p>Running time: O(log n) amortized</p>\n *\n * @return node with the smallest key\n */\npublic FibonacciHeapNode<T> removeMin() {\n    FibonacciHeapNode<T> z = minNode;\n    if (z != null) {\n        int numKids = z.degree;\n        FibonacciHeapNode<T> x = z.child;\n        FibonacciHeapNode<T> tempRight;\n        // for each child of z do...\n        while (numKids > 0) {\n            tempRight = x.right;\n            // remove x from child list\n            x.left.right = x.right;\n            x.right.left = x.left;\n            // add x to root list of heap\n            x.left = minNode;\n            x.right = minNode.right;\n            minNode.right = x;\n            x.right.left = x;\n            // set parent[x] to null\n            x.parent = null;\n            x = tempRight;\n            numKids--;\n        }\n        // remove z from root list of heap\n        z.left.right = z.right;\n        z.right.left = z.left;\n        if (z == z.right) {\n            minNode = null;\n        } else {\n            minNode = z.right;\n            consolidate();\n        }\n        // decrement size of heap\n        nNodes--;\n    }\n    return z;\n}"
            ],
            [
                "coder",
                "java.lang",
                "String",
                "byte coder()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase(Locale arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0)"
            ],
            [
                "stripIndent",
                "java.lang",
                "String",
                "public String stripIndent()"
            ],
            [
                "replaceFirst",
                "java.lang",
                "String",
                "public String replaceFirst(String arg0, String arg1)"
            ],
            [
                "compareToIgnoreCase",
                "java.lang",
                "String",
                "public int compareToIgnoreCase(String arg0)"
            ],
            [
                "isBlank",
                "java.lang",
                "String",
                "public boolean isBlank()"
            ],
            [
                "charAt",
                "java.lang",
                "String",
                "public char charAt(int arg0)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase(Locale arg0)"
            ],
            [
                "indent",
                "java.lang",
                "String",
                "public String indent(int arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(String arg0) throws UnsupportedEncodingException"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(String arg0, int arg1)"
            ],
            [
                "trim",
                "java.lang",
                "String",
                "public String trim()"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)"
            ],
            [
                "toLowerCase",
                "java.lang",
                "String",
                "public String toLowerCase()"
            ],
            [
                "chars",
                "java.lang",
                "String",
                "public IntStream chars()"
            ],
            [
                "matches",
                "java.lang",
                "String",
                "public boolean matches(String arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0, int arg1)"
            ],
            [
                "stripLeading",
                "java.lang",
                "String",
                "public String stripLeading()"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0, int arg1)"
            ],
            [
                "isLatin1",
                "java.lang",
                "String",
                "boolean isLatin1()"
            ],
            [
                "subSequence",
                "java.lang",
                "String",
                "public CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "codePointBefore",
                "java.lang",
                "String",
                "public int codePointBefore(int arg0)"
            ],
            [
                "formatted",
                "java.lang",
                "String",
                "public String formatted(Object[] arg0)"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes(Charset arg0)"
            ],
            [
                "translateEscapes",
                "java.lang",
                "String",
                "public String translateEscapes()"
            ],
            [
                "endsWith",
                "java.lang",
                "String",
                "public boolean endsWith(String arg0)"
            ],
            [
                "length",
                "java.lang",
                "String",
                "public int length()"
            ],
            [
                "startsWith",
                "java.lang",
                "String",
                "public boolean startsWith(String arg0, int arg1)"
            ],
            [
                "describeConstable",
                "java.lang",
                "String",
                "public Optional<String> describeConstable()"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(char arg0, char arg1)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(StringBuffer arg0)"
            ],
            [
                "replaceAll",
                "java.lang",
                "String",
                "public String replaceAll(String arg0, String arg1)"
            ],
            [
                "strip",
                "java.lang",
                "String",
                "public String strip()"
            ],
            [
                "equalsIgnoreCase",
                "java.lang",
                "String",
                "public boolean equalsIgnoreCase(String arg0)"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0, int arg1)"
            ],
            [
                "toString",
                "java.lang",
                "String",
                "public String toString()"
            ],
            [
                "resolveConstantDesc",
                "java.lang",
                "String",
                "public String resolveConstantDesc(MethodHandles.Lookup arg0)"
            ],
            [
                "offsetByCodePoints",
                "java.lang",
                "String",
                "public int offsetByCodePoints(int arg0, int arg1)"
            ],
            [
                "intern",
                "java.lang",
                "String",
                "public native String intern()"
            ],
            [
                "toCharArray",
                "java.lang",
                "String",
                "public char[] toCharArray()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(String arg0, int arg1)"
            ],
            [
                "value",
                "java.lang",
                "String",
                "byte[] value()"
            ],
            [
                "repeat",
                "java.lang",
                "String",
                "public String repeat(int arg0)"
            ],
            [
                "stripTrailing",
                "java.lang",
                "String",
                "public String stripTrailing()"
            ],
            [
                "getBytes",
                "java.lang",
                "String",
                "public byte[] getBytes()"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0, int arg1)"
            ],
            [
                "toUpperCase",
                "java.lang",
                "String",
                "public String toUpperCase()"
            ],
            [
                "concat",
                "java.lang",
                "String",
                "public String concat(String arg0)"
            ],
            [
                "contentEquals",
                "java.lang",
                "String",
                "public boolean contentEquals(CharSequence arg0)"
            ],
            [
                "replace",
                "java.lang",
                "String",
                "public String replace(CharSequence arg0, CharSequence arg1)"
            ],
            [
                "transform",
                "java.lang",
                "String",
                "public <R> R transform(Function<? super String, ? extends R> arg0)"
            ],
            [
                "compareTo",
                "java.lang",
                "String",
                "public int compareTo(String arg0)"
            ],
            [
                "codePointAt",
                "java.lang",
                "String",
                "public int codePointAt(int arg0)"
            ],
            [
                "isEmpty",
                "java.lang",
                "String",
                "public boolean isEmpty()"
            ],
            [
                "equals",
                "java.lang",
                "String",
                "public boolean equals(Object arg0)"
            ],
            [
                "indexOf",
                "java.lang",
                "String",
                "public int indexOf(int arg0)"
            ],
            [
                "lines",
                "java.lang",
                "String",
                "public Stream<String> lines()"
            ],
            [
                "lastIndexOf",
                "java.lang",
                "String",
                "public int lastIndexOf(int arg0)"
            ],
            [
                "substring",
                "java.lang",
                "String",
                "public String substring(int arg0)"
            ],
            [
                "split",
                "java.lang",
                "String",
                "public String[] split(String arg0)"
            ],
            [
                "contains",
                "java.lang",
                "String",
                "public boolean contains(CharSequence arg0)"
            ],
            [
                "regionMatches",
                "java.lang",
                "String",
                "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)"
            ],
            [
                "hashCode",
                "java.lang",
                "String",
                "public int hashCode()"
            ],
            [
                "codePoints",
                "java.lang",
                "String",
                "public IntStream codePoints()"
            ],
            [
                "codePointCount",
                "java.lang",
                "String",
                "public int codePointCount(int arg0, int arg1)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "compareTo",
                "java.lang",
                "Comparable",
                "public abstract int compareTo(T arg0)"
            ],
            [
                "subSequence",
                "java.lang",
                "CharSequence",
                "public abstract CharSequence subSequence(int arg0, int arg1)"
            ],
            [
                "toString",
                "java.lang",
                "CharSequence",
                "public abstract String toString()"
            ],
            [
                "codePoints",
                "java.lang",
                "CharSequence",
                "public default IntStream codePoints()"
            ],
            [
                "isEmpty",
                "java.lang",
                "CharSequence",
                "public default boolean isEmpty()"
            ],
            [
                "length",
                "java.lang",
                "CharSequence",
                "public abstract int length()"
            ],
            [
                "charAt",
                "java.lang",
                "CharSequence",
                "public abstract char charAt(int arg0)"
            ],
            [
                "chars",
                "java.lang",
                "CharSequence",
                "public default IntStream chars()"
            ],
            [
                "describeConstable",
                "java.lang.constant",
                "Constable",
                "public abstract Optional<? extends ConstantDesc> describeConstable()"
            ],
            [
                "resolveConstantDesc",
                "java.lang.constant",
                "ConstantDesc",
                "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25866,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.util",
        "className": "VertexPair",
        "javadocTag": "@param v The vertex in question",
        "methodJavadoc": "    /**\n     * Assess if this pair contains the vertex.\n     *\n     * @param v The vertex in question\n     *\n     * @return true if contains, false otherwise\n     */",
        "methodSourceCode": "public boolean hasVertex(V v){\n    return v.equals(n1) || v.equals(n2);\n}",
        "classJavadoc": "/**\n * Representation of a pair of vertices; to be replaced by Pair&lt;V,V&gt; if\n * Sun ever gets around to adding Pair to java.util.\n *\n * @author Soren (soren@tanesha.net)\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2009, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -------------------------\n * VertexPair.java\n * -------------------------\n * (C) Copyright 2009-2009, by Soren Davidsen and Contributors\n *\n * Original Author:  Soren Davidsen\n *\n * $Id$\n *\n * Changes\n * -------\n * 03-Dec-2009 : Initial revision (SD);\n *\n */\npackage org.jgrapht.util;\n\n/**\n * Representation of a pair of vertices; to be replaced by Pair&lt;V,V&gt; if\n * Sun ever gets around to adding Pair to java.util.\n *\n * @author Soren (soren@tanesha.net)\n */\npublic class VertexPair<V>\n{\n    private V n1;\n    private V n2;\n\n    public VertexPair(V n1, V n2)\n    {\n        this.n1 = n1;\n        this.n2 = n2;\n    }\n\n    public V getFirst()\n    {\n        return n1;\n    }\n\n    public V getSecond()\n    {\n        return n2;\n    }\n\n    /**\n     * Assess if this pair contains the vertex.\n     *\n     * @param v The vertex in question\n     *\n     * @return true if contains, false otherwise\n     */\n    public boolean hasVertex(V v)\n    {\n        return v.equals(n1) || v.equals(n2);\n    }\n\n    public V getOther(V one)\n    {\n        if (one.equals(n1)) {\n            return n2;\n        } else if (one.equals(n2)) {\n            return n1;\n        } else {\n            return null;\n        }\n    }\n\n    @Override public String toString()\n    {\n        return n1 + \",\" + n2;\n    }\n\n    @Override public boolean equals(Object o)\n    {\n        if (this == o) {\n            return true;\n        }\n        if ((o == null) || (getClass() != o.getClass())) {\n            return false;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        VertexPair<V> that = (VertexPair<V>) o;\n\n        if ((n1 != null) ? (!n1.equals(that.n1)) : (that.n1 != null)) {\n            return false;\n        }\n        if ((n2 != null) ? (!n2.equals(that.n2)) : (that.n2 != null)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override public int hashCode()\n    {\n        int result = (n1 != null) ? n1.hashCode() : 0;\n        result = (31 * result) + ((n2 != null) ? n2.hashCode() : 0);\n        return result;\n    }\n}\n\n// End VertexPair.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "v",
                "",
                "V"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "toString",
                "org.jgrapht.util",
                "VertexPair",
                "@Override\npublic String toString() {\n    return n1 + \",\" + n2;\n}"
            ],
            [
                "getOther",
                "org.jgrapht.util",
                "VertexPair",
                "public V getOther(V one) {\n    if (one.equals(n1)) {\n        return n2;\n    } else if (one.equals(n2)) {\n        return n1;\n    } else {\n        return null;\n    }\n}"
            ],
            [
                "getFirst",
                "org.jgrapht.util",
                "VertexPair",
                "public V getFirst() {\n    return n1;\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "org.jgrapht.util",
                "VertexPair",
                "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if ((o == null) || (getClass() != o.getClass())) {\n        return false;\n    }\n    @SuppressWarnings(\"unchecked\")\n    VertexPair<V> that = (VertexPair<V>) o;\n    if ((n1 != null) ? (!n1.equals(that.n1)) : (that.n1 != null)) {\n        return false;\n    }\n    if ((n2 != null) ? (!n2.equals(that.n2)) : (that.n2 != null)) {\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "hasVertex",
                "org.jgrapht.util",
                "VertexPair",
                "/**\n * Assess if this pair contains the vertex.\n *\n * @param v The vertex in question\n *\n * @return true if contains, false otherwise\n */\npublic boolean hasVertex(V v) {\n    return v.equals(n1) || v.equals(n2);\n}"
            ],
            [
                "hashCode",
                "org.jgrapht.util",
                "VertexPair",
                "@Override\npublic int hashCode() {\n    int result = (n1 != null) ? n1.hashCode() : 0;\n    result = (31 * result) + ((n2 != null) ? n2.hashCode() : 0);\n    return result;\n}"
            ],
            [
                "getSecond",
                "org.jgrapht.util",
                "VertexPair",
                "public V getSecond() {\n    return n2;\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25882,
        "oracle": ";",
        "oracleType": "EXCEPT_POST",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht",
        "className": "Graph",
        "javadocTag": "@throws ClassCastException if the specified edge is not assignment\ncompatible with the class of edges produced by the edge factory of this\ngraph.",
        "methodJavadoc": "    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */",
        "methodSourceCode": "public boolean addEdge(V sourceVertex, V targetVertex, E e);",
        "classJavadoc": "/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------\n * Graph.java\n * ----------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   John V. Sichi\n *                   Christian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 24-Jul-2003 : Initial revision (BN);\n * 06-Nov-2003 : Change edge sharing semantics (JVS);\n * 11-Mar-2004 : Made generic (CH);\n * 07-May-2006 : Changed from List<Edge> to Set<Edge> (JVS);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht;\n\nimport java.util.*;\n\n\n/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)</tt> contains a set <tt>V</tt> of vertices and a set <tt>\n * E</tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http://mathworld.wolfram.com/Graph.html\">\n * http://mathworld.wolfram.com/Graph.html</a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http://mathworld.wolfram.com/topics/GraphTheory.html\">\n * http://mathworld.wolfram.com/topics/GraphTheory.html</a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph</code> provides a gallery of abstract and\n * concrete graph implementations.</p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.</p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V</code> and edges <code>E&lt;T&gt;</code>. Such a graph can contain\n * vertices of type <code>V</code> and all sub-types and Edges of type <code>\n * E</code> and all sub-types.</p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https://github.com/jgrapht/jgrapht/wiki/EqualsAndHashCode\">this wiki\n * page</a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n */\npublic interface Graph<V, E>\n{\n    /**\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null</code>, returns <code>null</code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     */\n    public Set<E> getAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null</code>. If any of the specified vertices is <code>null</code>\n     * returns <code>null</code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     */\n    public E getEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     */\n    public EdgeFactory<V, E> getEdgeFactory();\n\n    /**\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * <p>This method creates the new edge <code>e</code> using this graph's\n     * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n     * must <i>not</i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n     * e2</code> is found then the newly created edge <code>e</code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null</code>.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null</code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #getEdgeFactory()\n     */\n    public E addEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e</code>, to this graph if this graph contains no edge <code>e2</code>\n     * such that <code>e2.equals(e)</code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false</code>. If the edge was added to the graph, returns <code>\n     * true</code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.</p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null</code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     */\n    public boolean addEdge(V sourceVertex, V targetVertex, E e);\n\n    /**\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v</code>, to this graph if\n     * this graph contains no vertex <code>u</code> such that <code>\n     * u.equals(v)</code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false</tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true</tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null</code>.\n     */\n    public boolean addVertex(V v);\n\n    /**\n     * Returns <tt>true</tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null</code>, returns <code>false</code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true</tt> if and only if this graph contains an\n     * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n     * specified edge is <code>null</code> returns <code>false</code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified edge.\n     */\n    public boolean containsEdge(E e);\n\n    /**\n     * Returns <tt>true</tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true</tt> if and only if this graph contains a\n     * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n     * specified vertex is <code>null</code> returns <code>false</code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true</tt> if this graph contains the specified vertex.\n     */\n    public boolean containsVertex(V v);\n\n    /**\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set of the edges contained in this graph.\n     */\n    public Set<E> edgeSet();\n\n    /**\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null</code>.\n     */\n    public Set<E> edgesOf(V vertex);\n\n    /**\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     */\n    public boolean removeAllEdges(Collection<? extends E> edges);\n\n    /**\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null</code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null</code> if either vertex is not\n     * part of graph\n     */\n    public Set<E> removeAllEdges(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true</tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null</tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     */\n    public boolean removeAllVertices(Collection<? extends V> vertices);\n\n    /**\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null</code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null</code> if no edge removed.\n     */\n    public E removeEdge(V sourceVertex, V targetVertex);\n\n    /**\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n     * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if and only if the graph contained the\n     * specified edge.\n     */\n    public boolean removeEdge(E e);\n\n    /**\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n     * that touch <code>u</code> and then removes <code>u</code> itself. If no\n     * such <code>u</code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null</code> returns <code>\n     * false</code>.</p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true</code> if the graph contained the specified vertex;\n     * <code>false</code> otherwise.\n     */\n    public boolean removeVertex(V v);\n\n    /**\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.</p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     */\n    public Set<V> vertexSet();\n\n    /**\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     */\n    public V getEdgeSource(E e);\n\n    /**\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     */\n    public V getEdgeTarget(E e);\n\n    /**\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     */\n    public double getEdgeWeight(E e);\n}\n\n// End Graph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "2",
                "int"
            ],
            [
                "2",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "sourceVertex",
                "",
                "V"
            ],
            [
                "targetVertex",
                "",
                "V"
            ],
            [
                "e",
                "",
                "E"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n * weighted-graph algorithms to apply to them where meaningful.\n *\n * @param e edge of interest\n *\n * @return edge weight\n *\n * @see WeightedGraph\n */\npublic double getEdgeWeight(E e);"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns a set of all edges connecting source vertex to target vertex if\n * such vertices exist in this graph. If any of the vertices does not exist\n * or is <code>null</code>, returns <code>null</code>. If both vertices\n * exist but no edges found, returns an empty set.\n *\n * <p>In undirected graphs, some of the returned edges may have their source\n * and target vertices in the opposite order. In simple graphs the returned\n * set is either singleton set or empty set.</p>\n *\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return a set of all edges connecting source vertex to target vertex.\n */\npublic Set<E> getAllEdges(V sourceVertex, V targetVertex);"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "/**\n * Removes all the edges going from the specified source vertex to the\n * specified target vertex, and returns a set of all removed edges. Returns\n * <code>null</code> if any of the specified vertices does not exist in the\n * graph. If both vertices exist but no edge is found, returns an empty set.\n * This method will either invoke the {@link #removeEdge(Object)} method, or\n * the {@link #removeEdge(Object, Object)} method.\n *\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return the removed edges, or <code>null</code> if either vertex is not\n * part of graph\n */\npublic Set<E> removeAllEdges(V sourceVertex, V targetVertex);"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns an edge connecting source vertex to target vertex if such\n * vertices and such edge exist in this graph. Otherwise returns <code>\n * null</code>. If any of the specified vertices is <code>null</code>\n * returns <code>null</code>\n *\n * <p>In undirected graphs, the returned edge may have its source and target\n * vertices in the opposite order.</p>\n *\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return an edge connecting source vertex to target vertex.\n */\npublic E getEdge(V sourceVertex, V targetVertex);"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns a set of the vertices contained in this graph. The set is backed\n * by the graph, so changes to the graph are reflected in the set. If the\n * graph is modified while an iteration over the set is in progress, the\n * results of the iteration are undefined.\n *\n * <p>The graph implementation may maintain a particular set ordering (e.g.\n * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n * this is not required. It is the responsibility of callers who rely on\n * this behavior to only use graph implementations which support it.</p>\n *\n * @return a set view of the vertices contained in this graph.\n */\npublic Set<V> vertexSet();"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "/**\n * Creates a new edge in this graph, going from the source vertex to the\n * target vertex, and returns the created edge. Some graphs do not allow\n * edge-multiplicity. In such cases, if the graph already contains an edge\n * from the specified source to the specified target, than this method does\n * not change the graph and returns <code>null</code>.\n *\n * <p>The source and target vertices must already be contained in this\n * graph. If they are not found in graph IllegalArgumentException is\n * thrown.</p>\n *\n * <p>This method creates the new edge <code>e</code> using this graph's\n * <code>EdgeFactory</code>. For the new edge to be added <code>e</code>\n * must <i>not</i> be equal to any other edge the graph (even if the graph\n * allows edge-multiplicity). More formally, the graph must not contain any\n * edge <code>e2</code> such that <code>e2.equals(e)</code>. If such <code>\n * e2</code> is found then the newly created edge <code>e</code> is\n * abandoned, the method leaves this graph unchanged returns <code>\n * null</code>.</p>\n *\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @throws IllegalArgumentException if source or target vertices are not\n * found in the graph.\n * @throws NullPointerException if any of the specified vertices is <code>\n * null</code>.\n *\n * @see #getEdgeFactory()\n */\npublic E addEdge(V sourceVertex, V targetVertex);"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "/**\n * Removes the specified edge from the graph. Removes the specified edge\n * from this graph if it is present. More formally, removes an edge <code>\n * e2</code> such that <code>e2.equals(e)</code>, if the graph contains such\n * edge. Returns <tt>true</tt> if the graph contained the specified edge.\n * (The graph will not contain the specified edge once the call returns).\n *\n * <p>If the specified edge is <code>null</code> returns <code>\n * false</code>.</p>\n *\n * @param e edge to be removed from this graph, if present.\n *\n * @return <code>true</code> if and only if the graph contained the\n * specified edge.\n */\npublic boolean removeEdge(E e);"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns the target vertex of an edge. For an undirected graph, source and\n * target are distinguishable designations (but without any mathematical\n * meaning).\n *\n * @param e edge of interest\n *\n * @return target vertex\n */\npublic V getEdgeTarget(E e);"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns <tt>true</tt> if this graph contains the specified vertex. More\n * formally, returns <tt>true</tt> if and only if this graph contains a\n * vertex <code>u</code> such that <code>u.equals(v)</code>. If the\n * specified vertex is <code>null</code> returns <code>false</code>.\n *\n * @param v vertex whose presence in this graph is to be tested.\n *\n * @return <tt>true</tt> if this graph contains the specified vertex.\n */\npublic boolean containsVertex(V v);"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns the source vertex of an edge. For an undirected graph, source and\n * target are distinguishable designations (but without any mathematical\n * meaning).\n *\n * @param e edge of interest\n *\n * @return source vertex\n */\npublic V getEdgeSource(E e);"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "/**\n * Removes an edge going from source vertex to target vertex, if such\n * vertices and such edge exist in this graph. Returns the edge if removed\n * or <code>null</code> otherwise.\n *\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The removed edge, or <code>null</code> if no edge removed.\n */\npublic E removeEdge(V sourceVertex, V targetVertex);"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns the edge factory using which this graph creates new edges. The\n * edge factory is defined when the graph is constructed and must not be\n * modified.\n *\n * @return the edge factory using which this graph creates new edges.\n */\npublic EdgeFactory<V, E> getEdgeFactory();"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns a set of all edges touching the specified vertex. If no edges are\n * touching the specified vertex returns an empty set.\n *\n * @param vertex the vertex for which a set of touching edges is to be\n * returned.\n *\n * @return a set of all edges touching the specified vertex.\n *\n * @throws IllegalArgumentException if vertex is not found in the graph.\n * @throws NullPointerException if vertex is <code>null</code>.\n */\npublic Set<E> edgesOf(V vertex);"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "/**\n * Removes all the vertices in this graph that are also contained in the\n * specified vertex collection. After this call returns, this graph will\n * contain no vertices in common with the specified vertices. This method\n * will invoke the {@link #removeVertex(Object)} method.\n *\n * @param vertices vertices to be removed from this graph.\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see #removeVertex(Object)\n * @see #containsVertex(Object)\n */\npublic boolean removeAllVertices(Collection<? extends V> vertices);"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "/**\n * Adds the specified edge to this graph, going from the source vertex to\n * the target vertex. More formally, adds the specified edge, <code>\n * e</code>, to this graph if this graph contains no edge <code>e2</code>\n * such that <code>e2.equals(e)</code>. If this graph already contains such\n * an edge, the call leaves this graph unchanged and returns <tt>false</tt>.\n * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n * already contains an edge from the specified source to the specified\n * target, than this method does not change the graph and returns <code>\n * false</code>. If the edge was added to the graph, returns <code>\n * true</code>.\n *\n * <p>The source and target vertices must already be contained in this\n * graph. If they are not found in graph IllegalArgumentException is\n * thrown.</p>\n *\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param e edge to be added to this graph.\n *\n * @return <tt>true</tt> if this graph did not already contain the specified\n * edge.\n *\n * @throws IllegalArgumentException if source or target vertices are not\n * found in the graph.\n * @throws ClassCastException if the specified edge is not assignment\n * compatible with the class of edges produced by the edge factory of this\n * graph.\n * @throws NullPointerException if any of the specified vertices is <code>\n * null</code>.\n *\n * @see #addEdge(Object, Object)\n * @see #getEdgeFactory()\n */\npublic boolean addEdge(V sourceVertex, V targetVertex, E e);"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns <tt>true</tt> if this graph contains the specified edge. More\n * formally, returns <tt>true</tt> if and only if this graph contains an\n * edge <code>e2</code> such that <code>e.equals(e2)</code>. If the\n * specified edge is <code>null</code> returns <code>false</code>.\n *\n * @param e edge whose presence in this graph is to be tested.\n *\n * @return <tt>true</tt> if this graph contains the specified edge.\n */\npublic boolean containsEdge(E e);"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns a set of the edges contained in this graph. The set is backed by\n * the graph, so changes to the graph are reflected in the set. If the graph\n * is modified while an iteration over the set is in progress, the results\n * of the iteration are undefined.\n *\n * <p>The graph implementation may maintain a particular set ordering (e.g.\n * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n * this is not required. It is the responsibility of callers who rely on\n * this behavior to only use graph implementations which support it.</p>\n *\n * @return a set of the edges contained in this graph.\n */\npublic Set<E> edgeSet();"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "/**\n * Removes all the edges in this graph that are also contained in the\n * specified edge collection. After this call returns, this graph will\n * contain no edges in common with the specified edges. This method will\n * invoke the {@link #removeEdge(Object)} method.\n *\n * @param edges edges to be removed from this graph.\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n *\n * @throws NullPointerException if the specified edge collection is <tt>\n * null</tt>.\n *\n * @see #removeEdge(Object)\n * @see #containsEdge(Object)\n */\npublic boolean removeAllEdges(Collection<? extends E> edges);"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "/**\n * Returns <tt>true</tt> if and only if this graph contains an edge going\n * from the source vertex to the target vertex. In undirected graphs the\n * same result is obtained when source and target are inverted. If any of\n * the specified vertices does not exist in the graph, or if is <code>\n * null</code>, returns <code>false</code>.\n *\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return <tt>true</tt> if this graph contains the specified edge.\n */\npublic boolean containsEdge(V sourceVertex, V targetVertex);"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "/**\n * Removes the specified vertex from this graph including all its touching\n * edges if present. More formally, if the graph contains a vertex <code>\n * u</code> such that <code>u.equals(v)</code>, the call removes all edges\n * that touch <code>u</code> and then removes <code>u</code> itself. If no\n * such <code>u</code> is found, the call leaves the graph unchanged.\n * Returns <tt>true</tt> if the graph contained the specified vertex. (The\n * graph will not contain the specified vertex once the call returns).\n *\n * <p>If the specified vertex is <code>null</code> returns <code>\n * false</code>.</p>\n *\n * @param v vertex to be removed from this graph, if present.\n *\n * @return <code>true</code> if the graph contained the specified vertex;\n * <code>false</code> otherwise.\n */\npublic boolean removeVertex(V v);"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "/**\n * Adds the specified vertex to this graph if not already present. More\n * formally, adds the specified vertex, <code>v</code>, to this graph if\n * this graph contains no vertex <code>u</code> such that <code>\n * u.equals(v)</code>. If this graph already contains such vertex, the call\n * leaves this graph unchanged and returns <tt>false</tt>. In combination\n * with the restriction on constructors, this ensures that graphs never\n * contain duplicate vertices.\n *\n * @param v vertex to be added to this graph.\n *\n * @return <tt>true</tt> if this graph did not already contain the specified\n * vertex.\n *\n * @throws NullPointerException if the specified vertex is <code>\n * null</code>.\n */\npublic boolean addVertex(V v);"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25918,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "SimpleGraph",
        "javadocTag": "@param ef the edge factory of the new graph.",
        "methodJavadoc": "    /**\n     * Creates a new simple graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */",
        "methodSourceCode": "public SimpleGraph(EdgeFactory<V, E> ef){\n    super(ef, false, false);\n}",
        "classJavadoc": "/**\n * A simple graph. A simple graph is an undirected graph for which at most one\n * edge connects any two vertices, and loops are not permitted. If you're unsure\n * about simple graphs, see: <a\n * href=\"http://mathworld.wolfram.com/SimpleGraph.html\">\n * http://mathworld.wolfram.com/SimpleGraph.html</a>.\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* ----------------\n * SimpleGraph.java\n * ----------------\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * Original Author:  Barak Naveh\n * Contributor(s):   CHristian Hammer\n *\n * $Id$\n *\n * Changes\n * -------\n * 05-Aug-2003 : Initial revision (BN);\n * 06-Aug-2005 : Made generic (CH);\n * 28-May-2006 : Moved connectivity info from edge to graph (JVS);\n *\n */\npackage org.jgrapht.graph;\n\nimport org.jgrapht.*;\nimport org.jgrapht.graph.builder.*;\n\n\n/**\n * A simple graph. A simple graph is an undirected graph for which at most one\n * edge connects any two vertices, and loops are not permitted. If you're unsure\n * about simple graphs, see: <a\n * href=\"http://mathworld.wolfram.com/SimpleGraph.html\">\n * http://mathworld.wolfram.com/SimpleGraph.html</a>.\n */\npublic class SimpleGraph<V, E>\n    extends AbstractBaseGraph<V, E>\n    implements UndirectedGraph<V, E>\n{\n    private static final long serialVersionUID = 3545796589454112304L;\n\n    /**\n     * Creates a new simple graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     */\n    public SimpleGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, false, false);\n    }\n\n    /**\n     * Creates a new simple graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     */\n    public SimpleGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }\n\n    public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)\n    {\n        return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(\n            new SimpleGraph<V, E>(edgeClass));\n    }\n\n    public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(\n            new SimpleGraph<V, E>(ef));\n    }\n}\n\n// End SimpleGraph.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "ef",
                "org.jgrapht.EdgeFactory",
                "EdgeFactory<V, E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "edgeSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgeSet()"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public double getEdgeWeight(E arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "addVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addVertex(V arg0)"
            ],
            [
                "assertVertexExist",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean assertVertexExist(V arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "createUndirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.UndirectedSpecifics createUndirectedSpecifics()"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E addEdge(V arg0, V arg1)"
            ],
            [
                "incomingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> incomingEdgesOf(V arg0)"
            ],
            [
                "clone",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Object clone()"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean removeAllEdges(Collection<? extends E> arg0)"
            ],
            [
                "outgoingEdgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> outgoingEdgesOf(V arg0)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E removeEdge(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeTarget(E arg0)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public V getEdgeSource(E arg0)"
            ],
            [
                "removeVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeVertex(V arg0)"
            ],
            [
                "hashCode",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public int hashCode()"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toStringFromSets",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected String toStringFromSets(Collection<? extends V> arg0, Collection<? extends E> arg1, boolean arg2)"
            ],
            [
                "vertexSet",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<V> vertexSet()"
            ],
            [
                "addEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "removeEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean removeEdge(E arg0)"
            ],
            [
                "edgesOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public Set<E> edgesOf(V arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public E getEdge(V arg0, V arg1)"
            ],
            [
                "degreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int degreeOf(V arg0)"
            ],
            [
                "inDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int inDegreeOf(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht.graph",
                "AbstractGraph",
                "protected boolean removeAllEdges(E[] arg0)"
            ],
            [
                "createDirectedSpecifics",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "protected AbstractBaseGraph.DirectedSpecifics createDirectedSpecifics()"
            ],
            [
                "isAllowingMultipleEdges",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingMultipleEdges()"
            ],
            [
                "isAllowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean isAllowingLoops()"
            ],
            [
                "equals",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public boolean equals(Object arg0)"
            ],
            [
                "containsVertex",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsVertex(V arg0)"
            ],
            [
                "toString",
                "org.jgrapht.graph",
                "AbstractGraph",
                "public String toString()"
            ],
            [
                "outDegreeOf",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public int outDegreeOf(V arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "public boolean containsEdge(E arg0)"
            ],
            [
                "createEdge",
                "org.jgrapht",
                "EdgeFactory",
                "public abstract E createEdge(V arg0, V arg1)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [
            [
                "allowingLoops",
                "org.jgrapht.graph",
                "AbstractBaseGraph",
                "boolean allowingLoops;"
            ]
        ],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 25920,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "jgrapht-core-0.9.2",
        "packageName": "org.jgrapht.graph",
        "className": "DefaultGraphMapping",
        "javadocTag": "@param g1ToG2",
        "methodJavadoc": "    /**\n     * The maps themselves are used. There is no defensive-copy. Assumption: The\n     * key and value in the mappings are of valid graph objects. It is not\n     * checked.\n     *\n     * @param g1ToG2\n     * @param g2ToG1\n     * @param g1\n     * @param g2\n     */",
        "methodSourceCode": "public DefaultGraphMapping(Map<V, V> g1ToG2, Map<V, V> g2ToG1, Graph<V, E> g1, Graph<V, E> g2){\n    this.graph1 = g1;\n    this.graph2 = g2;\n    this.graphMappingForward = g1ToG2;\n    this.graphMappingReverse = g2ToG1;\n}",
        "classJavadoc": "/**\n * Implementation of the GraphMapping interface. The performance of <code>\n * getVertex/EdgeCorrespondence</code> is based on the performance of the\n * concrete Map class which is passed in the constructor. For example, using\n * hashmaps will provide O(1) performence.\n *\n * @author Assaf\n * @since Jul 30, 2005\n */",
        "classSourceCode": "/* ==========================================\n * JGraphT : a free Java graph-theory library\n * ==========================================\n *\n * Project Info:  http://jgrapht.sourceforge.net/\n * Project Creator:  Barak Naveh (http://sourceforge.net/users/barak_naveh)\n *\n * (C) Copyright 2003-2008, by Barak Naveh and Contributors.\n *\n * This program and the accompanying materials are dual-licensed under\n * either\n *\n * (a) the terms of the GNU Lesser General Public License version 2.1\n * as published by the Free Software Foundation, or (at your option) any\n * later version.\n *\n * or (per the licensee's choosing)\n *\n * (b) the terms of the Eclipse Public License v1.0 as published by\n * the Eclipse Foundation.\n */\n/* -----------------\n * DefaultGraphMapping.java\n * -----------------\n * (C) Copyright 2005-2008, by Assaf Lehr and Contributors.\n *\n * Original Author:  Assaf Lehr\n * Contributor(s):   -\n *\n * $Id$\n *\n * Changes\n * -------\n */\npackage org.jgrapht.graph;\n\nimport java.util.*;\n\nimport org.jgrapht.*;\n\n\n/**\n * Implementation of the GraphMapping interface. The performance of <code>\n * getVertex/EdgeCorrespondence</code> is based on the performance of the\n * concrete Map class which is passed in the constructor. For example, using\n * hashmaps will provide O(1) performence.\n *\n * @author Assaf\n * @since Jul 30, 2005\n */\npublic class DefaultGraphMapping<V, E>\n    implements GraphMapping<V, E>\n{\n    private Map<V, V> graphMappingForward;\n    private Map<V, V> graphMappingReverse;\n\n    private Graph<V, E> graph1;\n    private Graph<V, E> graph2;\n\n    /**\n     * The maps themselves are used. There is no defensive-copy. Assumption: The\n     * key and value in the mappings are of valid graph objects. It is not\n     * checked.\n     *\n     * @param g1ToG2\n     * @param g2ToG1\n     * @param g1\n     * @param g2\n     */\n    public DefaultGraphMapping(\n        Map<V, V> g1ToG2,\n        Map<V, V> g2ToG1,\n        Graph<V, E> g1,\n        Graph<V, E> g2)\n    {\n        this.graph1 = g1;\n        this.graph2 = g2;\n        this.graphMappingForward = g1ToG2;\n        this.graphMappingReverse = g2ToG1;\n    }\n\n    @Override public E getEdgeCorrespondence(E currEdge, boolean forward)\n    {\n        Graph<V, E> sourceGraph, targetGraph;\n\n        if (forward) {\n            sourceGraph = this.graph1;\n            targetGraph = this.graph2;\n        } else {\n            sourceGraph = this.graph2;\n            targetGraph = this.graph1;\n        }\n\n        V mappedSourceVertex =\n            getVertexCorrespondence(\n                sourceGraph.getEdgeSource(currEdge),\n                forward);\n        V mappedTargetVertex =\n            getVertexCorrespondence(\n                sourceGraph.getEdgeTarget(currEdge),\n                forward);\n        if ((mappedSourceVertex == null) || (mappedTargetVertex == null)) {\n            return null;\n        } else {\n            return targetGraph.getEdge(\n                mappedSourceVertex,\n                mappedTargetVertex);\n        }\n    }\n\n    @Override public V getVertexCorrespondence(\n        V keyVertex,\n        boolean forward)\n    {\n        Map<V, V> graphMapping;\n        if (forward) {\n            graphMapping = graphMappingForward;\n        } else {\n            graphMapping = graphMappingReverse;\n        }\n\n        return graphMapping.get(keyVertex);\n    }\n}\n\n// End DefaultGraphMapping.java\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "PartiteRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "RandomGraphHelper",
                "org.jgrapht.experimental"
            ],
            [
                "GraphReader",
                "org.jgrapht.experimental"
            ],
            [
                "DirectedAcyclicGraph",
                "org.jgrapht.experimental.dag"
            ],
            [
                "GraphSquare",
                "org.jgrapht.experimental"
            ],
            [
                "UniformRandomGraphGenerator",
                "org.jgrapht.experimental"
            ],
            [
                "GraphTests",
                "org.jgrapht.experimental"
            ],
            [
                "ApproximationAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "BrownBacktrackColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "GreedyColoring",
                "org.jgrapht.experimental.alg.color"
            ],
            [
                "IntArrayGraphAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ExactAlgorithm",
                "org.jgrapht.experimental.alg"
            ],
            [
                "ListenableGraph",
                "org.jgrapht"
            ],
            [
                "ModifiableInteger",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeapNode",
                "org.jgrapht.util"
            ],
            [
                "WeightCombiner",
                "org.jgrapht.util"
            ],
            [
                "FibonacciHeap",
                "org.jgrapht.util"
            ],
            [
                "TypeUtil",
                "org.jgrapht.util"
            ],
            [
                "ArrayUnenforcedSet",
                "org.jgrapht.util"
            ],
            [
                "VertexPair",
                "org.jgrapht.util"
            ],
            [
                "MathUtil",
                "org.jgrapht.util"
            ],
            [
                "PrefetchIterator",
                "org.jgrapht.util"
            ],
            [
                "VertexFactory",
                "org.jgrapht"
            ],
            [
                "Graph",
                "org.jgrapht"
            ],
            [
                "GraphPath",
                "org.jgrapht"
            ],
            [
                "UndirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraph",
                "org.jgrapht.graph"
            ],
            [
                "MixedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DefaultGraphMapping",
                "org.jgrapht.graph"
            ],
            [
                "WeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskEdgeSet",
                "org.jgrapht.graph"
            ],
            [
                "Pseudograph",
                "org.jgrapht.graph"
            ],
            [
                "MaskFunctor",
                "org.jgrapht.graph"
            ],
            [
                "GraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractBaseGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "Multigraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultWeightedEdge",
                "org.jgrapht.graph"
            ],
            [
                "ListenableDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphUnion",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeSetFactory",
                "org.jgrapht.graph"
            ],
            [
                "GraphDelegator",
                "org.jgrapht.graph"
            ],
            [
                "DefaultListenableGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedVertexFactory",
                "org.jgrapht.graph"
            ],
            [
                "DefaultEdge",
                "org.jgrapht.graph"
            ],
            [
                "MaskVertexSet",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ListenableUndirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsUnweightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DefaultDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "IntrusiveEdge",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphPathImpl",
                "org.jgrapht.graph"
            ],
            [
                "Subgraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedWeightedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedPseudograph",
                "org.jgrapht.graph"
            ],
            [
                "AbstractGraph",
                "org.jgrapht.graph"
            ],
            [
                "MaskSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "ClassBasedEdgeFactory",
                "org.jgrapht.graph"
            ],
            [
                "SimpleWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableUndirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UndirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "WeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "EdgeReversedGraph",
                "org.jgrapht.graph"
            ],
            [
                "AsWeightedGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "UndirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "AbstractGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedWeightedGraphBuilder",
                "org.jgrapht.graph.builder"
            ],
            [
                "DirectedGraphBuilderBase",
                "org.jgrapht.graph.builder"
            ],
            [
                "ListenableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "UnmodifiableDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleGraphPath",
                "org.jgrapht.graph"
            ],
            [
                "ParanoidGraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedWeightedMultigraph",
                "org.jgrapht.graph"
            ],
            [
                "DirectedSubgraph",
                "org.jgrapht.graph"
            ],
            [
                "SimpleDirectedGraph",
                "org.jgrapht.graph"
            ],
            [
                "GraphHelper",
                "org.jgrapht"
            ],
            [
                "Graphs",
                "org.jgrapht"
            ],
            [
                "DirectedGraph",
                "org.jgrapht"
            ],
            [
                "WeightedGraph",
                "org.jgrapht"
            ],
            [
                "HyperCubeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RingGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WheelGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GridGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "ScaleFreeGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "SimpleWeightedBipartiteGraphMatrixGenerator",
                "org.jgrapht.generate"
            ],
            [
                "LinearGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "RandomGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "WeightedGraphGeneratorAdapter",
                "org.jgrapht.generate"
            ],
            [
                "EmptyGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "CompleteBipartiteGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "GraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "StarGraphGenerator",
                "org.jgrapht.generate"
            ],
            [
                "UndirectedGraph",
                "org.jgrapht"
            ],
            [
                "TopologicalOrderIterator",
                "org.jgrapht.traverse"
            ],
            [
                "CrossComponentIterator",
                "org.jgrapht.traverse"
            ],
            [
                "AbstractGraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "ClosestFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "BreadthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "DepthFirstIterator",
                "org.jgrapht.traverse"
            ],
            [
                "GraphIterator",
                "org.jgrapht.traverse"
            ],
            [
                "EdgeFactory",
                "org.jgrapht"
            ],
            [
                "GraphMapping",
                "org.jgrapht"
            ],
            [
                "VertexSetListener",
                "org.jgrapht.event"
            ],
            [
                "EdgeTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "TraversalListener",
                "org.jgrapht.event"
            ],
            [
                "GraphEdgeChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "VertexTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphListener",
                "org.jgrapht.event"
            ],
            [
                "TraversalListenerAdapter",
                "org.jgrapht.event"
            ],
            [
                "ConnectedComponentTraversalEvent",
                "org.jgrapht.event"
            ],
            [
                "GraphVertexChangeEvent",
                "org.jgrapht.event"
            ],
            [
                "TarjanLowestCommonAncestor",
                "org.jgrapht.alg"
            ],
            [
                "PrimMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "BlockCutpointGraph",
                "org.jgrapht.alg"
            ],
            [
                "AllDirectedPaths",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPathsIterator",
                "org.jgrapht.alg"
            ],
            [
                "KruskalMinimumSpanningTree",
                "org.jgrapht.alg"
            ],
            [
                "StrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "VF2State",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2AbstractIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismState",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "GraphOrdering",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "IsomorphicGraphMapping",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2GraphIsomorphismInspector",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2SubgraphMappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "VF2MappingIterator",
                "org.jgrapht.alg.isomorphism"
            ],
            [
                "BronKerboschCliqueFinder",
                "org.jgrapht.alg"
            ],
            [
                "ChromaticNumber",
                "org.jgrapht.alg"
            ],
            [
                "KosarajuStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "DijkstraShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElement",
                "org.jgrapht.alg"
            ],
            [
                "AStarShortestPath",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordPathElement",
                "org.jgrapht.alg"
            ],
            [
                "FloydWarshallShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "UnionFind",
                "org.jgrapht.alg.util"
            ],
            [
                "AlwaysEqualComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Extension",
                "org.jgrapht.alg.util"
            ],
            [
                "VertexDegreeComparator",
                "org.jgrapht.alg.util"
            ],
            [
                "Pair",
                "org.jgrapht.alg.util"
            ],
            [
                "GabowStrongConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "HawickJamesSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "DirectedSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "JohnsonSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TiernanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "UndirectedCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "PatonCycleBase",
                "org.jgrapht.alg.cycle"
            ],
            [
                "TarjanSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "SzwarcfiterLauerSimpleCycles",
                "org.jgrapht.alg.cycle"
            ],
            [
                "BiconnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "ConnectivityInspector",
                "org.jgrapht.alg"
            ],
            [
                "MinSourceSinkCut",
                "org.jgrapht.alg"
            ],
            [
                "RankingPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsBlossomShrinking",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveClosure",
                "org.jgrapht.alg"
            ],
            [
                "HopcroftKarpBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "StoerWagnerMinimumCut",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElementList",
                "org.jgrapht.alg"
            ],
            [
                "KuhnMunkresMinimalWeightBipartitePerfectMatching",
                "org.jgrapht.alg"
            ],
            [
                "TransitiveReduction",
                "org.jgrapht.alg"
            ],
            [
                "EulerianCircuit",
                "org.jgrapht.alg"
            ],
            [
                "DirectedNeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "NaiveLcaFinder",
                "org.jgrapht.alg"
            ],
            [
                "MaximumWeightBipartiteMatching",
                "org.jgrapht.alg"
            ],
            [
                "HamiltonianCycle",
                "org.jgrapht.alg"
            ],
            [
                "KShortestPaths",
                "org.jgrapht.alg"
            ],
            [
                "NeighborIndex",
                "org.jgrapht.alg"
            ],
            [
                "VertexCovers",
                "org.jgrapht.alg"
            ],
            [
                "CycleDetector",
                "org.jgrapht.alg"
            ],
            [
                "AStarAdmissibleHeuristic",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MinimumSpanningTree",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "WeightedMatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "StrongConnectivityAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MaximumFlowAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "MatchingAlgorithm",
                "org.jgrapht.alg.interfaces"
            ],
            [
                "CliqueMinimalSeparatorDecomposition",
                "org.jgrapht.alg"
            ],
            [
                "BellmanFordIterator",
                "org.jgrapht.alg"
            ],
            [
                "AbstractPathElement",
                "org.jgrapht.alg"
            ],
            [
                "EdmondsKarpMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "PushRelabelMaximumFlow",
                "org.jgrapht.alg.flow"
            ],
            [
                "MaximumFlowAlgorithmBase",
                "org.jgrapht.alg.flow"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "addVertices",
                "org.jgrapht.experimental",
                "RandomGraphHelper",
                "/**\n * .\n *\n * @param target\n * @param vertexFactory\n * @param numVertices\n *\n * @return vertices\n */\n@SuppressWarnings(\"unchecked\")\npublic static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices) {\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}"
            ],
            [
                "isEmpty",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isEmpty(Graph<V, E> g) {\n    return g.edgeSet().isEmpty();\n}"
            ],
            [
                "isComplete",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isComplete(Graph<V, E> g) {\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) / 2);\n}"
            ],
            [
                "isConnected",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isConnected(Graph<V, E> g) {\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) / 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    // start with node 1\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}"
            ],
            [
                "isTree",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isTree(Graph<V, E> g) {\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}"
            ],
            [
                "isBipartite",
                "org.jgrapht.experimental",
                "GraphTests",
                "public static <V, E> boolean isBipartite(Graph<V, E> g) {\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
            ],
            [
                "union",
                "org.jgrapht.util",
                "FibonacciHeap",
                "// size\n/**\n * Joins two Fibonacci heaps into a new one. No heap consolidation is\n * performed at this time. The two root lists are simply joined together.\n *\n * <p>Running time: O(1) actual</p>\n *\n * @param h1 first heap\n * @param h2 second heap\n *\n * @return new heap containing h1 and h2\n */\npublic static <T> FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2) {\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}"
            ],
            [
                "uncheckedCast",
                "org.jgrapht.util",
                "TypeUtil",
                "/**\n * Casts an object to a type.\n *\n * @param o object to be cast\n * @param typeDecl conveys the target type information; the actual value is\n * unused and can be null since this is all just stupid compiler tricks\n *\n * @return the result of the cast\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl) {\n    return (T) o;\n}"
            ],
            [
                "factorial",
                "org.jgrapht.util",
                "MathUtil",
                "public static long factorial(int N) {\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleGraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedPseudograph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Pseudograph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedMultigraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedPseudograph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "Multigraph",
                "public static <V, E> UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DefaultDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedPseudograph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleWeightedGraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedWeightedGraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "WeightedMultigraph",
                "public static <V, E> UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "DirectedWeightedMultigraph",
                "public static <V, E> DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}"
            ],
            [
                "builder",
                "org.jgrapht.graph",
                "SimpleDirectedGraph",
                "public static <V, E> DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef) {\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graphs",
                "/**\n * Creates a new edge and adds it to the specified graph similarly to the\n * {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n *\n * @see Graph#addEdge(Object, Object)\n */\npublic static <V, E> E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    // we first create the edge and set the weight to make sure that\n    // listeners will see the correct weight upon addEdge.\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new edge and adds it to the specified\n * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified edge to the graph, including its vertices if not\n * already included.\n *\n * @param targetGraph the graph for which the specified edge to be added.\n * @param sourceGraph the graph in which the specified edge is already\n * present\n * @param edge edge to add\n *\n * @return <tt>true</tt> if the target graph did not already contain the\n * specified edge.\n */\npublic static <V, E> boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge) {\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}"
            ],
            [
                "addEdgeWithVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds the specified source and target vertices to the graph, if not\n * already included, and creates a new weighted edge and adds it to the\n * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n * method.\n *\n * @param g the graph for which the specified edge to be added.\n * @param sourceVertex source vertex of the edge.\n * @param targetVertex target vertex of the edge.\n * @param weight weight of the edge.\n *\n * @return The newly created edge if added to the graph, otherwise <code>\n * null</code>.\n */\npublic static <V, E> E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight) {\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}"
            ],
            [
                "addGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all the vertices and all the edges of the specified source graph to\n * the specified destination graph. First all vertices of the source graph\n * are added to the destination graph. Then every edge of the source graph\n * is added to the destination graph. This method returns <code>true</code>\n * if the destination graph has been modified as a result of this operation,\n * otherwise it returns <code>false</code>.\n *\n * <p>The behavior of this operation is undefined if any of the specified\n * graphs is modified while operation is in progress.</p>\n *\n * @param destination the graph to which vertices and edges are added.\n * @param source the graph used as source for vertices and edges to add.\n *\n * @return <code>true</code> if and only if the destination graph has been\n * changed as a result of this operation.\n */\npublic static <V, E> boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source) {\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}"
            ],
            [
                "addAllEdges",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds a subset of the edges of the specified source graph to the specified\n * destination graph. The behavior of this operation is undefined if either\n * of the graphs is modified while the operation is in progress. {@link\n * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n * be added automatically to the target graph.\n *\n * @param destination the graph to which edges are to be added\n * @param source the graph used as a source for edges to add\n * @param edges the edges to be added\n *\n * @return <tt>true</tt> if this graph changed as a result of the call\n */\npublic static <V, E> boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges) {\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}"
            ],
            [
                "addAllVertices",
                "org.jgrapht",
                "Graphs",
                "/**\n * Adds all of the specified vertices to the destination graph. The behavior\n * of this operation is undefined if the specified vertex collection is\n * modified while the operation is in progress. This method will invoke the\n * {@link Graph#addVertex(Object)} method.\n *\n * @param destination the graph to which edges are to be added\n * @param vertices the vertices to be added to the graph.\n *\n * @return <tt>true</tt> if graph changed as a result of the call\n *\n * @throws NullPointerException if the specified vertices contains one or\n * more null vertices, or if the specified vertex collection is <tt>\n * null</tt>.\n *\n * @see Graph#addVertex(Object)\n */\npublic static <V, E> boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices) {\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}"
            ],
            [
                "neighborListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the neighbors of a specified vertex.\n * If the graph is a multigraph vertices may appear more than once in the\n * returned list.\n *\n * @param g the graph to look for neighbors in.\n * @param vertex the vertex to get the neighbors of.\n *\n * @return a list of the vertices that are the neighbors of the specified\n * vertex.\n */\npublic static <V, E> List<V> neighborListOf(Graph<V, E> g, V vertex) {\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}"
            ],
            [
                "predecessorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct predecessors of a\n * specified vertex. If the graph is a multigraph, vertices may appear more\n * than once in the returned list.\n *\n * @param g the graph to look for predecessors in.\n * @param vertex the vertex to get the predecessors of.\n *\n * @return a list of the vertices that are the direct predecessors of the\n * specified vertex.\n */\npublic static <V, E> List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}"
            ],
            [
                "successorListOf",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns a list of vertices that are the direct successors of a specified\n * vertex. If the graph is a multigraph vertices may appear more than once\n * in the returned list.\n *\n * @param g the graph to look for successors in.\n * @param vertex the vertex to get the successors of.\n *\n * @return a list of the vertices that are the direct successors of the\n * specified vertex.\n */\npublic static <V, E> List<V> successorListOf(DirectedGraph<V, E> g, V vertex) {\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}"
            ],
            [
                "undirectedGraph",
                "org.jgrapht",
                "Graphs",
                "/**\n * Returns an undirected view of the specified graph. If the specified graph\n * is directed, returns an undirected view of it. If the specified graph is\n * already undirected, just returns it.\n *\n * @param g the graph for which an undirected view is to be returned.\n *\n * @return an undirected view of the specified graph, if it is directed, or\n * or the specified graph itself if it is already undirected.\n *\n * @throws IllegalArgumentException if the graph is neither DirectedGraph\n * nor UndirectedGraph.\n *\n * @see AsUndirectedGraph\n */\npublic static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}"
            ],
            [
                "testIncidence",
                "org.jgrapht",
                "Graphs",
                "/**\n * Tests whether an edge is incident to a vertex.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return true iff e is incident on v\n */\npublic static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v) {\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}"
            ],
            [
                "getOppositeVertex",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the vertex opposite another vertex across an edge.\n *\n * @param g graph containing e and v\n * @param e edge in g\n * @param v vertex in g\n *\n * @return vertex opposite to v across e\n */\npublic static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v) {\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}"
            ],
            [
                "getPathVertexList",
                "org.jgrapht",
                "Graphs",
                "/**\n * Gets the list of vertices visited by a path.\n *\n * @param path path of interest\n *\n * @return corresponding vertex list\n */\npublic static <V, E> List<V> getPathVertexList(GraphPath<V, E> path) {\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}"
            ],
            [
                "range",
                "org.jgrapht.generate",
                "SimpleWeightedGraphMatrixGenerator",
                "///////////////////////////////////////////////////////////////////////////////////////////////\npublic static int[] range(final int from, final int to) {\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}"
            ],
            [
                "createGraphSpecifics",
                "org.jgrapht.traverse",
                "CrossComponentIterator",
                "// -------------------------------------------------------------------------\n/**\n * @param <V>\n * @param <E>\n * @param g\n *\n * @return TODO Document me\n */\nstatic <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g) {\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}"
            ],
            [
                "findGreedyChromaticNumber",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds the number of colors required for a greedy coloring of the graph.\n *\n * @param g an undirected graph to find the chromatic number of\n *\n * @return integer the approximate chromatic number from the greedy\n * algorithm\n */\npublic static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g) {\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}"
            ],
            [
                "findGreedyColoredGroups",
                "org.jgrapht.alg",
                "ChromaticNumber",
                "/**\n * Finds a greedy coloring of the graph.\n *\n * @param g an undirected graph for which to find the coloring\n */\npublic static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g) {\n    // A copy of the graph is made, so that elements of the graph may be\n    // removed to carry out the algorithm\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // The Vertices will be sorted in decreasing order by degree, so that\n    // higher degree vertices have priority to be colored first\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    // create a map which will hold color as key and Set<V> as value\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    // We'll attempt to color each vertex with a single color each\n    // iteration, and these vertices will be removed from the graph at the\n    // end of each iteration\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        // This set will contain vertices that are colored with the\n        // current color of this iteration\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            // Add new vertices to be colored as long as they are not\n            // adjacent with any other vertex that has already been colored\n            // with the current color\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        // Add all these vertices as a group for this color\n        coloredGroups.put(color, currentColor);\n        // Remove vertices from the graph and then repeat the process for\n        // the next iteration\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "BellmanFordShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by hops, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}"
            ],
            [
                "findPathBetween",
                "org.jgrapht.alg",
                "DijkstraShortestPath",
                "/**\n * Convenience method to find the shortest path via a single static method\n * call. If you need a more advanced search (e.g. limited by radius, or\n * computation of the path length), use the constructor instead.\n *\n * @param graph the graph to be searched\n * @param startVertex the vertex at which the path should start\n * @param endVertex the vertex at which the path should end\n *\n * @return List of Edges, or null if no path exists\n */\npublic static <V, E> List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex) {\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}"
            ],
            [
                "of",
                "org.jgrapht.alg.util",
                "Pair",
                "/**\n * Creates new pair of elements pulling of the necessity to provide\n * corresponding types of the elements supplied\n *\n * @param a first element\n * @param b second element\n *\n * @return new pair\n */\npublic static <A, B> Pair<A, B> of(A a, B b) {\n    return new Pair<A, B>(a, b);\n}"
            ],
            [
                "isEulerian",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will check whether the graph passed in is Eulerian or not.\n *\n * @param g The graph to be checked\n *\n * @return true for Eulerian and false for non-Eulerian\n */\npublic static <V, E> boolean isEulerian(UndirectedGraph<V, E> g) {\n    // If the graph is not connected, then no Eulerian circuit exists\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    // A graph is Eulerian if and only if all vertices have even degree\n    // So, this code will check for that\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "getEulerianCircuitVertices",
                "org.jgrapht.alg",
                "EulerianCircuit",
                "/**\n * This method will return a list of vertices which represents the Eulerian\n * circuit of the graph.\n *\n * @param g The graph to find an Eulerian circuit\n *\n * @return null if no Eulerian circuit exists, or a list of vertices\n * representing the Eulerian circuit if one does exist\n */\npublic static <V, E> List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g) {\n    // If the graph is not Eulerian then just return a null since no\n    // Eulerian circuit exists\n    if (!isEulerian(g)) {\n        return null;\n    }\n    // The circuit will be represented by a linked list\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    // Algorithm for finding an Eulerian circuit Basically this will find an\n    // arbitrary circuit, then it will find another arbitrary circuit until\n    // every edge has been traversed\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        // Find a vertex which has an edge that hasn't been traversed yet,\n        // and keep its index position in the circuit list\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        // Finds an arbitrary circuit of the current vertex and\n        // appends this into the circuit list\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}"
            ],
            [
                "getApproximateOptimalForCompleteGraph",
                "org.jgrapht.alg",
                "HamiltonianCycle",
                "/**\n * This method will return an approximate minimal traveling salesman tour\n * (hamiltonian cycle). This algorithm requires that the graph be complete\n * and the triangle inequality exists (if x,y,z are vertices then\n * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n * guarantee a hamiltonian cycle such that the total weight of the cycle is\n * less than or equal to double the total weight of the optimal hamiltonian\n * cycle. The optimal solution is NP-complete, so this is a decent\n * approximation that runs in polynomial time.\n *\n * @param <V>\n * @param <E>\n * @param g is the graph to find the optimal tour for.\n *\n * @return The optimal tour as a list of vertices.\n */\npublic static <V, E> List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g) {\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    // If the graph is not complete then return null since this algorithm\n    // requires the graph be complete\n    if ((vertices.size() * (vertices.size() - 1) / 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    // Each iteration a new vertex will be added to the tour until all\n    // vertices have been added\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        // A check will be made for the shortest edge to a vertex not within\n        // the tour and that new vertex will be added to the vertex\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}"
            ],
            [
                "find2ApproximationCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a 2-approximation for a minimal vertex cover of the specified\n * graph. The algorithm promises a cover that is at most double the size of\n * a minimal cover. The algorithm takes O(|E|) time.\n *\n * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n * Language Theory and Computation, Fall 2002, Vassar College, <a\n * href=\"http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf\">\n * http://www.cs.vassar.edu/~walter/cs241index/lectures/PDF/approx.pdf</a>.\n * </p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G'=(V',E') <-- G(V,E)\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    // while E' is non-empty\n    while (sg.edgeSet().size() > 0) {\n        // let (u,v) be an arbitrary edge of E'\n        E e = sg.edgeSet().iterator().next();\n        // C <-- C U {u,v}\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        // remove from E' every edge incident on either u or v\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    // return C\n    return cover;\n}"
            ],
            [
                "findGreedyCover",
                "org.jgrapht.alg",
                "VertexCovers",
                "/**\n * Finds a greedy approximation for a minimal vertex cover of a specified\n * graph. At each iteration, the algorithm picks the vertex with the highest\n * degree and adds it to the cover, until all edges are covered.\n *\n * <p>The algorithm works on undirected graphs, but can also work on\n * directed graphs when their edge-directions are ignored. To ignore edge\n * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n * or {@link org.jgrapht.graph.AsUndirectedGraph}.</p>\n *\n * @param g the graph for which vertex cover approximation is to be found.\n *\n * @return a set of vertices which is a vertex cover for the specified\n * graph.\n */\npublic static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g) {\n    // C <-- {}\n    Set<V> cover = new HashSet<V>();\n    // G' <-- G\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    // compare vertices in descending order of degree\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    // while G' != {}\n    while (sg.edgeSet().size() > 0) {\n        // v <-- vertex with maximum degree in G'\n        V v = Collections.max(sg.vertexSet(), comp);\n        // C <-- C U {v}\n        cover.add(v);\n        // remove from G' every edge incident on v, and v itself\n        sg.removeVertex(v);\n    }\n    return cover;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "BEST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int BEST_ORDER = 0;"
            ],
            [
                "NATURAL_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int NATURAL_ORDER = 1;"
            ],
            [
                "SMALLEST_DEGREE_LAST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int SMALLEST_DEGREE_LAST_ORDER = 2;"
            ],
            [
                "LARGEST_SATURATION_FIRST_ORDER",
                "org.jgrapht.experimental.alg.color",
                "GreedyColoring",
                "public static final int LARGEST_SATURATION_FIRST_ORDER = 3;"
            ],
            [
                "DEFAULT_EDGE_WEIGHT",
                "org.jgrapht",
                "WeightedGraph",
                "/**\n * The default weight for an edge.\n */\npublic static double DEFAULT_EDGE_WEIGHT = 1.0;"
            ],
            [
                "HUB_VERTEX",
                "org.jgrapht.generate",
                "WheelGraphGenerator",
                "/**\n * Role for the hub vertex.\n */\npublic static final String HUB_VERTEX = \"Hub Vertex\";"
            ],
            [
                "CORNER_VERTEX",
                "org.jgrapht.generate",
                "GridGraphGenerator",
                "/**\n * Role for the vertices at the corners.\n */\npublic static final String CORNER_VERTEX = \"Corner Vertex\";"
            ],
            [
                "START_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the first vertex generated.\n */\npublic static final String START_VERTEX = \"Start Vertex\";"
            ],
            [
                "END_VERTEX",
                "org.jgrapht.generate",
                "LinearGraphGenerator",
                "/**\n * Role for the last vertex generated.\n */\npublic static final String END_VERTEX = \"End Vertex\";"
            ],
            [
                "CENTER_VERTEX",
                "org.jgrapht.generate",
                "StarGraphGenerator",
                "public static final String CENTER_VERTEX = \"Center Vertex\";"
            ],
            [
                "SENTINEL",
                "org.jgrapht.traverse",
                "DepthFirstIterator",
                "/**\n * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n * won't accept those. And we don't want to rely on the caller to provide a\n * sentinel object for us. So we have to play typecasting games.\n */\npublic static final Object SENTINEL = new Object();"
            ],
            [
                "BEFORE_EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge added event. This event is fired before an edge is added to a\n * graph.\n */\npublic static final int BEFORE_EDGE_ADDED = 21;"
            ],
            [
                "BEFORE_EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Before edge removed event. This event is fired before an edge is removed\n * from a graph.\n */\npublic static final int BEFORE_EDGE_REMOVED = 22;"
            ],
            [
                "EDGE_ADDED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge added event. This event is fired after an edge is added to a graph.\n */\npublic static final int EDGE_ADDED = 23;"
            ],
            [
                "EDGE_REMOVED",
                "org.jgrapht.event",
                "GraphEdgeChangeEvent",
                "/**\n * Edge removed event. This event is fired after an edge is removed from a\n * graph.\n */\npublic static final int EDGE_REMOVED = 24;"
            ],
            [
                "CONNECTED_COMPONENT_STARTED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal started event.\n */\npublic static final int CONNECTED_COMPONENT_STARTED = 31;"
            ],
            [
                "CONNECTED_COMPONENT_FINISHED",
                "org.jgrapht.event",
                "ConnectedComponentTraversalEvent",
                "/**\n * Connected component traversal finished event.\n */\npublic static final int CONNECTED_COMPONENT_FINISHED = 32;"
            ],
            [
                "BEFORE_VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex added event. This event is fired before a vertex is added\n * to a graph.\n */\npublic static final int BEFORE_VERTEX_ADDED = 11;"
            ],
            [
                "BEFORE_VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Before vertex removed event. This event is fired before a vertex is\n * removed from a graph.\n */\npublic static final int BEFORE_VERTEX_REMOVED = 12;"
            ],
            [
                "VERTEX_ADDED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex added event. This event is fired after a vertex is added to a\n * graph.\n */\npublic static final int VERTEX_ADDED = 13;"
            ],
            [
                "VERTEX_REMOVED",
                "org.jgrapht.event",
                "GraphVertexChangeEvent",
                "/**\n * Vertex removed event. This event is fired after a vertex is removed from\n * a graph.\n */\npublic static final int VERTEX_REMOVED = 14;"
            ],
            [
                "NULL_NODE",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "public static final int NULL_NODE = -1;"
            ],
            [
                "DEBUG",
                "org.jgrapht.alg.isomorphism",
                "VF2State",
                "protected static final boolean DEBUG = false;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg",
                "EdmondsKarpMaximumFlow",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 0.000000001;"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveClosure",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveClosure INSTANCE = new TransitiveClosure();"
            ],
            [
                "INSTANCE",
                "org.jgrapht.alg",
                "TransitiveReduction",
                "/**\n * Singleton instance.\n */\npublic static final TransitiveReduction INSTANCE = new TransitiveReduction();"
            ],
            [
                "NEGATIVE_UNDIRECTED_EDGE",
                "org.jgrapht.alg",
                "BellmanFordIterator",
                "/**\n * Error message.\n */\nprotected final static String NEGATIVE_UNDIRECTED_EDGE = \"Negative\" + \"edge-weights are not allowed in an unidrected graph!\";"
            ],
            [
                "DEFAULT_EPSILON",
                "org.jgrapht.alg.flow",
                "MaximumFlowAlgorithmBase",
                "/**\n * Default tolerance.\n */\npublic static final double DEFAULT_EPSILON = 1e-9;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "2",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "2",
                "int"
            ]
        ],
        "tokensMethodArguments": [
            [
                "g1ToG2",
                "java.util.Map",
                "Map<V, V>"
            ],
            [
                "g2ToG1",
                "java.util.Map",
                "Map<V, V>"
            ],
            [
                "g1",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ],
            [
                "g2",
                "org.jgrapht.Graph",
                "Graph<V, E>"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getEdgeCorrespondence",
                "org.jgrapht.graph",
                "DefaultGraphMapping",
                "@Override\npublic E getEdgeCorrespondence(E currEdge, boolean forward) {\n    Graph<V, E> sourceGraph, targetGraph;\n    if (forward) {\n        sourceGraph = this.graph1;\n        targetGraph = this.graph2;\n    } else {\n        sourceGraph = this.graph2;\n        targetGraph = this.graph1;\n    }\n    V mappedSourceVertex = getVertexCorrespondence(sourceGraph.getEdgeSource(currEdge), forward);\n    V mappedTargetVertex = getVertexCorrespondence(sourceGraph.getEdgeTarget(currEdge), forward);\n    if ((mappedSourceVertex == null) || (mappedTargetVertex == null)) {\n        return null;\n    } else {\n        return targetGraph.getEdge(mappedSourceVertex, mappedTargetVertex);\n    }\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "getVertexCorrespondence",
                "org.jgrapht.graph",
                "DefaultGraphMapping",
                "@Override\npublic V getVertexCorrespondence(V keyVertex, boolean forward) {\n    Map<V, V> graphMapping;\n    if (forward) {\n        graphMapping = graphMappingForward;\n    } else {\n        graphMapping = graphMappingReverse;\n    }\n    return graphMapping.get(keyVertex);\n}"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public abstract V remove(Object arg0)"
            ],
            [
                "entrySet",
                "java.util",
                "Map",
                "public abstract Set<Map.Entry<K, V>> entrySet()"
            ],
            [
                "putIfAbsent",
                "java.util",
                "Map",
                "public default V putIfAbsent(K arg0, V arg1)"
            ],
            [
                "get",
                "java.util",
                "Map",
                "public abstract V get(Object arg0)"
            ],
            [
                "keySet",
                "java.util",
                "Map",
                "public abstract Set<K> keySet()"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default V replace(K arg0, V arg1)"
            ],
            [
                "replace",
                "java.util",
                "Map",
                "public default boolean replace(K arg0, V arg1, V arg2)"
            ],
            [
                "put",
                "java.util",
                "Map",
                "public abstract V put(K arg0, V arg1)"
            ],
            [
                "equals",
                "java.util",
                "Map",
                "public abstract boolean equals(Object arg0)"
            ],
            [
                "merge",
                "java.util",
                "Map",
                "public default V merge(K arg0, V arg1, BiFunction<? super V, ? super V, ? extends V> arg2)"
            ],
            [
                "size",
                "java.util",
                "Map",
                "public abstract int size()"
            ],
            [
                "compute",
                "java.util",
                "Map",
                "public default V compute(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "computeIfPresent",
                "java.util",
                "Map",
                "public default V computeIfPresent(K arg0, BiFunction<? super K, ? super V, ? extends V> arg1)"
            ],
            [
                "getOrDefault",
                "java.util",
                "Map",
                "public default V getOrDefault(Object arg0, V arg1)"
            ],
            [
                "hashCode",
                "java.util",
                "Map",
                "public abstract int hashCode()"
            ],
            [
                "remove",
                "java.util",
                "Map",
                "public default boolean remove(Object arg0, Object arg1)"
            ],
            [
                "isEmpty",
                "java.util",
                "Map",
                "public abstract boolean isEmpty()"
            ],
            [
                "computeIfAbsent",
                "java.util",
                "Map",
                "public default V computeIfAbsent(K arg0, Function<? super K, ? extends V> arg1)"
            ],
            [
                "values",
                "java.util",
                "Map",
                "public abstract Collection<V> values()"
            ],
            [
                "containsKey",
                "java.util",
                "Map",
                "public abstract boolean containsKey(Object arg0)"
            ],
            [
                "containsValue",
                "java.util",
                "Map",
                "public abstract boolean containsValue(Object arg0)"
            ],
            [
                "getAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> getAllEdges(V arg0, V arg1)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(V arg0, V arg1)"
            ],
            [
                "getEdgeTarget",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeTarget(E arg0)"
            ],
            [
                "getEdgeFactory",
                "org.jgrapht",
                "Graph",
                "public abstract EdgeFactory<V, E> getEdgeFactory()"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeEdge(E arg0)"
            ],
            [
                "containsEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsEdge(E arg0)"
            ],
            [
                "removeAllVertices",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllVertices(Collection<? extends V> arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> removeAllEdges(V arg0, V arg1)"
            ],
            [
                "getEdgeSource",
                "org.jgrapht",
                "Graph",
                "public abstract V getEdgeSource(E arg0)"
            ],
            [
                "vertexSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<V> vertexSet()"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E addEdge(V arg0, V arg1)"
            ],
            [
                "removeEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E removeEdge(V arg0, V arg1)"
            ],
            [
                "addVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addVertex(V arg0)"
            ],
            [
                "getEdgeWeight",
                "org.jgrapht",
                "Graph",
                "public abstract double getEdgeWeight(E arg0)"
            ],
            [
                "getEdge",
                "org.jgrapht",
                "Graph",
                "public abstract E getEdge(V arg0, V arg1)"
            ],
            [
                "edgesOf",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgesOf(V arg0)"
            ],
            [
                "edgeSet",
                "org.jgrapht",
                "Graph",
                "public abstract Set<E> edgeSet()"
            ],
            [
                "containsVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean containsVertex(V arg0)"
            ],
            [
                "addEdge",
                "org.jgrapht",
                "Graph",
                "public abstract boolean addEdge(V arg0, V arg1, E arg2)"
            ],
            [
                "removeVertex",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeVertex(V arg0)"
            ],
            [
                "removeAllEdges",
                "org.jgrapht",
                "Graph",
                "public abstract boolean removeAllEdges(Collection<? extends E> arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]