[ {
  "id" : 4087,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Node",
  "javadocTag" : "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}.",
  "methodJavadoc" : "    /**\n\t * True if an edge exists between this node and a node with given index.\n\t * \n\t * @param index\n\t *            Index of another node.\n\t * @return True if an edge exists between this node and the other node.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */",
  "methodSourceCode" : "boolean hasEdgeBetween(int index) throws IndexOutOfBoundsException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */\npublic interface Node extends Element, Iterable<Edge> {\n\t/**\n\t * Parent graph. Some elements are not able to give their parent graph.\n\t * \n\t * @return The graph containing this node or null if unknown.\n\t */\n\tGraph getGraph();\n\n\t/**\n\t * Total number of relations with other nodes or this node.\n\t * \n\t * @return The number of edges/relations/links.\n\t */\n\tint getDegree();\n\n\t/**\n\t * Number of leaving edges.\n\t * \n\t * @return the count of edges that only leave this node plus all undirected\n\t *         edges.\n\t */\n\tint getOutDegree();\n\n\t/**\n\t * Number of entering edges.\n\t * \n\t * @return the count of edges that only enter this node plus all undirected\n\t *         edges.\n\t */\n\tint getInDegree();\n\n\t/**\n\t * True if an edge leaves this node toward node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeToward(String id);\n\n\t/**\n\t * True if an edge enters this node from node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(String id);\n\n\t/**\n\t * True if an edge exists between this node and node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of another node.\n\t * @return True if a edge exists between this node and node 'id'.\n\t */\n\tboolean hasEdgeBetween(String id);\n\n\t/**\n\t * Retrieve an edge that leaves this node toward 'id'.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at node 'id'\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return Directed edge going from this node to 'id', or undirected edge if\n\t *         it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(String id);\n\n\t/**\n\t * Retrieve an edge that leaves node 'id' toward this node.\n\t * <p>\n\t * This method selects only edges leaving node 'id' an pointing at this node\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return Directed edge going from node 'id' to this node, or undirected\n\t *         edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(String id);\n\n\t/**\n\t * Retrieve an edge between this node and the node 'id', if it exits.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the opposite node.\n\t * @return Edge between node 'id' and this node if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeBetween(String id);\n\n\t/**\n\t * Iterator on the set of connected edges.\n\t * <p>\n\t * This iterator iterates on all edges leaving and entering (this includes\n\t * any non-directed edge present, and a non-directed edge is only iterated\n\t * once).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEdgeIterator();\n\n\t/**\n\t * Iterator only on leaving edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from this node to\n\t * others (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEnteringEdgeIterator();\n\n\t/**\n\t * Iterator only on entering edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from other nodes\n\t * toward this node (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getLeavingEdgeIterator();\n\n\t/**\n\t * Iterator on the set of neighbor nodes connected to this node via one or\n\t * more edges. This iterator iterates across any leaving, entering and non\n\t * directed edges (nodes are neighbors even if they only have a directed\n\t * edge from them toward this node). If there are multiple edges connecting\n\t * the same node, it might be iterated several times.\n\t * \n\t * @return The iterator, neighbors are iterated in arbitrary order.\n\t */\n\t<T extends Node> Iterator<T> getNeighborNodeIterator();\n\n\t/**\n\t * I-th edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all edges, or to\n\t * choose a given edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             degree\n\t */\n\t<T extends Edge> T getEdge(int i);\n\n\t/**\n\t * I-th entering edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all entering edges,\n\t * or to choose a given entering edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEnteringEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th entering edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             in-degree\n\t */\n\t<T extends Edge> T getEnteringEdge(int i);\n\n\t/**\n\t * I-th leaving edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all leaving edges,\n\t * or to choose a given leaving edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getLeavingEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th leaving edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             out-degree\n\t */\n\t<T extends Edge> T getLeavingEdge(int i);\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator();\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed);\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t * @complexity of the depth first iterator O(n+m) with n the number of nodes\n\t *             and m the number of edges.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator();\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed);\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Iterable<T> getEachEdge();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachLeavingEdge();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachEnteringEdge();\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Collection<T> getEdgeSet();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getLeavingEdgeSet();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getEnteringEdgeSet();\n\n\t/**\n\t * Override the Object.toString() method.\n\t */\n\tString toString();\n\n\t// New methods\n\n\t/**\n\t * True if an edge leaves this node toward a given node.\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeToward(Node node);\n\n\t/**\n\t * True if an edge leaves this node toward a node with given index.\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeToward(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge enters this node from a given node.\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(Node node);\n\n\t/**\n\t * True if an edge enters this node from a node with given index.\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge exists between this node and another node.\n\t * \n\t * @param node\n\t *            Another node.\n\t * @return True if an edge exists between this node and the other node.\n\t */\n\tboolean hasEdgeBetween(Node node);\n\n\t/**\n\t * True if an edge exists between this node and a node with given index.\n\t * \n\t * @param index\n\t *            Index of another node.\n\t * @return True if an edge exists between this node and the other node.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeBetween(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves this node toward another node.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves this node toward the node with given index.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeToward(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves given node toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves node with given index toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge between this node and and another node if one exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The opposite node.\n\t * @return Edge between this node and the parameter node if it exists, else\n\t *         null.\n\t */\n\t<T extends Edge> T getEdgeBetween(Node node);\n\n\t/**\n\t * Retrieves an edge between this node and the node with index i if one\n\t * exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the opposite node.\n\t * @return Edge between node with index i and this node if it exists, else\n\t *         null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeBetween(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "index", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEnteringEdgeSet()" ], [ "getDegree", "org.graphstream.graph", "Node", "int getDegree()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(Node node)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(String id)" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getLeavingEdge(int i)" ], [ "toString", "org.graphstream.graph", "Node", "String toString()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEnteringEdgeIterator()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEdgeSet()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachLeavingEdge()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getEachEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEdge()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(Node node)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(Node node)" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getNeighborNodeIterator()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(String id)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(Node node)" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEnteringEdge(int i)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getLeavingEdgeSet()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(String id)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(Node node)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(String id)" ], [ "getOutDegree", "org.graphstream.graph", "Node", "int getOutDegree()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(String id)" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEnteringEdge()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "getEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEdge(int i)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getLeavingEdgeIterator()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(Node node)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEdgeIterator()" ], [ "getGraph", "org.graphstream.graph", "Node", "Graph getGraph()" ], [ "getInDegree", "org.graphstream.graph", "Node", "int getInDegree()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(String id)" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4088,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Node",
  "javadocTag" : "@param node The target node.",
  "methodJavadoc" : "    /**\n\t * Retrieves an edge that leaves this node toward another node.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t */",
  "methodSourceCode" : "<T extends Edge> T getEdgeToward(Node node);",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */\npublic interface Node extends Element, Iterable<Edge> {\n\t/**\n\t * Parent graph. Some elements are not able to give their parent graph.\n\t * \n\t * @return The graph containing this node or null if unknown.\n\t */\n\tGraph getGraph();\n\n\t/**\n\t * Total number of relations with other nodes or this node.\n\t * \n\t * @return The number of edges/relations/links.\n\t */\n\tint getDegree();\n\n\t/**\n\t * Number of leaving edges.\n\t * \n\t * @return the count of edges that only leave this node plus all undirected\n\t *         edges.\n\t */\n\tint getOutDegree();\n\n\t/**\n\t * Number of entering edges.\n\t * \n\t * @return the count of edges that only enter this node plus all undirected\n\t *         edges.\n\t */\n\tint getInDegree();\n\n\t/**\n\t * True if an edge leaves this node toward node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeToward(String id);\n\n\t/**\n\t * True if an edge enters this node from node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(String id);\n\n\t/**\n\t * True if an edge exists between this node and node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of another node.\n\t * @return True if a edge exists between this node and node 'id'.\n\t */\n\tboolean hasEdgeBetween(String id);\n\n\t/**\n\t * Retrieve an edge that leaves this node toward 'id'.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at node 'id'\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return Directed edge going from this node to 'id', or undirected edge if\n\t *         it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(String id);\n\n\t/**\n\t * Retrieve an edge that leaves node 'id' toward this node.\n\t * <p>\n\t * This method selects only edges leaving node 'id' an pointing at this node\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return Directed edge going from node 'id' to this node, or undirected\n\t *         edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(String id);\n\n\t/**\n\t * Retrieve an edge between this node and the node 'id', if it exits.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the opposite node.\n\t * @return Edge between node 'id' and this node if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeBetween(String id);\n\n\t/**\n\t * Iterator on the set of connected edges.\n\t * <p>\n\t * This iterator iterates on all edges leaving and entering (this includes\n\t * any non-directed edge present, and a non-directed edge is only iterated\n\t * once).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEdgeIterator();\n\n\t/**\n\t * Iterator only on leaving edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from this node to\n\t * others (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEnteringEdgeIterator();\n\n\t/**\n\t * Iterator only on entering edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from other nodes\n\t * toward this node (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getLeavingEdgeIterator();\n\n\t/**\n\t * Iterator on the set of neighbor nodes connected to this node via one or\n\t * more edges. This iterator iterates across any leaving, entering and non\n\t * directed edges (nodes are neighbors even if they only have a directed\n\t * edge from them toward this node). If there are multiple edges connecting\n\t * the same node, it might be iterated several times.\n\t * \n\t * @return The iterator, neighbors are iterated in arbitrary order.\n\t */\n\t<T extends Node> Iterator<T> getNeighborNodeIterator();\n\n\t/**\n\t * I-th edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all edges, or to\n\t * choose a given edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             degree\n\t */\n\t<T extends Edge> T getEdge(int i);\n\n\t/**\n\t * I-th entering edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all entering edges,\n\t * or to choose a given entering edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEnteringEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th entering edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             in-degree\n\t */\n\t<T extends Edge> T getEnteringEdge(int i);\n\n\t/**\n\t * I-th leaving edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all leaving edges,\n\t * or to choose a given leaving edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getLeavingEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th leaving edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             out-degree\n\t */\n\t<T extends Edge> T getLeavingEdge(int i);\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator();\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed);\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t * @complexity of the depth first iterator O(n+m) with n the number of nodes\n\t *             and m the number of edges.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator();\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed);\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Iterable<T> getEachEdge();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachLeavingEdge();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachEnteringEdge();\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Collection<T> getEdgeSet();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getLeavingEdgeSet();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getEnteringEdgeSet();\n\n\t/**\n\t * Override the Object.toString() method.\n\t */\n\tString toString();\n\n\t// New methods\n\n\t/**\n\t * True if an edge leaves this node toward a given node.\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeToward(Node node);\n\n\t/**\n\t * True if an edge leaves this node toward a node with given index.\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeToward(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge enters this node from a given node.\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(Node node);\n\n\t/**\n\t * True if an edge enters this node from a node with given index.\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge exists between this node and another node.\n\t * \n\t * @param node\n\t *            Another node.\n\t * @return True if an edge exists between this node and the other node.\n\t */\n\tboolean hasEdgeBetween(Node node);\n\n\t/**\n\t * True if an edge exists between this node and a node with given index.\n\t * \n\t * @param index\n\t *            Index of another node.\n\t * @return True if an edge exists between this node and the other node.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeBetween(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves this node toward another node.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves this node toward the node with given index.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeToward(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves given node toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves node with given index toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge between this node and and another node if one exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The opposite node.\n\t * @return Edge between this node and the parameter node if it exists, else\n\t *         null.\n\t */\n\t<T extends Edge> T getEdgeBetween(Node node);\n\n\t/**\n\t * Retrieves an edge between this node and the node with index i if one\n\t * exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the opposite node.\n\t * @return Edge between node with index i and this node if it exists, else\n\t *         null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeBetween(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "node", "org.graphstream.graph", "Node" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getInDegree", "org.graphstream.graph", "Node", "int getInDegree()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEdgeSet()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getNeighborNodeIterator()" ], [ "getGraph", "org.graphstream.graph", "Node", "Graph getGraph()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(String id)" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getLeavingEdge(int i)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(String id)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getLeavingEdgeIterator()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getEachEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEdge()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(Node node)" ], [ "toString", "org.graphstream.graph", "Node", "String toString()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(String id)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(String id)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(Node node)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEdgeIterator()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEnteringEdge(int i)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator()" ], [ "getDegree", "org.graphstream.graph", "Node", "int getDegree()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(Node node)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(Node node)" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEnteringEdge()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(Node node)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEnteringEdgeIterator()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getLeavingEdgeSet()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(String id)" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEnteringEdgeSet()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(Node node)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(String id)" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachLeavingEdge()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEdge(int i)" ], [ "getOutDegree", "org.graphstream.graph", "Node", "int getOutDegree()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4092,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Node",
  "javadocTag" : "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}.",
  "methodJavadoc" : "    /**\n\t * Retrieves an edge that leaves this node toward the node with given index.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */",
  "methodSourceCode" : "<T extends Edge> T getEdgeToward(int index) throws IndexOutOfBoundsException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */\npublic interface Node extends Element, Iterable<Edge> {\n\t/**\n\t * Parent graph. Some elements are not able to give their parent graph.\n\t * \n\t * @return The graph containing this node or null if unknown.\n\t */\n\tGraph getGraph();\n\n\t/**\n\t * Total number of relations with other nodes or this node.\n\t * \n\t * @return The number of edges/relations/links.\n\t */\n\tint getDegree();\n\n\t/**\n\t * Number of leaving edges.\n\t * \n\t * @return the count of edges that only leave this node plus all undirected\n\t *         edges.\n\t */\n\tint getOutDegree();\n\n\t/**\n\t * Number of entering edges.\n\t * \n\t * @return the count of edges that only enter this node plus all undirected\n\t *         edges.\n\t */\n\tint getInDegree();\n\n\t/**\n\t * True if an edge leaves this node toward node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeToward(String id);\n\n\t/**\n\t * True if an edge enters this node from node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(String id);\n\n\t/**\n\t * True if an edge exists between this node and node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of another node.\n\t * @return True if a edge exists between this node and node 'id'.\n\t */\n\tboolean hasEdgeBetween(String id);\n\n\t/**\n\t * Retrieve an edge that leaves this node toward 'id'.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at node 'id'\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return Directed edge going from this node to 'id', or undirected edge if\n\t *         it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(String id);\n\n\t/**\n\t * Retrieve an edge that leaves node 'id' toward this node.\n\t * <p>\n\t * This method selects only edges leaving node 'id' an pointing at this node\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return Directed edge going from node 'id' to this node, or undirected\n\t *         edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(String id);\n\n\t/**\n\t * Retrieve an edge between this node and the node 'id', if it exits.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the opposite node.\n\t * @return Edge between node 'id' and this node if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeBetween(String id);\n\n\t/**\n\t * Iterator on the set of connected edges.\n\t * <p>\n\t * This iterator iterates on all edges leaving and entering (this includes\n\t * any non-directed edge present, and a non-directed edge is only iterated\n\t * once).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEdgeIterator();\n\n\t/**\n\t * Iterator only on leaving edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from this node to\n\t * others (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEnteringEdgeIterator();\n\n\t/**\n\t * Iterator only on entering edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from other nodes\n\t * toward this node (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getLeavingEdgeIterator();\n\n\t/**\n\t * Iterator on the set of neighbor nodes connected to this node via one or\n\t * more edges. This iterator iterates across any leaving, entering and non\n\t * directed edges (nodes are neighbors even if they only have a directed\n\t * edge from them toward this node). If there are multiple edges connecting\n\t * the same node, it might be iterated several times.\n\t * \n\t * @return The iterator, neighbors are iterated in arbitrary order.\n\t */\n\t<T extends Node> Iterator<T> getNeighborNodeIterator();\n\n\t/**\n\t * I-th edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all edges, or to\n\t * choose a given edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             degree\n\t */\n\t<T extends Edge> T getEdge(int i);\n\n\t/**\n\t * I-th entering edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all entering edges,\n\t * or to choose a given entering edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEnteringEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th entering edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             in-degree\n\t */\n\t<T extends Edge> T getEnteringEdge(int i);\n\n\t/**\n\t * I-th leaving edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all leaving edges,\n\t * or to choose a given leaving edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getLeavingEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th leaving edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             out-degree\n\t */\n\t<T extends Edge> T getLeavingEdge(int i);\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator();\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed);\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t * @complexity of the depth first iterator O(n+m) with n the number of nodes\n\t *             and m the number of edges.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator();\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed);\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Iterable<T> getEachEdge();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachLeavingEdge();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachEnteringEdge();\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Collection<T> getEdgeSet();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getLeavingEdgeSet();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getEnteringEdgeSet();\n\n\t/**\n\t * Override the Object.toString() method.\n\t */\n\tString toString();\n\n\t// New methods\n\n\t/**\n\t * True if an edge leaves this node toward a given node.\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeToward(Node node);\n\n\t/**\n\t * True if an edge leaves this node toward a node with given index.\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeToward(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge enters this node from a given node.\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(Node node);\n\n\t/**\n\t * True if an edge enters this node from a node with given index.\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge exists between this node and another node.\n\t * \n\t * @param node\n\t *            Another node.\n\t * @return True if an edge exists between this node and the other node.\n\t */\n\tboolean hasEdgeBetween(Node node);\n\n\t/**\n\t * True if an edge exists between this node and a node with given index.\n\t * \n\t * @param index\n\t *            Index of another node.\n\t * @return True if an edge exists between this node and the other node.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeBetween(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves this node toward another node.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves this node toward the node with given index.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeToward(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves given node toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves node with given index toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge between this node and and another node if one exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The opposite node.\n\t * @return Edge between this node and the parameter node if it exists, else\n\t *         null.\n\t */\n\t<T extends Edge> T getEdgeBetween(Node node);\n\n\t/**\n\t * Retrieves an edge between this node and the node with index i if one\n\t * exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the opposite node.\n\t * @return Edge between node with index i and this node if it exists, else\n\t *         null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeBetween(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "index", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(Node node)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(String id)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEnteringEdgeIterator()" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEnteringEdge()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachLeavingEdge()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(String id)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getInDegree", "org.graphstream.graph", "Node", "int getInDegree()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(String id)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getDegree", "org.graphstream.graph", "Node", "int getDegree()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(Node node)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getLeavingEdgeIterator()" ], [ "toString", "org.graphstream.graph", "Node", "String toString()" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getNeighborNodeIterator()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(String id)" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getLeavingEdgeSet()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEnteringEdge(int i)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(Node node)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(String id)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(String id)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEdgeIterator()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(Node node)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(Node node)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(Node node)" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator()" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "getOutDegree", "org.graphstream.graph", "Node", "int getOutDegree()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getLeavingEdge(int i)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getGraph", "org.graphstream.graph", "Node", "Graph getGraph()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEnteringEdgeSet()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEdgeSet()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEdge(int i)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getEachEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEdge()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4097,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Node",
  "javadocTag" : "@throws IndexOutOfBoundsException if the index is negative or greater than {@code\n            getNodeCount() - 1}.",
  "methodJavadoc" : "    /**\n\t * Retrieves an edge that leaves node with given index toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */",
  "methodSourceCode" : "<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * An Interface that advises general purpose methods for handling nodes as\n * elements of a graph.\n * \n * <h3>Important</h3>\n * <p>\n * Implementing classes should indicate the complexity of their implementation\n * for each method.\n * </p>\n * \n * @since July 12 2007\n */\npublic interface Node extends Element, Iterable<Edge> {\n\t/**\n\t * Parent graph. Some elements are not able to give their parent graph.\n\t * \n\t * @return The graph containing this node or null if unknown.\n\t */\n\tGraph getGraph();\n\n\t/**\n\t * Total number of relations with other nodes or this node.\n\t * \n\t * @return The number of edges/relations/links.\n\t */\n\tint getDegree();\n\n\t/**\n\t * Number of leaving edges.\n\t * \n\t * @return the count of edges that only leave this node plus all undirected\n\t *         edges.\n\t */\n\tint getOutDegree();\n\n\t/**\n\t * Number of entering edges.\n\t * \n\t * @return the count of edges that only enter this node plus all undirected\n\t *         edges.\n\t */\n\tint getInDegree();\n\n\t/**\n\t * True if an edge leaves this node toward node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeToward(String id);\n\n\t/**\n\t * True if an edge enters this node from node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return True if a directed edge goes from this node to 'id' or if an\n\t *         undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(String id);\n\n\t/**\n\t * True if an edge exists between this node and node 'id'.\n\t * \n\t * @param id\n\t *            Identifier of another node.\n\t * @return True if a edge exists between this node and node 'id'.\n\t */\n\tboolean hasEdgeBetween(String id);\n\n\t/**\n\t * Retrieve an edge that leaves this node toward 'id'.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at node 'id'\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the target node.\n\t * @return Directed edge going from this node to 'id', or undirected edge if\n\t *         it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(String id);\n\n\t/**\n\t * Retrieve an edge that leaves node 'id' toward this node.\n\t * <p>\n\t * This method selects only edges leaving node 'id' an pointing at this node\n\t * (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the source node.\n\t * @return Directed edge going from node 'id' to this node, or undirected\n\t *         edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(String id);\n\n\t/**\n\t * Retrieve an edge between this node and the node 'id', if it exits.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the opposite node.\n\t * @return Edge between node 'id' and this node if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeBetween(String id);\n\n\t/**\n\t * Iterator on the set of connected edges.\n\t * <p>\n\t * This iterator iterates on all edges leaving and entering (this includes\n\t * any non-directed edge present, and a non-directed edge is only iterated\n\t * once).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEdgeIterator();\n\n\t/**\n\t * Iterator only on leaving edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from this node to\n\t * others (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getEnteringEdgeIterator();\n\n\t/**\n\t * Iterator only on entering edges.\n\t * <p>\n\t * This iterator iterates only on directed edges going from other nodes\n\t * toward this node (non-directed edges are included in the iteration).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return The iterator, edges are iterated in arbitrary order.\n\t */\n\t<T extends Edge> Iterator<T> getLeavingEdgeIterator();\n\n\t/**\n\t * Iterator on the set of neighbor nodes connected to this node via one or\n\t * more edges. This iterator iterates across any leaving, entering and non\n\t * directed edges (nodes are neighbors even if they only have a directed\n\t * edge from them toward this node). If there are multiple edges connecting\n\t * the same node, it might be iterated several times.\n\t * \n\t * @return The iterator, neighbors are iterated in arbitrary order.\n\t */\n\t<T extends Node> Iterator<T> getNeighborNodeIterator();\n\n\t/**\n\t * I-th edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all edges, or to\n\t * choose a given edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             degree\n\t */\n\t<T extends Edge> T getEdge(int i);\n\n\t/**\n\t * I-th entering edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all entering edges,\n\t * or to choose a given entering edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEnteringEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th entering edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             in-degree\n\t */\n\t<T extends Edge> T getEnteringEdge(int i);\n\n\t/**\n\t * I-th leaving edge. Edges are stored in no given order.\n\t * <p>\n\t * However this method allows to iterate very quickly on all leaving edges,\n\t * or to choose a given leaving edge with direct access.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getLeavingEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param i\n\t *            Index of the edge.\n\t * @return The i-th leaving edge.\n\t * @throws IndexOutOfBoundException\n\t *             if <code>i</code> is negative or greater than or equal to the\n\t *             out-degree\n\t */\n\t<T extends Edge> T getLeavingEdge(int i);\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator();\n\n\t/**\n\t * Iterator for breadth first exploration of the graph, starting at this\n\t * node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getBreadthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a breadth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed);\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored. By\n\t * default, this iterator will respect edge orientation.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator();\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t * @complexity of the depth first iterator O(n+m) with n the number of nodes\n\t *             and m the number of edges.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator();\n\n\t/**\n\t * Iterator for depth first exploration of the graph, starting at this node.\n\t * <p>\n\t * If the graph is not connected, only a part of it will be explored.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return an Iterator over something\n\t * which extends Node. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterator&lt;ExtendedNode&gt; ite = node.getDepthFirstIterator(true);\n\t * </pre>\n\t * \n\t * the method will return an Iterator&lt;ExtendedNode&gt;. If no left part\n\t * exists, method will just return an Iterator&lt;Node&gt;.\n\t * </p>\n\t * \n\t * @param directed\n\t *            If false, the iterator will ignore edge orientation (the\n\t *            default is \"True\").\n\t * @return An iterator able to explore the graph in a depth first way\n\t *         starting at this node.\n\t */\n\t<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed);\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Iterable<T> getEachEdge();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachLeavingEdge();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Iterable<T> getEachEnteringEdge();\n\n\t/**\n\t * Set of all entering and leaving edges.\n\t * \n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection containing all directed and undirected edges,\n\t *         leaving or entering.\n\t */\n\t<T extends Edge> Collection<T> getEdgeSet();\n\n\t/**\n\t * Set of all leaving edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getLeavingEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that leave this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getLeavingEdgeSet();\n\n\t/**\n\t * Set of all entering edges.\n\t * <p>\n\t * This method is implicitly generic and return an Iterable over something\n\t * which extends Edge. The return type is the one of the left part of the\n\t * assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * Iterable&lt;ExtendedEdge&gt; ite = node.getEnteringEdgeSet();\n\t * </pre>\n\t * \n\t * the method will return an Iterable&lt;ExtendedEdge&gt;. If no left part\n\t * exists, method will just return an Iterable&lt;Edge&gt;.\n\t * </p>\n\t * \n\t * @return A collection of only edges that enter this node plus all\n\t *         undirected edges.\n\t */\n\t<T extends Edge> Collection<T> getEnteringEdgeSet();\n\n\t/**\n\t * Override the Object.toString() method.\n\t */\n\tString toString();\n\n\t// New methods\n\n\t/**\n\t * True if an edge leaves this node toward a given node.\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeToward(Node node);\n\n\t/**\n\t * True if an edge leaves this node toward a node with given index.\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return True if a directed edge goes from this node to the other node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeToward(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge enters this node from a given node.\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t */\n\tboolean hasEdgeFrom(Node node);\n\n\t/**\n\t * True if an edge enters this node from a node with given index.\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return True if a directed edge goes from the other node to this node or\n\t *         if an undirected edge exists.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * True if an edge exists between this node and another node.\n\t * \n\t * @param node\n\t *            Another node.\n\t * @return True if an edge exists between this node and the other node.\n\t */\n\tboolean hasEdgeBetween(Node node);\n\n\t/**\n\t * True if an edge exists between this node and a node with given index.\n\t * \n\t * @param index\n\t *            Index of another node.\n\t * @return True if an edge exists between this node and the other node.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\tboolean hasEdgeBetween(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves this node toward another node.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeToward(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves this node toward the node with given index.\n\t * <p>\n\t * This method selects only edges leaving this node an pointing at the\n\t * parameter node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeToward(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the target node.\n\t * @return Directed edge going from this node to the parameter node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeToward(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge that leaves given node toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t */\n\t<T extends Edge> T getEdgeFrom(Node node);\n\n\t/**\n\t * Retrieves an edge that leaves node with given index toward this node.\n\t * <p>\n\t * This method selects only edges leaving the other node an pointing at this\n\t * node (this also selects undirected edges).\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeFrom(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            Index of the source node.\n\t * @return Directed edge going from the parameter node to this node, or\n\t *         undirected edge if it exists, else null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Retrieves an edge between this node and and another node if one exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param node\n\t *            The opposite node.\n\t * @return Edge between this node and the parameter node if it exists, else\n\t *         null.\n\t */\n\t<T extends Edge> T getEdgeBetween(Node node);\n\n\t/**\n\t * Retrieves an edge between this node and the node with index i if one\n\t * exists.\n\t * <p>\n\t * This method selects directed or undirected edges. If the edge is\n\t * directed, its direction is not important and leaving or entering edges\n\t * will be selected.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = node.getEdgeBetween(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the opposite node.\n\t * @return Edge between node with index i and this node if it exists, else\n\t *         null.\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdgeBetween(int index)\n\t\t\tthrows IndexOutOfBoundsException;\n\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "index", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(String id)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(Node node)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(Node node)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator(boolean directed)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "toString", "org.graphstream.graph", "Node", "String toString()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getDegree", "org.graphstream.graph", "Node", "int getDegree()" ], [ "getEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEdgeSet()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "getLeavingEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getLeavingEdgeSet()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getInDegree", "org.graphstream.graph", "Node", "int getInDegree()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getBreadthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getBreadthFirstIterator()" ], [ "getEnteringEdgeSet", "org.graphstream.graph", "Node", "<T extends Edge> Collection<T> getEnteringEdgeSet()" ], [ "getEachEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEdge()" ], [ "getLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getLeavingEdge(int i)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(String id)" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator()" ], [ "getDepthFirstIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getDepthFirstIterator(boolean directed)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getEachLeavingEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachLeavingEdge()" ], [ "getEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEdge(int i)" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(String id)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEdgeIterator()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(String id)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(int index) throws IndexOutOfBoundsException" ], [ "getEachEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> Iterable<T> getEachEnteringEdge()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(int index) throws IndexOutOfBoundsException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getNeighborNodeIterator", "org.graphstream.graph", "Node", "<T extends Node> Iterator<T> getNeighborNodeIterator()" ], [ "hasEdgeToward", "org.graphstream.graph", "Node", "boolean hasEdgeToward(Node node)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(String id)" ], [ "getEdgeToward", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeToward(Node node)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasEdgeFrom", "org.graphstream.graph", "Node", "boolean hasEdgeFrom(String id)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getEdgeFrom", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeFrom(Node node)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getLeavingEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getLeavingEdgeIterator()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getEdgeBetween", "org.graphstream.graph", "Node", "<T extends Edge> T getEdgeBetween(int index) throws IndexOutOfBoundsException" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getOutDegree", "org.graphstream.graph", "Node", "int getOutDegree()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getGraph", "org.graphstream.graph", "Node", "Graph getGraph()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getEnteringEdge", "org.graphstream.graph", "Node", "<T extends Edge> T getEnteringEdge(int i)" ], [ "getEnteringEdgeIterator", "org.graphstream.graph", "Node", "<T extends Edge> Iterator<T> getEnteringEdgeIterator()" ], [ "hasEdgeBetween", "org.graphstream.graph", "Node", "boolean hasEdgeBetween(Node node)" ], [ "toString", "java.lang", "Object", "public String toString()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4105,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@param id Identifier of the edge to find.",
  "methodJavadoc" : "    /**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */",
  "methodSourceCode" : "<T extends Edge> T getEdge(String id);",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4108,
  "oracle" : ";",
  "oracleType" : "NORMAL_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@return True if enabled.",
  "methodJavadoc" : "    /**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */",
  "methodSourceCode" : "boolean isAutoCreationEnabled();",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4113,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@param ef the new EdgeFactory",
  "methodJavadoc" : "    /**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */",
  "methodSourceCode" : "void setEdgeFactory(EdgeFactory<? extends Edge> ef);",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "ef", "org.graphstream.graph.EdgeFactory", "EdgeFactory<? extends Edge>" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "newInstance", "org.graphstream.graph", "EdgeFactory", "public abstract T newInstance(String arg0, Node arg1, Node arg2, boolean arg3)" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4118,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IdAlreadyInUseException If strict checking is enabled the identifier is already used.",
  "methodJavadoc" : "    /**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */",
  "methodSourceCode" : "<T extends Node> T addNode(String id) throws IdAlreadyInUseException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4126,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled.",
  "methodJavadoc" : "    /**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "\"node1\"", "String" ], [ "\"node2\"", "String" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "node1", "java.lang", "String" ], [ "node2", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "length", "java.lang", "String", "public int length()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4127,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws ElementNotFoundException If strict checking is enabled, and 'node1' or 'node2' are not\n            registered in the graph.",
  "methodJavadoc" : "    /**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "\"node1\"", "String" ], [ "\"node2\"", "String" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "node1", "java.lang", "String" ], [ "node2", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4128,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted.",
  "methodJavadoc" : "    /**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "\"node1\"", "String" ], [ "\"node2\"", "String" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "node1", "java.lang", "String" ], [ "node2", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4135,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws ElementNotFoundException If strict checking is enabled, and 'node1' or 'node2' are not\n            registered in the graph.",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "\"from\"", "String" ], [ "\"to\"", "String" ], [ "\"node1\"", "String" ], [ "\"node2\"", "String" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "from", "java.lang", "String" ], [ "to", "java.lang", "String" ], [ "directed", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4136,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws EdgeRejectedException If strict checking is enabled and the edge is not accepted.",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ], [ "2", "int" ], [ "\"from\"", "String" ], [ "\"to\"", "String" ], [ "\"node1\"", "String" ], [ "\"node2\"", "String" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "from", "java.lang", "String" ], [ "to", "java.lang", "String" ], [ "directed", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "length", "java.lang", "String", "public int length()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4140,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws ElementNotFoundException If the 'from' or 'to' node is not registered in the graph or\n            not connected and strict checking is enabled.",
  "methodJavadoc" : "    /**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "\"from\"", "String" ], [ "\"to\"", "String" ], [ "\"from\"", "String" ], [ "\"to\"", "String" ] ],
  "tokensMethodArguments" : [ [ "from", "java.lang", "String" ], [ "to", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4141,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@param id Identifier of the edge to remove.",
  "methodJavadoc" : "    /**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "length", "java.lang", "String", "public int length()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4143,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws ElementNotFoundException If no edge matches the identifier and strict checking is\n            enabled.",
  "methodJavadoc" : "    /**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */",
  "methodSourceCode" : "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "length", "java.lang", "String", "public int length()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4148,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws ElementNotFoundException If the file cannot be found or if the format is not\n            recognized.",
  "methodJavadoc" : "    /**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */",
  "methodSourceCode" : "void read(String filename) throws IOException, GraphParseException, ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4149,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws GraphParseException If there is a parsing error while reading the file.",
  "methodJavadoc" : "    /**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */",
  "methodSourceCode" : "void read(String filename) throws IOException, GraphParseException, ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4150,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IOException If an input output error occurs during the graph reading.",
  "methodJavadoc" : "    /**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */",
  "methodSourceCode" : "void read(String filename) throws IOException, GraphParseException, ElementNotFoundException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "length", "java.lang", "String", "public int length()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4154,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws GraphParseException If there is a parsing error while reading the file.",
  "methodJavadoc" : "    /**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */",
  "methodSourceCode" : "void read(FileSource input, String filename) throws IOException, GraphParseException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "input", "org.graphstream.stream.file", "FileSource" ], [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "nextEvents", "org.graphstream.stream.file", "FileSource", "public abstract boolean nextEvents() throws IOException" ], [ "nextStep", "org.graphstream.stream.file", "FileSource", "public abstract boolean nextStep() throws IOException" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4155,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IOException If an input/output error occurs during the graph reading.",
  "methodJavadoc" : "    /**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */",
  "methodSourceCode" : "void read(FileSource input, String filename) throws IOException, GraphParseException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "input", "org.graphstream.stream.file", "FileSource" ], [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "nextStep", "org.graphstream.stream.file", "FileSource", "public abstract boolean nextStep() throws IOException" ], [ "nextEvents", "org.graphstream.stream.file", "FileSource", "public abstract boolean nextEvents() throws IOException" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4157,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IOException If an input/output error occurs during the graph writing.",
  "methodJavadoc" : "    /**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */",
  "methodSourceCode" : "void write(String filename) throws IOException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4160,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IOException If an input/output error occurs during the graph writing.",
  "methodJavadoc" : "    /**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */",
  "methodSourceCode" : "void write(FileSink output, String filename) throws IOException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ ],
  "tokensMethodArguments" : [ [ "output", "org.graphstream.stream.file", "FileSink" ], [ "filename", "java.lang", "String" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4166,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IndexOutOfBoundsException If the index is negative or greater than {@code\n            getNodeCount() - 1}.",
  "methodJavadoc" : "    /**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */",
  "methodSourceCode" : "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "index", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4171,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@param index1 The first node index",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "index1", "", "int" ], [ "index2", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4172,
  "oracle" : ";",
  "oracleType" : "PRE",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@param index2 The second node index",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "index1", "", "int" ], [ "index2", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "length", "java.lang", "String", "public int length()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4174,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IndexOutOfBoundsException If node indices are negative or greater than {@code\n            getNodeCount() - 1}",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "index1", "", "int" ], [ "index2", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "length", "java.lang", "String", "public int length()" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4175,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IdAlreadyInUseException If an edge with the same id already exists and strict\n            checking is enabled.",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ], [ "2", "int" ], [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "index1", "", "int" ], [ "index2", "", "int" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "length", "java.lang", "String", "public int length()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
}, {
  "id" : 4182,
  "oracle" : ";",
  "oracleType" : "EXCEPT_POST",
  "projectName" : "gs-core-1.3",
  "packageName" : "org.graphstream.graph",
  "className" : "Graph",
  "javadocTag" : "@throws IndexOutOfBoundsException If node indices are negative or greater than {@code\n            getNodeCount() - 1}",
  "methodJavadoc" : "    /**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */",
  "methodSourceCode" : "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException;",
  "classJavadoc" : "/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */",
  "classSourceCode" : "/*\n * Copyright 2006 - 2015\n *     Stefan Balev     <stefan.balev@graphstream-project.org>\n *     Julien Baudry    <julien.baudry@graphstream-project.org>\n *     Antoine Dutot    <antoine.dutot@graphstream-project.org>\n *     Yoann Pign√©      <yoann.pigne@graphstream-project.org>\n *     Guilhelm Savin   <guilhelm.savin@graphstream-project.org>\n * \n * This file is part of GraphStream <http://graphstream-project.org>.\n * \n * GraphStream is a library whose purpose is to handle static or dynamic\n * graph, create them from scratch, file or any source and display them.\n * \n * This program is free software distributed under the terms of two licenses, the\n * CeCILL-C license that fits European law, and the GNU Lesser General Public\n * License. You can  use, modify and/ or redistribute the software under the terms\n * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following\n * URL <http://www.cecill.info> or under the terms of the GNU LGPL as published by\n * the Free Software Foundation, either version 3 of the License, or (at your\n * option) any later version.\n * \n * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n * \n * The fact that you are presently reading this means that you have had\n * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.\n */\npackage org.graphstream.graph;\n\nimport java.io.IOException;\n\nimport org.graphstream.stream.AttributeSink;\nimport org.graphstream.stream.ElementSink;\nimport org.graphstream.stream.GraphParseException;\nimport org.graphstream.stream.Pipe;\nimport org.graphstream.stream.file.FileSink;\nimport org.graphstream.stream.file.FileSource;\nimport org.graphstream.ui.view.Viewer;\n\n\n/**\n * An Interface that advises general purpose methods for handling graphs.\n * \n * <p>\n * This interface is one of the main interfaces of GraphStream. It defines the\n * services provided by a graph structure. Graphs implementations must at least\n * implement this interface (but are free to provide more services).\n * </p>\n * \n * <p>\n * With {@link org.graphstream.stream.Source},\n * {@link org.graphstream.stream.Sink} and {@link org.graphstream.stream.Pipe},\n * this interface is one of the most important. A graph is a\n * {@link org.graphstream.stream.Pipe} that buffers the graph events and present\n * the graph structure as it is actually.\n * </p>\n * \n * <p>\n * In other words, it allows to browse the graph structure, to explore it, to\n * modify it, and to implement algorithms on it. This class can be seen as a\n * snapshot of a stream of event at current time.\n * </p>\n * \n * <p>\n * With factories ({@link org.graphstream.graph.NodeFactory},\n * {@link org.graphstream.graph.EdgeFactory}), users can define their own models\n * of nodes or edges. Problem is that when you define such model, you want to\n * access to elements with the valid type, without cast if possible. To improve\n * the access to elements in such cases, Graph offers implicit genericity to\n * access nodes or edges. The following is an example of an access without\n * genericity :\n * \n * <pre>\n * \tGraph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = (MyNode) g.getNode(\"root\");\n *  \n *  for( Node o : g.getEachNode() )\n *  {\n *  \tMyNode node = (MyNode) o;\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * With implicit genericity offers by Graph, this can be done easier:\n * \n * <pre>\n *  Graph g = ... ;\n * \tg.setNodeFactory( new MyNodeFactory() );\n *  g.addNode(\"root\");\n *  \n *  MyNode n = g.getNode(\"root\");\n *  \n *  for( MyNode node : g.getEachNode() )\n *  {\n *  \t// Do something with node\n *  }\n * </pre>\n * \n * </p>\n * \n * <p>\n * Graph elements (nodes and edges) can be accessed using their identifier or\n * their index. Each node / edge has a unique string identifier assigned when\n * the element is created. Each element has an automatically maintained unique\n * index between 0 and {@link #getNodeCount()} - 1 or {@link #getEdgeCount()} -\n * 1. When a new element is added, its index is <code>getNodeCount() - 1</code>\n * or <code>getEdgeCount() - 1</code>. When an element is removed, the element\n * with the biggest index takes its place. Unlike identifiers, indices can\n * change when the graph is modified, but they are always successive. A loop of\n * the form\n * \n * <pre>\n * for (int i = 0; i &lt; g.getNodeCount(); i++) {\n * \tNode node = g.getNode(i);\n * \t// Do something with node\n * }\n * </pre>\n * \n * will always iterate on all the nodes of <code>g</code>.\n * </p>\n */\npublic interface Graph extends Element, Pipe, Iterable<Node>, Structure {\n\t// Access\n\n\t/**\n\t * Get a node by its identifier. This method is implicitly generic and\n\t * returns something which extends Node. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param id\n\t *            Identifier of the node to find.\n\t * @return The searched node or null if not found.\n\t */\n\t<T extends Node> T getNode(String id);\n\n\t/**\n\t * Get an edge by its identifier. This method is implicitly generic and\n\t * returns something which extends Edge. The return type is the one of the\n\t * left part of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param id\n\t *            Identifier of the edge to find.\n\t * @return The searched edge or null if not found.\n\t */\n\t<T extends Edge> T getEdge(String id);\n\n\t/**\n\t * The factory used to create node instances. The factory can be changed to\n\t * refine the node class generated for this graph.\n\t * \n\t * @see #setNodeFactory(NodeFactory)\n\t * @see #edgeFactory()\n\t */\n\tNodeFactory<? extends Node> nodeFactory();\n\n\t/**\n\t * The factory used to create edge instances. The factory can be changed to\n\t * refine the edge class generated for this graph.\n\t * \n\t * @see #setEdgeFactory(EdgeFactory)\n\t * @see #nodeFactory()\n\t */\n\tEdgeFactory<? extends Edge> edgeFactory();\n\n\t/**\n\t * Is strict checking enabled? If strict checking is enabled the graph\n\t * checks for name space conflicts (e.g. insertion of two nodes with the\n\t * same name), removal of non-existing elements, use of non existing\n\t * elements (create an edge between two non existing nodes). Graph\n\t * implementations are free to respect strict checking or not.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isStrict();\n\n\t/**\n\t * Is the automatic creation of missing elements enabled?. If strict\n\t * checking is disabled and auto-creation is enabled, when an edge is\n\t * created and one or two of its nodes are not already present in the graph,\n\t * the nodes are automatically created.\n\t * \n\t * @return True if enabled.\n\t */\n\tboolean isAutoCreationEnabled();\n\n\t/**\n\t * If true, when accessing an attribute that does not exist (or is not of\n\t * the expected type), a {@link NullAttributeException} is thrown. Else null\n\t * is returned.\n\t * \n\t * @return True if exceptions must be thrown when accessing a null\n\t *         attribute.\n\t */\n\tboolean nullAttributesAreErrors();\n\n\t/**\n\t * The current step.\n\t * \n\t * @return The step.\n\t */\n\tdouble getStep();\n\n\t// Command\n\n\t/**\n\t * Should a {@link NullAttributeException} be thrown when one tries to\n\t * access a non existing attribute, or an attribute whose type is not the\n\t * expected one?.\n\t * \n\t * @param on\n\t *            if true, exceptions will be thrown when accessing a non\n\t *            existing attribute.\n\t */\n\tvoid setNullAttributesAreErrors(boolean on);\n\n\t/**\n\t * Set the node factory used to create nodes.\n\t * \n\t * @param nf\n\t *            the new NodeFactory\n\t */\n\tvoid setNodeFactory(NodeFactory<? extends Node> nf);\n\n\t/**\n\t * Set the edge factory used to create edges.\n\t * \n\t * @param ef\n\t *            the new EdgeFactory\n\t */\n\tvoid setEdgeFactory(EdgeFactory<? extends Edge> ef);\n\n\t/**\n\t * Enable or disable strict checking.\n\t * \n\t * @see #isStrict()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setStrict(boolean on);\n\n\t/**\n\t * Enable or disable the automatic creation of missing elements.\n\t * \n\t * @see #isAutoCreationEnabled()\n\t * @param on\n\t *            True or false.\n\t */\n\tvoid setAutoCreate(boolean on);\n\n\t// Graph construction\n\n\t/**\n\t * Empty the graph completely by removing any references to nodes or edges.\n\t * Every attribute is also removed. However, listeners are kept.\n\t * \n\t * @see #clearSinks()\n\t */\n\tvoid clear();\n\n\t/**\n\t * Add a node in the graph.\n\t * <p>\n\t * This acts as a factory, creating the node instance automatically (and\n\t * eventually using the node factory provided). An event is generated toward\n\t * the listeners. If strict checking is enabled, and a node already exists\n\t * with this identifier, an\n\t * {@link org.graphstream.graph.IdAlreadyInUseException} is raised. Else the\n\t * error is silently ignored and the already existing node is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.addNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            Arbitrary and unique string identifying the node.\n\t * @return The created node (or the already existing node).\n\t * @throws IdAlreadyInUseException\n\t *             If strict checking is enabled the identifier is already used.\n\t */\n\t<T extends Node> T addNode(String id) throws IdAlreadyInUseException;\n\n\t/**\n\t * Remove a node using its identifier.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param id\n\t *            The unique identifier of the node to remove.\n\t * @return The removed node. If strict checking is disabled, it can return\n\t *         null if the node to remove does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no node matches the given identifier and strict checking\n\t *             is enabled.\n\t */\n\t<T extends Node> T removeNode(String id) throws ElementNotFoundException;\n\n\t/**\n\t * Adds an undirected edge between nodes.\n\t * \n\t * <p>\n\t * The behavior of this method depends on many conditions. It can be\n\t * summarized as follows.\n\t * </p>\n\t * \n\t * <p>\n\t * First of all, the method checks if the graph already contains an edge\n\t * with the same id. If this is the case and strict checking is enabled,\n\t * {@code IdAlreadyInUseException} is thrown. If the strict checking is\n\t * disabled the method returns a reference to the existing edge if it has\n\t * endpoints {@code node1} and {@code node2} (in the same order if the edge\n\t * is directed) or {@code null} otherwise.\n\t * </p>\n\t * \n\t * <p>\n\t * In the case when the graph does not contain an edge with the same id, the\n\t * method checks if {@code node1} and {@code node2} exist. If one or both of\n\t * them do not exist, and strict checking is enabled, {@code\n\t * ElementNotFoundException} is thrown. Otherwise if auto-creation is\n\t * disabled, the method returns {@code null}. If auto-creation is enabled,\n\t * the method creates the missing endpoints.\n\t * \n\t * <p>\n\t * When the edge id is not already in use and the both endpoints exist (or\n\t * created), the edge can still be rejected. It may happen for example when\n\t * it connects two already connected nodes in a single graph. If the edge is\n\t * rejected, the method throws {@code EdgeRejectedException} if strict\n\t * checking is enabled or returns {@code null} otherwise. Finally, if the\n\t * edge is accepted, it is created using the corresponding edge factory and\n\t * a reference to it is returned.\n\t * \n\t * <p>\n\t * An edge creation event is sent toward the listeners. If new nodes are\n\t * created, the corresponding events are also sent to the listeners.\n\t * </p>\n\t * \n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.addEdge(&quot;...&quot;, &quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * \n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t */\n\t<T extends Edge> T addEdge(String id, String node1, String node2)\n\t\t\tthrows IdAlreadyInUseException, ElementNotFoundException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)}, but this edge can be\n\t * directed between the two given nodes. If directed, the edge goes in the\n\t * 'from' -&gt; 'to' direction. An event is sent toward the listeners.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node identifier.\n\t * @param node2\n\t *            The second node identifier.\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null} (see the\n\t *         detailed description above)\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws ElementNotFoundException\n\t *             If strict checking is enabled, and 'node1' or 'node2' are not\n\t *             registered in the graph.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, String from, String to,\n\t\t\tboolean directed) throws IdAlreadyInUseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Remove an edge given the identifiers of its two endpoints.\n\t * <p>\n\t * If the edge is directed it is removed only if its source and destination\n\t * nodes are identified by 'from' and 'to' respectively. If the graph is a\n\t * multi-graph and there are several edges between the two nodes, one of the\n\t * edges at random is removed. An event is sent toward the listeners. If\n\t * strict checking is enabled and at least one of the two given nodes does\n\t * not exist or if they are not connected, a not found exception is raised.\n\t * Else the error is silently ignored, and null is returned.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;, &quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param from\n\t *            The origin node identifier to select the edge.\n\t * @param to\n\t *            The destination node identifier to select the edge.\n\t * @return The removed edge, or null if strict checking is disabled and at\n\t *         least one of the two given nodes does not exist or there is no\n\t *         edge between them\n\t * @throws ElementNotFoundException\n\t *             If the 'from' or 'to' node is not registered in the graph or\n\t *             not connected and strict checking is enabled.\n\t */\n\t<T extends Edge> T removeEdge(String from, String to)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge knowing its identifier. An event is sent toward the\n\t * listeners. If strict checking is enabled and the edge does not exist,\n\t * {@code ElementNotFoundException} is raised. Otherwise the error is\n\t * silently ignored and null is returned.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(&quot;...&quot;);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * @param id\n\t *            Identifier of the edge to remove.\n\t * @return The removed edge, or null if strict checking is disabled and the\n\t *         edge does not exist.\n\t * @throws ElementNotFoundException\n\t *             If no edge matches the identifier and strict checking is\n\t *             enabled.\n\t */\n\t<T extends Edge> T removeEdge(String id) throws ElementNotFoundException;\n\n\t/**\n\t * <p>\n\t * Since dynamic graphs are based on discrete event modifications, the\n\t * notion of step is defined to simulate elapsed time between events. So a\n\t * step is a event that occurs in the graph, it does not modify it but it\n\t * gives a kind of timestamp that allows the tracking of the progress of the\n\t * graph over the time.\n\t * </p>\n\t * <p>\n\t * This kind of event is useful for dynamic algorithms that listen to the\n\t * dynamic graph and need to measure the time in the graph's evolution.\n\t * </p>\n\t * \n\t * @param time\n\t *            A numerical value that may give a timestamp to track the\n\t *            evolution of the graph over the time.\n\t */\n\tvoid stepBegins(double time);\n\n\t// Source\n\t// XXX do we put the iterable attributeSinks and elementSinks in Source ?\n\n\t/**\n\t * Returns an \"iterable\" of {@link AttributeSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the set of {@link AttributeSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<AttributeSink> attributeSinks();\n\n\t/**\n\t * Returns an \"iterable\" of {@link ElementSink} objects registered to this\n\t * graph.\n\t * \n\t * @return the list of {@link ElementSink} under the form of an iterable\n\t *         object.\n\t */\n\tIterable<ElementSink> elementSinks();\n\n\t// Utility shortcuts (should be mixins or traits, what are you doing Mr Java\n\t// ?)\n\t// XXX use a Readable/Writable/Displayable interface for this ?\n\n\t/**\n\t * Utility method to read a graph. This method tries to identify the graph\n\t * format by itself and instantiates the corresponding reader automatically.\n\t * If this process fails, a NotFoundException is raised.\n\t * \n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognized.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input output error occurs during the graph reading.\n\t */\n\tvoid read(String filename) throws IOException, GraphParseException,\n\t\t\tElementNotFoundException;\n\n\t/**\n\t * Utility method to read a graph using the given reader.\n\t * \n\t * @param input\n\t *            An appropriate reader for the filename.\n\t * @param filename\n\t *            The graph filename (or URL).\n\t * @throws ElementNotFoundException\n\t *             If the file cannot be found or if the format is not\n\t *             recognised.\n\t * @throws GraphParseException\n\t *             If there is a parsing error while reading the file.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph reading.\n\t */\n\tvoid read(FileSource input, String filename) throws IOException,\n\t\t\tGraphParseException;\n\n\t/**\n\t * Utility method to write a graph in DGS format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(String filename) throws IOException;\n\n\t/**\n\t * Utility method to write a graph in the chosen format to a file.\n\t * \n\t * @param filename\n\t *            The file that will contain the saved graph (or URL).\n\t * @param output\n\t *            The output format to use.\n\t * @throws IOException\n\t *             If an input/output error occurs during the graph writing.\n\t */\n\tvoid write(FileSink output, String filename) throws IOException;\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but may be limited. This method\n\t * automatically launch a graph layout algorithm in its own thread to\n\t * compute best node positions.\n\t * \n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display(boolean )\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display();\n\n\t/**\n\t * Utility method that creates a new graph viewer, and register the graph in\n\t * it. Notice that this method is a quick way to see a graph, and only this.\n\t * It can be used to prototype a program, but is very limited.\n\t * \n\t * @param autoLayout\n\t *            If true a layout algorithm is launched in its own thread to\n\t *            compute best node positions.\n\t * @see org.graphstream.ui.view.Viewer\n\t * @see #display()\n\t * @return a graph viewer that allows to command the viewer (it often run in\n\t *         another thread).\n\t */\n\tViewer display(boolean autoLayout);\n\n\t// New methods\n\n\t/**\n\t * Get a node by its index. This method is implicitly generic and returns\n\t * something which extends Node. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode node = graph.getNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode node. If no left part exists,\n\t * method will just return a Node.\n\t * \n\t * @param index\n\t *            Index of the node to find.\n\t * @return The node with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             If the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T getNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Get an edge by its index. This method is implicitly generic and returns\n\t * something which extends Edge. The return type is the one of the left part\n\t * of the assignment. For example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.getEdge(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * \n\t * @param index\n\t *            The index of the edge to find.\n\t * @return The edge with the given index\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is less than 0 or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param index1\n\t *            The first node index\n\t * @param index2\n\t *            The second node index\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int index1, int index2)\n\t\t\tthrows IndexOutOfBoundsException, IdAlreadyInUseException,\n\t\t\tEdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the nodes are\n\t * identified by their indices.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param toIndex\n\t *            The first node index\n\t * @param fromIndex\n\t *            The second node index\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IndexOutOfBoundsException\n\t *             If node indices are negative or greater than {@code\n\t *             getNodeCount() - 1}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, int fromIndex, int toIndex,\n\t\t\tboolean directed) throws IndexOutOfBoundsException,\n\t\t\tIdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String)} but the node references are\n\t * given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param node1\n\t *            The first node\n\t * @param node2\n\t *            The second node\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node node1, Node node2)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Like {@link #addEdge(String, String, String, boolean)} but the node\n\t * references are given instead of node identifiers.\n\t * \n\t * @param id\n\t *            Unique and arbitrary string identifying the edge.\n\t * @param from\n\t *            The first node\n\t * @param to\n\t *            The second node\n\t * @param directed\n\t *            Is the edge directed?\n\t * @return The newly created edge, an existing edge or {@code null}\n\t * @throws IdAlreadyInUseException\n\t *             If an edge with the same id already exists and strict\n\t *             checking is enabled.\n\t * @throws EdgeRejectedException\n\t *             If strict checking is enabled and the edge is not accepted.\n\t * @see #addEdge(String, String, String)\n\t */\n\t<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed)\n\t\t\tthrows IdAlreadyInUseException, EdgeRejectedException;\n\n\t/**\n\t * Removes an edge with a given index. An event is sent toward the\n\t * listeners.\n\t * \n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge edge = graph.removeEdge(i);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge edge. If no left part exists,\n\t * method will just return an Edge.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the edge to be removed.\n\t * @return The removed edge\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getEdgeCount() - 1}\n\t */\n\t<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but the nodes are identified by their\n\t * indices.\n\t * \n\t * @param fromIndex\n\t *            the index of the source node\n\t * @param toIndex\n\t *            the index of the target node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws IndexOutOfBoundsException\n\t *             If one of the node indices is negative or greater than\n\t *             {@code getNodeCount() - 1}.\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(int fromIndex, int toIndex)\n\t\t\tthrows IndexOutOfBoundsException, ElementNotFoundException;\n\n\t/**\n\t * Removes an edge between two nodes. Like\n\t * {@link #removeEdge(String, String)} but node references are given instead\n\t * of node identifiers.\n\t * \n\t * @param node1\n\t *            the first node\n\t * @param node2\n\t *            the second node\n\t * @return the removed edge or {@code null} if no edge is removed\n\t * @throws ElementNotFoundException\n\t *             if strict checking is enabled and there is no edge between\n\t *             the two nodes.\n\t * @see #removeEdge(String, String)\n\t */\n\t<T extends Edge> T removeEdge(Node node1, Node node2)\n\t\t\tthrows ElementNotFoundException;\n\n\t/**\n\t * Removes an edge. An event is sent toward the listeners.\n\t * <p>\n\t * This method is implicitly generic and returns something which extends\n\t * Edge. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedEdge e = graph.removeEdge(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedEdge. If no left part exists, method\n\t * will just return an Edge.\n\t * </p>\n\t * \n\t * \n\t * \n\t * @param edge\n\t *            The edge to be removed\n\t * @return The removed edge\n\t */\n\t<T extends Edge> T removeEdge(Edge edge);\n\n\t/**\n\t * Removes a node with a given index.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(index);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param index\n\t *            The index of the node to be removed\n\t * @return The removed node\n\t * @throws IndexOutOfBoundsException\n\t *             if the index is negative or greater than {@code\n\t *             getNodeCount() - 1}.\n\t */\n\t<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException;\n\n\t/**\n\t * Removes a node.\n\t * <p>\n\t * An event is generated toward the listeners. Note that removing a node may\n\t * remove all edges it is connected to. In this case corresponding events\n\t * will also be generated toward the listeners.\n\t * </p>\n\t * <p>\n\t * This method is implicitly generic and return something which extends\n\t * Node. The return type is the one of the left part of the assignment. For\n\t * example, in the following call :\n\t * \n\t * <pre>\n\t * ExtendedNode n = graph.removeNode(...);\n\t * </pre>\n\t * \n\t * the method will return an ExtendedNode. If no left part exists, method\n\t * will just return a Node.\n\t * </p>\n\t * \n\t * @param node\n\t *            The node to be removed\n\t * @return The removed node\n\t */\n\t<T extends Node> T removeNode(Node node);\n}",
  "tokensGeneralGrammar" : [ "null", "true", "false", ",", ".", ":", ";", "?", "(", ")", "jdVar", "stream", "Arrays", "allMatch", "noneMatch", "anyMatch", "~", ">>", "<<", ">>>", "|", "&", "^", "+", "-", "/", "*", "%", "&&", "||", ">=", "<=", ">", "<", "==", "!=", "instanceof", "class", "methodResultID", "this" ],
  "tokensGeneralValuesGlobalDictionary" : [ [ "0", "int" ], [ "1", "int" ], [ "-1", "int" ], [ "0.0", "double" ], [ "1.0", "double" ], [ "-1.0", "double" ], [ "\"\"", "String" ], [ "\" \"", "String" ] ],
  "tokensProjectClasses" : [ [ "DefaultCamera", "org.graphstream.ui.swingViewer.util" ], [ "GradientFactory", "org.graphstream.ui.swingViewer.util" ], [ "GraphMetrics", "org.graphstream.ui.swingViewer.util" ], [ "Graphics2DOutput", "org.graphstream.ui.swingViewer.util" ], [ "ImageCache", "org.graphstream.ui.swingViewer.util" ], [ "StrokeFactory", "org.graphstream.ui.swingViewer.util" ], [ "FontCache", "org.graphstream.ui.swingViewer.util" ], [ "FontSlot", "org.graphstream.ui.swingViewer.util" ], [ "DefaultView", "org.graphstream.ui.swingViewer" ], [ "SpriteRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "ElementRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "NodeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "Arrow", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "Shape", "org.graphstream.ui.swingViewer.basicRenderer.shapes" ], [ "EdgeRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "SwingBasicGraphRenderer", "org.graphstream.ui.swingViewer.basicRenderer" ], [ "GraphRendererBase", "org.graphstream.ui.swingViewer" ], [ "GraphRenderer", "org.graphstream.ui.swingViewer" ], [ "LayerRenderer", "org.graphstream.ui.swingViewer" ], [ "ViewPanel", "org.graphstream.ui.swingViewer" ], [ "Layouts", "org.graphstream.ui.layout" ], [ "Layout", "org.graphstream.ui.layout" ], [ "LayoutRunner", "org.graphstream.ui.layout" ], [ "NodeParticle", "org.graphstream.ui.layout.springbox" ], [ "GraphCellData", "org.graphstream.ui.layout.springbox" ], [ "EdgeSpring", "org.graphstream.ui.layout.springbox" ], [ "Energies", "org.graphstream.ui.layout.springbox" ], [ "BarnesHutLayout", "org.graphstream.ui.layout.springbox" ], [ "LinLog", "org.graphstream.ui.layout.springbox.implementations" ], [ "LinLogNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBoxNodeParticle", "org.graphstream.ui.layout.springbox.implementations" ], [ "SpringBox", "org.graphstream.ui.layout.springbox.implementations" ], [ "Point2", "org.graphstream.ui.geom" ], [ "Vector2", "org.graphstream.ui.geom" ], [ "Vector3", "org.graphstream.ui.geom" ], [ "Point3", "org.graphstream.ui.geom" ], [ "ViewerListener", "org.graphstream.ui.view" ], [ "MouseManager", "org.graphstream.ui.view.util" ], [ "ShortcutManager", "org.graphstream.ui.view.util" ], [ "DefaultShortcutManager", "org.graphstream.ui.view.util" ], [ "FpsCounter", "org.graphstream.ui.view.util" ], [ "CubicCurve", "org.graphstream.ui.view.util" ], [ "DefaultMouseManager", "org.graphstream.ui.view.util" ], [ "Selection", "org.graphstream.ui.view" ], [ "ViewerPipe", "org.graphstream.ui.view" ], [ "Viewer", "org.graphstream.ui.view" ], [ "View", "org.graphstream.ui.view" ], [ "Camera", "org.graphstream.ui.view" ], [ "Sprite", "org.graphstream.ui.spriteManager" ], [ "InvalidSpriteIDException", "org.graphstream.ui.spriteManager" ], [ "SpriteManager", "org.graphstream.ui.spriteManager" ], [ "SpriteFactory", "org.graphstream.ui.spriteManager" ], [ "StyleGroupListener", "org.graphstream.ui.graphicGraph" ], [ "Colors", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Values", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetListener", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheetParserTokenManager", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParserConstants", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "StyleSheetParser", "org.graphstream.ui.graphicGraph.stylesheet.parser" ], [ "Style", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleSheet", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "StyleConstants", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Selector", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Value", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "Rule", "org.graphstream.ui.graphicGraph.stylesheet" ], [ "GraphicNode", "org.graphstream.ui.graphicGraph" ], [ "StyleGroup", "org.graphstream.ui.graphicGraph" ], [ "GraphPosLengthUtils", "org.graphstream.ui.graphicGraph" ], [ "GraphicEdge", "org.graphstream.ui.graphicGraph" ], [ "GraphicElementChangeListener", "org.graphstream.ui.graphicGraph" ], [ "GraphicGraph", "org.graphstream.ui.graphicGraph" ], [ "StyleGroupSet", "org.graphstream.ui.graphicGraph" ], [ "GraphicSprite", "org.graphstream.ui.graphicGraph" ], [ "GraphicElement", "org.graphstream.ui.graphicGraph" ], [ "VerboseSink", "org.graphstream.util" ], [ "GraphListeners", "org.graphstream.util" ], [ "Environment", "org.graphstream.util" ], [ "GraphDiff", "org.graphstream.util" ], [ "Filters", "org.graphstream.util" ], [ "FilteredEdgeIterator", "org.graphstream.util" ], [ "Parser", "org.graphstream.util.parser" ], [ "ParserFactory", "org.graphstream.util.parser" ], [ "TokenMgrError", "org.graphstream.util.parser" ], [ "ParseException", "org.graphstream.util.parser" ], [ "SimpleCharStream", "org.graphstream.util.parser" ], [ "Token", "org.graphstream.util.parser" ], [ "ISODateIO", "org.graphstream.util.time" ], [ "ISODateComponent", "org.graphstream.util.time" ], [ "FilteredNodeIterator", "org.graphstream.util" ], [ "FixedArrayList", "org.graphstream.util.set" ], [ "StepCounter", "org.graphstream.util" ], [ "GraphSpells", "org.graphstream.util.cumulative" ], [ "CumulativeAttributes", "org.graphstream.util.cumulative" ], [ "CumulativeSpells", "org.graphstream.util.cumulative" ], [ "Filter", "org.graphstream.util" ], [ "PipeAdapter", "org.graphstream.stream" ], [ "GraphParseException", "org.graphstream.stream" ], [ "ElementSink", "org.graphstream.stream" ], [ "URLSource", "org.graphstream.stream.net" ], [ "HTTPSource", "org.graphstream.stream.net" ], [ "SourceAdapter", "org.graphstream.stream" ], [ "AttributeSink", "org.graphstream.stream" ], [ "GMLParserConstants", "org.graphstream.stream.file.gml" ], [ "GMLParserTokenManager", "org.graphstream.stream.file.gml" ], [ "GMLContext", "org.graphstream.stream.file.gml" ], [ "Graphics", "org.graphstream.stream.file.gml" ], [ "KeyValues", "org.graphstream.stream.file.gml" ], [ "GMLParser", "org.graphstream.stream.file.gml" ], [ "FileSinkGraphML", "org.graphstream.stream.file" ], [ "TLPParserConstants", "org.graphstream.stream.file.tlp" ], [ "TLPParser", "org.graphstream.stream.file.tlp" ], [ "TLPParserTokenManager", "org.graphstream.stream.file.tlp" ], [ "FileSinkFactory", "org.graphstream.stream.file" ], [ "FileSourceEdge", "org.graphstream.stream.file" ], [ "FileSinkBase", "org.graphstream.stream.file" ], [ "FileSinkTikZ", "org.graphstream.stream.file" ], [ "FileSourceGEXF", "org.graphstream.stream.file" ], [ "DOTParser", "org.graphstream.stream.file.dot" ], [ "DOTParserConstants", "org.graphstream.stream.file.dot" ], [ "DOTParserTokenManager", "org.graphstream.stream.file.dot" ], [ "FileSink", "org.graphstream.stream.file" ], [ "PajekContext", "org.graphstream.stream.file.pajek" ], [ "Graphics", "org.graphstream.stream.file.pajek" ], [ "NodeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeGraphics", "org.graphstream.stream.file.pajek" ], [ "EdgeMatrix", "org.graphstream.stream.file.pajek" ], [ "PajekParserTokenManager", "org.graphstream.stream.file.pajek" ], [ "PajekParserConstants", "org.graphstream.stream.file.pajek" ], [ "FileSourceXML", "org.graphstream.stream.file" ], [ "FileSinkBaseFiltered", "org.graphstream.stream.file" ], [ "FileSinkDOT", "org.graphstream.stream.file" ], [ "FileSourceParser", "org.graphstream.stream.file" ], [ "FileSinkDGSFiltered", "org.graphstream.stream.file" ], [ "FileSourceDOT", "org.graphstream.stream.file" ], [ "FileSourceDGS1And2", "org.graphstream.stream.file" ], [ "FileSourceGraphML", "org.graphstream.stream.file" ], [ "FileSourceFactory", "org.graphstream.stream.file" ], [ "FileSinkImages", "org.graphstream.stream.file" ], [ "FileSinkDynamicGML", "org.graphstream.stream.file" ], [ "FileSinkSVG", "org.graphstream.stream.file" ], [ "GEXFSpell", "org.graphstream.stream.file.gexf" ], [ "SmartXMLWriter", "org.graphstream.stream.file.gexf" ], [ "GEXFElement", "org.graphstream.stream.file.gexf" ], [ "GEXFEdges", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValues", "org.graphstream.stream.file.gexf" ], [ "GEXFEdge", "org.graphstream.stream.file.gexf" ], [ "GEXFSpells", "org.graphstream.stream.file.gexf" ], [ "GEXFAttValue", "org.graphstream.stream.file.gexf" ], [ "GEXFNodes", "org.graphstream.stream.file.gexf" ], [ "GEXFNode", "org.graphstream.stream.file.gexf" ], [ "GEXFMeta", "org.graphstream.stream.file.gexf" ], [ "GEXFAttributes", "org.graphstream.stream.file.gexf" ], [ "GEXF", "org.graphstream.stream.file.gexf" ], [ "GEXFGraph", "org.graphstream.stream.file.gexf" ], [ "GEXFAttribute", "org.graphstream.stream.file.gexf" ], [ "OldFileSourceDGS", "org.graphstream.stream.file.dgs" ], [ "DGSParser", "org.graphstream.stream.file.dgs" ], [ "FileSourceBase", "org.graphstream.stream.file" ], [ "FileSinkGML", "org.graphstream.stream.file" ], [ "FileSourceDGS", "org.graphstream.stream.file" ], [ "FileSinkDGSUtility", "org.graphstream.stream.file" ], [ "FileSourceTLP", "org.graphstream.stream.file" ], [ "FileSinkSVG2", "org.graphstream.stream.file" ], [ "FileSource", "org.graphstream.stream.file" ], [ "FileSourceNCol", "org.graphstream.stream.file" ], [ "FileSourcePajek", "org.graphstream.stream.file" ], [ "FileSourceGPX", "org.graphstream.stream.file" ], [ "FileSourceLGL", "org.graphstream.stream.file" ], [ "FileSinkGEXF2", "org.graphstream.stream.file" ], [ "FileSourceGML", "org.graphstream.stream.file" ], [ "FileSinkGEXF", "org.graphstream.stream.file" ], [ "FileSinkDGS", "org.graphstream.stream.file" ], [ "ProxyPipe", "org.graphstream.stream" ], [ "Sink", "org.graphstream.stream" ], [ "Timeline", "org.graphstream.stream" ], [ "Pipe", "org.graphstream.stream" ], [ "SinkAdapter", "org.graphstream.stream" ], [ "Replayable", "org.graphstream.stream" ], [ "Source", "org.graphstream.stream" ], [ "AnnotatedSink", "org.graphstream.stream" ], [ "GraphReplay", "org.graphstream.stream" ], [ "AttributePipe", "org.graphstream.stream" ], [ "SinkTime", "org.graphstream.stream.sync" ], [ "SourceTime", "org.graphstream.stream.sync" ], [ "PipeBase", "org.graphstream.stream" ], [ "ThreadProxyPipe", "org.graphstream.stream.thread" ], [ "ThreadProxyPipeOld", "org.graphstream.stream.thread" ], [ "RMISource", "org.graphstream.stream.rmi" ], [ "RMIAdapterOut", "org.graphstream.stream.rmi" ], [ "RMISink", "org.graphstream.stream.rmi" ], [ "RMIAdapterIn", "org.graphstream.stream.rmi" ], [ "SourceBase", "org.graphstream.stream" ], [ "NetStreamDecoder", "org.graphstream.stream.netstream" ], [ "NetStreamReceiver", "org.graphstream.stream.netstream" ], [ "NetStreamConstants", "org.graphstream.stream.netstream" ], [ "NetStreamSender", "org.graphstream.stream.netstream" ], [ "DefaultNetStreamDecoder", "org.graphstream.stream.netstream" ], [ "Base64", "org.graphstream.stream.netstream.packing" ], [ "NetStreamUnpacker", "org.graphstream.stream.netstream.packing" ], [ "Base64Packer", "org.graphstream.stream.netstream.packing" ], [ "Base64Unpacker", "org.graphstream.stream.netstream.packing" ], [ "NetStreamPacker", "org.graphstream.stream.netstream.packing" ], [ "AttributePredicate", "org.graphstream.stream" ], [ "Element", "org.graphstream.graph" ], [ "Node", "org.graphstream.graph" ], [ "BreadthFirstIterator", "org.graphstream.graph" ], [ "Graph", "org.graphstream.graph" ], [ "EdgeRejectedException", "org.graphstream.graph" ], [ "CompoundAttribute", "org.graphstream.graph" ], [ "Structure", "org.graphstream.graph" ], [ "DepthFirstIterator", "org.graphstream.graph" ], [ "NullAttributeException", "org.graphstream.graph" ], [ "IdAlreadyInUseException", "org.graphstream.graph" ], [ "EdgeFactory", "org.graphstream.graph" ], [ "ElementNotFoundException", "org.graphstream.graph" ], [ "OneAttributeElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListNode", "org.graphstream.graph.implementations" ], [ "SingleNode", "org.graphstream.graph.implementations" ], [ "AbstractElement", "org.graphstream.graph.implementations" ], [ "AdjacencyListGraph", "org.graphstream.graph.implementations" ], [ "AbstractNode", "org.graphstream.graph.implementations" ], [ "DefaultGraph", "org.graphstream.graph.implementations" ], [ "MultiGraph", "org.graphstream.graph.implementations" ], [ "Graphs", "org.graphstream.graph.implementations" ], [ "SingleGraph", "org.graphstream.graph.implementations" ], [ "MultiNode", "org.graphstream.graph.implementations" ], [ "AbstractGraph", "org.graphstream.graph.implementations" ], [ "AbstractEdge", "org.graphstream.graph.implementations" ], [ "GraphFactory", "org.graphstream.graph" ], [ "NodeFactory", "org.graphstream.graph" ], [ "Edge", "org.graphstream.graph" ], [ "Path", "org.graphstream.graph" ] ],
  "tokensProjectClassesNonPrivateStaticNonVoidMethods" : [ [ "gradientInArea", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint gradientInArea(int x0, int y0, int width, int height, Style style)" ], [ "linearGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint linearGradientFromStyle(float x0, float y0, float x1, float y1, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, Style style)" ], [ "radialGradientFromStyle", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static Paint radialGradientFromStyle(float cx, float cy, float radius, float fx, float fy, Style style)" ], [ "createFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static float[] createFractions(Style style)" ], [ "createColors", "org.graphstream.ui.swingViewer.util", "GradientFactory", "protected static Color[] createColors(Style style)" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "public static ImageCache defaultImageCache()" ], [ "generateStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "public static Stroke generateStroke(Style style, GraphMetrics metrics)" ], [ "generatePlainStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generatePlainStroke(Style style, GraphMetrics metrics)" ], [ "generateDotsStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDotsStroke(Style style, GraphMetrics metrics)" ], [ "generateDashesStroke", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static Stroke generateDashesStroke(Style style, GraphMetrics metrics)" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache()" ], [ "newLayoutAlgorithm", "org.graphstream.ui.layout", "Layouts", "public static Layout newLayoutAlgorithm()" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static double eval(double x0, double x1, double x2, double x3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double eval(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "eval", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 eval(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Point2 result)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static double derivative(double x0, double x1, double x2, double x3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t)" ], [ "derivative", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2 derivative(Point2 p0, Point2 p1, Point2 p2, Point3 p3, double t, Point2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Vector2 perpendicular(Point2 p0, Point2 p1, Point2 p2, Point2 p3, double t, Vector2 result)" ], [ "perpendicular", "org.graphstream.ui.view.util", "CubicCurve", "public static Point2D.Double perpendicular(Point2D.Double p0, Point2D.Double p1, Point2D.Double p2, Point2D.Double p3, double t)" ], [ "newGraphRenderer", "org.graphstream.ui.view", "Viewer", "public static GraphRenderer newGraphRenderer()" ], [ "getPositionValue", "org.graphstream.ui.spriteManager", "SpriteManager", "protected static Values getPositionValue(Object value)" ], [ "convertColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Color convertColor(Object anyValue)" ], [ "convertLabel", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static String convertLabel(Object value)" ], [ "convertWidth", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static float convertWidth(Object value)" ], [ "convertValue", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "public static Value convertValue(Object value)" ], [ "convertUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Units convertUnit(String unit)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Graph graph, String id)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Graph graph, String id)" ], [ "nodePosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double[] nodePosition(Node node)" ], [ "nodePointPosition", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static Point3 nodePointPosition(Node node)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Graph graph, String id)" ], [ "edgeLength", "org.graphstream.ui.graphicGraph", "GraphPosLengthUtils", "public static double edgeLength(Edge edge)" ], [ "getGlobalEnvironment", "org.graphstream.util", "Environment", "public static Environment getGlobalEnvironment()" ], [ "falseFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> falseFilter()" ], [ "trueFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> trueFilter()" ], [ "byAttributeFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byAttributeFilter(String key, Object expectedValue)" ], [ "separateNodeAndEdgeFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<Element> separateNodeAndEdgeFilter(Filter<T> nodeFilter, Filter<U> edgeFilter)" ], [ "byExtremitiesFilter", "org.graphstream.util", "Filters", "public static <T extends Element, U extends Element> Filter<T> byExtremitiesFilter(Filter<U> f)" ], [ "byIdFilter", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> byIdFilter(String idPattern)" ], [ "isContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isContained(final Collection<? extends T> set)" ], [ "isIdContained", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> isIdContained(final Collection<String> set)" ], [ "and", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> and(Filter<T> f1, Filter<T> f2)" ], [ "or", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> or(Filter<T> f1, Filter<T> f2)" ], [ "xor", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> xor(Filter<T> f1, Filter<T> f2)" ], [ "not", "org.graphstream.util", "Filters", "public static <T extends Element> Filter<T> not(Filter<T> f)" ], [ "addEscapes", "org.graphstream.util.parser", "TokenMgrError", "protected static final String addEscapes(String str)" ], [ "LexicalError", "org.graphstream.util.parser", "TokenMgrError", "protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar)" ], [ "add_escapes", "org.graphstream.util.parser", "ParseException", "static String add_escapes(String str)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind, String image)" ], [ "newToken", "org.graphstream.util.parser", "Token", "public static Token newToken(int ofKind)" ], [ "countStepInFile", "org.graphstream.util", "StepCounter", "public static int countStepInFile(String path) throws IOException" ], [ "GET", "org.graphstream.stream.net", "HTTPSource", "protected static HashMap<String, Object> GET(HttpExchange ex)" ], [ "sinkFor", "org.graphstream.stream.file", "FileSinkFactory", "public static FileSink sinkFor(String filename)" ], [ "formatId", "org.graphstream.stream.file", "FileSinkTikZ", "protected static String formatId(String id)" ], [ "getInt", "org.graphstream.stream.file.pajek", "PajekContext", "protected static int getInt(Token nb) throws ParseException" ], [ "getReal", "org.graphstream.stream.file.pajek", "PajekContext", "protected static double getReal(Token nb) throws ParseException" ], [ "toColorValue", "org.graphstream.stream.file.pajek", "PajekContext", "public static String toColorValue(Token R, Token G, Token B) throws ParseException" ], [ "sourceFor", "org.graphstream.stream.file", "FileSourceFactory", "public static FileSource sourceFor(String fileName) throws IOException" ], [ "getXMLRootElement", "org.graphstream.stream.file", "FileSourceFactory", "public static String getXMLRootElement(String fileName) throws IOException" ], [ "formatStringForQuoting", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String formatStringForQuoting(String str)" ], [ "attributeString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String attributeString(String key, Object value, boolean remove)" ], [ "arrayString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String arrayString(Object value)" ], [ "valueString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String valueString(Object value)" ], [ "hashToString", "org.graphstream.stream.file", "FileSinkDGSUtility", "protected static String hashToString(HashMap<?, ?> hash)" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException" ], [ "encodeObject", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int options) throws java.io.IOException" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len)" ], [ "encodeBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source)" ], [ "encodeBytesToBytes", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s) throws java.io.IOException" ], [ "decode", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decode(String s, int options) throws java.io.IOException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeToObject", "org.graphstream.stream.netstream.packing", "Base64", "public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader) throws java.io.IOException, java.lang.ClassNotFoundException" ], [ "decodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static byte[] decodeFromFile(String filename) throws java.io.IOException" ], [ "encodeFromFile", "org.graphstream.stream.netstream.packing", "Base64", "public static String encodeFromFile(String filename) throws java.io.IOException" ], [ "unmutableGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph unmutableGraph(Graph g)" ], [ "synchronizedGraph", "org.graphstream.graph.implementations", "Graphs", "public static Graph synchronizedGraph(Graph g)" ], [ "merge", "org.graphstream.graph.implementations", "Graphs", "public static Graph merge(Graph... graphs)" ], [ "clone", "org.graphstream.graph.implementations", "Graphs", "public static Graph clone(Graph g)" ] ],
  "tokensProjectClassesNonPrivateStaticAttributes" : [ [ "version16", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static boolean version16 = false;" ], [ "predefFractions", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[][] predefFractions = new float[11][];" ], [ "predefFractions2", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions2 = { 0f, 1f };" ], [ "predefFractions3", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions3 = { 0f, 0.5f, 1f };" ], [ "predefFractions4", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions4 = { 0f, 0.33f, 0.66f, 1f };" ], [ "predefFractions5", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions5 = { 0f, 0.25f, 0.5f, 0.75f, 1f };" ], [ "predefFractions6", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions6 = { 0f, 0.2f, 0.4f, 0.6f, 0.8f, 1f };" ], [ "predefFractions7", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions7 = { 0f, 0.1666f, 0.3333f, 0.4999f, 0.6666f, 0.8333f, 1f };" ], [ "predefFractions8", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions8 = { 0f, 0.1428f, 0.2856f, 0.4284f, 0.5712f, 0.7140f, 0.8568f, 1f };" ], [ "predefFractions9", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions9 = { 0f, 0.125f, 0.25f, 0.375f, 0.5f, 0.625f, .75f, 0.875f, 1f };" ], [ "predefFractions10", "org.graphstream.ui.swingViewer.util", "GradientFactory", "public static float[] predefFractions10 = { 0f, 0.1111f, 0.2222f, 0.3333f, 0.4444f, 0.5555f, 0.6666f, 0.7777f, 0.8888f, 1f };" ], [ "defaultImageCache", "org.graphstream.ui.swingViewer.util", "ImageCache", "protected static ImageCache defaultImageCache;" ], [ "dots", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dots = { 1f, 1f };" ], [ "dashes", "org.graphstream.ui.swingViewer.util", "StrokeFactory", "protected static float[] dashes = { 3f, 3f };" ], [ "defaultFontCache", "org.graphstream.ui.swingViewer.util", "FontCache", "public static FontCache defaultFontCache;" ], [ "NULL_POINT2", "org.graphstream.ui.geom", "Point2", "public static final Point2 NULL_POINT2 = new Point2(0, 0);" ], [ "NULL_POINT3", "org.graphstream.ui.geom", "Point3", "public static final Point3 NULL_POINT3 = new Point3(0, 0, 0);" ], [ "DEFAULT_VIEW_ID", "org.graphstream.ui.view", "Viewer", "public static String DEFAULT_VIEW_ID = \"defaultView\";" ], [ "jjbitVec0", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final int[] jjnextStates = { 48, 49, 52, 54, 55, 65, 69, 2, 4, 6, 10, 16, 23, 33, 50, 52, 54, 55, 57, 58, 60, 61, 66, 68, 70, 71 };" ], [ "jjstrLiteralImages", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, \"\\56\", \"\\173\", \"\\175\", \"\\50\", \"\\51\", \"\\43\", \"\\72\", \"\\73\", \"\\54\", \"\\162\\147\\142\\141\", \"\\162\\147\\142\", null, null, null, \"\\165\\162\\154\", \"\\147\\162\\141\\160\\150\", \"\\145\\144\\147\\145\", \"\\156\\157\\144\\145\", \"\\163\\160\\162\\151\\164\\145\", \"\\146\\151\\154\\154\\55\\155\\157\\144\\145\", \"\\146\\151\\154\\154\\55\\143\\157\\154\\157\\162\", \"\\146\\151\\154\\154\\55\\151\\155\\141\\147\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\155\\157\\144\\145\", \"\\163\\164\\162\\157\\153\\145\\55\\143\\157\\154\\157\\162\", \"\\163\\164\\162\\157\\153\\145\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\144\\157\\167\\55\\143\\157\\154\\157\\162\", \"\\163\\150\\141\\144\\157\\167\\55\\167\\151\\144\\164\\150\", \"\\163\\150\\141\\144\\157\\167\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\163\\164\\171\\154\\145\", \"\\164\\145\\170\\164\\55\\146\\157\\156\\164\", \"\\164\\145\\170\\164\\55\\163\\151\\172\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\155\\157\\144\\145\", \"\\164\\145\\170\\164\\55\\142\\141\\143\\153\\147\\162\\157\\165\\156\\144\\55\\143\\157\\154\\157\\162\", \"\\164\\145\\170\\164\\55\\157\\146\\146\\163\\145\\164\", \"\\164\\145\\170\\164\\55\\160\\141\\144\\144\\151\\156\\147\", \"\\151\\143\\157\\156\\55\\155\\157\\144\\145\", \"\\151\\143\\157\\156\", \"\\160\\141\\144\\144\\151\\156\\147\", \"\\172\\55\\151\\156\\144\\145\\170\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\\55\\155\\157\\144\\145\", \"\\166\\151\\163\\151\\142\\151\\154\\151\\164\\171\", \"\\163\\150\\141\\160\\145\", \"\\163\\151\\172\\145\", \"\\163\\151\\172\\145\\55\\155\\157\\144\\145\", \"\\163\\150\\141\\160\\145\\55\\160\\157\\151\\156\\164\\163\", \"\\164\\145\\170\\164\\55\\141\\154\\151\\147\\156\\155\\145\\156\\164\", \"\\152\\143\\157\\155\\160\\157\\156\\145\\156\\164\", \"\\141\\162\\162\\157\\167\\55\\151\\155\\141\\147\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\151\\172\\145\", \"\\141\\162\\162\\157\\167\\55\\163\\150\\141\\160\\145\", \"\\163\\160\\162\\151\\164\\145\\55\\157\\162\\151\\145\\156\\164\\141\\164\\151\\157\\156\", \"\\143\\141\\156\\166\\141\\163\\55\\143\\157\\154\\157\\162\", \"\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\160\\154\\141\\151\\156\", \"\\144\\171\\156\\55\\163\\151\\172\\145\", \"\\144\\171\\156\\55\\151\\143\\157\\156\", \"\\144\\141\\163\\150\\145\\163\", \"\\144\\157\\164\\163\", \"\\144\\157\\165\\142\\154\\145\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\61\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\144\\151\\141\\147\\157\\156\\141\\154\\62\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\162\\141\\144\\151\\141\\154\", \"\\147\\162\\141\\144\\151\\145\\156\\164\\55\\166\\145\\162\\164\\151\\143\\141\\154\", \"\\150\\151\\144\\144\\145\\156\", \"\\151\\155\\141\\147\\145\\55\\164\\151\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\141\\170\", \"\\151\\155\\141\\147\\145\\55\\163\\143\\141\\154\\145\\144\\55\\162\\141\\164\\151\\157\\55\\155\\151\\156\", \"\\156\\157\\156\\145\", \"\\156\\157\\162\\155\\141\\154\", \"\\164\\162\\165\\156\\143\\141\\164\\145\\144\", \"\\172\\157\\157\\155\\55\\162\\141\\156\\147\\145\", \"\\141\\164\\55\\172\\157\\157\\155\", \"\\165\\156\\144\\145\\162\\55\\172\\157\\157\\155\", \"\\157\\166\\145\\162\\55\\172\\157\\157\\155\", \"\\172\\157\\157\\155\\163\", \"\\146\\151\\164\", \"\\142\\157\\154\\144\", \"\\142\\157\\154\\144\\55\\151\\164\\141\\154\\151\\143\", \"\\151\\164\\141\\154\\151\\143\", \"\\141\\154\\157\\156\\147\", \"\\141\\164\\55\\154\\145\\146\\164\", \"\\141\\164\\55\\162\\151\\147\\150\\164\", \"\\143\\145\\156\\164\\145\\162\", \"\\154\\145\\146\\164\", \"\\162\\151\\147\\150\\164\", \"\\165\\156\\144\\145\\162\", \"\\141\\142\\157\\166\\145\", \"\\152\\165\\163\\164\\151\\146\\171\", \"\\143\\151\\162\\143\\154\\145\", \"\\164\\162\\151\\141\\156\\147\\154\\145\", \"\\146\\162\\145\\145\\160\\154\\141\\156\\145\", \"\\164\\145\\170\\164\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\164\\145\\170\\164\\55\\143\\151\\162\\143\\154\\145\", \"\\164\\145\\170\\164\\55\\144\\151\\141\\155\\157\\156\\144\", \"\\164\\145\\170\\164\\55\\160\\141\\162\\141\\147\\162\\141\\160\\150\", \"\\142\\157\\170\", \"\\162\\157\\165\\156\\144\\145\\144\\55\\142\\157\\170\", \"\\143\\162\\157\\163\\163\", \"\\144\\151\\141\\155\\157\\156\\144\", \"\\160\\157\\154\\171\\147\\157\\156\", \"\\142\\165\\164\\164\\157\\156\", \"\\164\\145\\170\\164\\55\\146\\151\\145\\154\\144\", \"\\160\\141\\156\\145\\154\", \"\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\", \"\\160\\157\\154\\171\\154\\151\\156\\145\\55\\163\\143\\141\\154\\145\\144\", \"\\141\\156\\147\\154\\145\", \"\\143\\165\\142\\151\\143\\55\\143\\165\\162\\166\\145\", \"\\142\\154\\157\\142\", \"\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\114\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\150\\157\\162\\151\\172\\157\\156\\164\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\166\\145\\162\\164\\151\\143\\141\\154\\55\\163\\161\\165\\141\\162\\145\\55\\154\\151\\156\\145\", \"\\141\\162\\162\\157\\167\", \"\\146\\154\\157\\167\", \"\\160\\151\\145\\55\\143\\150\\141\\162\\164\", \"\\151\\155\\141\\147\\145\", \"\\151\\155\\141\\147\\145\\163\", \"\\146\\162\\157\\155\", \"\\156\\157\\144\\145\\60\", \"\\164\\157\", \"\\156\\157\\144\\145\\61\", \"\\160\\162\\157\\152\\145\\143\\164\\151\\157\\156\", \"\\143\\154\\151\\143\\153\\145\\144\", \"\\163\\145\\154\\145\\143\\164\\145\\144\", null, null };" ], [ "lexStateNames", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoToken = { 0xfffffffffffffe01L, 0xffffffffffffffffL, 0xffffL };" ], [ "jjtoSkip", "org.graphstream.ui.graphicGraph.stylesheet.parser", "StyleSheetParserTokenManager", "static final long[] jjtoSkip = { 0x1eL, 0x0L, 0x0L };" ], [ "colorMap", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static HashMap<String,Color> colorMap;" ], [ "sharpColor1", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor1;" ], [ "sharpColor2", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern sharpColor2;" ], [ "cssColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColor;" ], [ "cssColorA", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern cssColorA;" ], [ "awtColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern awtColor;" ], [ "hexaColor", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern hexaColor;" ], [ "numberUnit", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern numberUnit;" ], [ "number", "org.graphstream.ui.graphicGraph.stylesheet", "StyleConstants", "protected static Pattern number;" ], [ "acceptedAttribute", "org.graphstream.ui.graphicGraph", "GraphicElement", "protected static Pattern acceptedAttribute;" ], [ "DEFAULT_AN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AN_FORMAT = \"%prefix%[%sourceId%:%timeId%] add node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_CNA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CNR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CNR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set node \\\"%nodeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DN_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DN_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove node \\\"%nodeId%\\\"%suffix%\";" ], [ "DEFAULT_AE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_AE_FORMAT = \"%prefix%[%sourceId%:%timeId%] add edge \\\"%edgeId%\\\" : \\\"%source%\\\" -- \\\"%target%\\\"%suffix%\";" ], [ "DEFAULT_CEA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CEC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CEC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CER_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CER_FORMAT = \"%prefix%[%sourceId%:%timeId%] set edge \\\"%edgeId%\\\" -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_DE_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_DE_FORMAT = \"%prefix%[%sourceId%:%timeId%] remove edge \\\"%edgeId%\\\"%suffix%\";" ], [ "DEFAULT_CGA_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGA_FORMAT = \"%prefix%[%sourceId%:%timeId%] set +\\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGC_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGC_FORMAT = \"%prefix%[%sourceId%:%timeId%] set \\\"%attributeId%\\\"=%value%%suffix%\";" ], [ "DEFAULT_CGR_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CGR_FORMAT = \"%prefix%[%sourceId%:%timeId%] set -\\\"%attributeId%\\\"%suffix%\";" ], [ "DEFAULT_CL_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_CL_FORMAT = \"%prefix%[%sourceId%:%timeId%] clear%suffix%\";" ], [ "DEFAULT_ST_FORMAT", "org.graphstream.util", "VerboseSink", "public static final String DEFAULT_ST_FORMAT = \"%prefix%[%sourceId%:%timeId%] step %step% begins%suffix%\";" ], [ "GLOBAL_ENV", "org.graphstream.util", "Environment", "public static Environment GLOBAL_ENV;" ], [ "LEXICAL_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int LEXICAL_ERROR = 0;" ], [ "STATIC_LEXER_ERROR", "org.graphstream.util.parser", "TokenMgrError", "public static final int STATIC_LEXER_ERROR = 1;" ], [ "INVALID_LEXICAL_STATE", "org.graphstream.util.parser", "TokenMgrError", "public static final int INVALID_LEXICAL_STATE = 2;" ], [ "LOOP_DETECTED", "org.graphstream.util.parser", "TokenMgrError", "public static final int LOOP_DETECTED = 3;" ], [ "staticFlag", "org.graphstream.util.parser", "SimpleCharStream", "public static final boolean staticFlag = false;" ], [ "ABBREVIATED_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_WEEKDAY_NAME = new NotImplementedComponent(\"%a\", \"\\\\w+[.]\");" ], [ "FULL_WEEKDAY_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_WEEKDAY_NAME = new NotImplementedComponent(\"%A\", \"\\\\w+\");" ], [ "ABBREVIATED_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME = new NotImplementedComponent(\"%b\", \"\\\\w+[.]\");" ], [ "FULL_MONTH_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent FULL_MONTH_NAME = new NotImplementedComponent(\"%B\", \"\\\\w+\");" ], [ "LOCALE_DATE_AND_TIME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_AND_TIME = new NotImplementedComponent(\"%c\", null);" ], [ "CENTURY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent CENTURY = new NotImplementedComponent(\"%C\", \"\\\\d\\\\d\");" ], [ "DAY_OF_MONTH_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH_2_DIGITS = new FieldComponent(\"%d\", \"[012]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%02d\");" ], [ "DATE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE = new AliasComponent(\"%D\", \"%m/%d/%y\");" ], [ "DAY_OF_MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_MONTH = new FieldComponent(\"%e\", \"\\\\d|[12]\\\\d|3[01]\", Calendar.DAY_OF_MONTH, \"%2d\");" ], [ "DATE_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DATE_ISO8601 = new AliasComponent(\"%F\", \"%Y-%m-%d\");" ], [ "WEEK_BASED_YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_2_DIGITS = new FieldComponent(\"%g\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "WEEK_BASED_YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_BASED_YEAR_4_DIGITS = new FieldComponent(\"%G\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "ABBREVIATED_MONTH_NAME_ALIAS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent ABBREVIATED_MONTH_NAME_ALIAS = new AliasComponent(\"%h\", \"%b\");" ], [ "HOUR_OF_DAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_OF_DAY = new FieldComponent(\"%H\", \"[01]\\\\d|2[0123]\", Calendar.HOUR_OF_DAY, \"%02d\");" ], [ "HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR = new FieldComponent(\"%I\", \"0\\\\d|1[012]\", Calendar.HOUR, \"%02d\");" ], [ "DAY_OF_YEAR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_YEAR = new FieldComponent(\"%j\", \"[012]\\\\d\\\\d|3[0-5]\\\\d|36[0-6]\", Calendar.DAY_OF_YEAR, \"%03d\");" ], [ "MILLISECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MILLISECOND = new FieldComponent(\"%k\", \"\\\\d{3}\", Calendar.MILLISECOND, \"%03d\");" ], [ "EPOCH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent EPOCH = new EpochComponent();" ], [ "MONTH", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MONTH = new FieldComponent(\"%m\", \"0[1-9]|1[012]\", Calendar.MONTH, -1, \"%02d\");" ], [ "MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent MINUTE = new FieldComponent(\"%M\", \"[0-5]\\\\d\", Calendar.MINUTE, \"%02d\");" ], [ "NEW_LINE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent NEW_LINE = new AliasComponent(\"%n\", \"\\n\");" ], [ "AM_PM", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent AM_PM = new AMPMComponent();" ], [ "LOCALE_CLOCK_TIME_12_HOUR", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_CLOCK_TIME_12_HOUR = new NotImplementedComponent(\"%r\", \"\");" ], [ "HOUR_AND_MINUTE", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent HOUR_AND_MINUTE = new AliasComponent(\"%R\", \"%H:%M\");" ], [ "SECOND", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent SECOND = new FieldComponent(\"%S\", \"[0-5]\\\\d|60\", Calendar.SECOND, \"%02d\");" ], [ "TABULATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TABULATION = new AliasComponent(\"%t\", \"\\t\");" ], [ "TIME_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent TIME_ISO8601 = new AliasComponent(\"%T\", \"%H:%M:%S\");" ], [ "DAY_OF_WEEK_1_7", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_1_7 = new FieldComponent(\"%u\", \"[1-7]\", Calendar.DAY_OF_WEEK, -1, \"%1d\");" ], [ "WEEK_OF_YEAR_FROM_SUNDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_SUNDAY = new FieldComponent(\"%U\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, 1, \"%2d\");" ], [ "WEEK_NUMBER_ISO8601", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_NUMBER_ISO8601 = new NotImplementedComponent(\"%V\", \"0[1-9]|[2-4]\\\\d|5[0123]\");" ], [ "DAY_OF_WEEK_0_6", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent DAY_OF_WEEK_0_6 = new FieldComponent(\"%w\", \"[0-6]\", Calendar.DAY_OF_WEEK, \"%01d\");" ], [ "WEEK_OF_YEAR_FROM_MONDAY", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent WEEK_OF_YEAR_FROM_MONDAY = new FieldComponent(\"%W\", \"[0-4]\\\\d|5[0123]\", Calendar.WEEK_OF_YEAR, \"%02d\");" ], [ "LOCALE_DATE_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_DATE_REPRESENTATION = new NotImplementedComponent(\"%x\", \"\");" ], [ "LOCALE_TIME_REPRESENTATION", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_REPRESENTATION = new NotImplementedComponent(\"%X\", \"\");" ], [ "YEAR_2_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_2_DIGITS = new FieldComponent(\"%y\", \"\\\\d\\\\d\", Calendar.YEAR, \"%02d\");" ], [ "YEAR_4_DIGITS", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent YEAR_4_DIGITS = new FieldComponent(\"%Y\", \"\\\\d{4}\", Calendar.YEAR, \"%04d\");" ], [ "UTC_OFFSET", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent UTC_OFFSET = new UTCOffsetComponent();" ], [ "LOCALE_TIME_ZONE_NAME", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent LOCALE_TIME_ZONE_NAME = new NotImplementedComponent(\"%Z\", \"\\\\w*\");" ], [ "PERCENT", "org.graphstream.util.time", "ISODateComponent", "public static final ISODateComponent PERCENT = new AliasComponent(\"%%\", \"%\");" ], [ "jjbitVec0", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final int[] jjnextStates = { 5, 6, 8, 9, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, \"\\133\", \"\\135\", null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoToken = { 0xff01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.gml", "GMLParserTokenManager", "static final long[] jjtoSkip = { 0x1eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final int[] jjnextStates = { 54, 11, 12, 15, 17, 18, 1, 2, 5, 47, 52, 8, 9, 20, 21 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\50\", \"\\51\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoToken = { 0xffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.tlp", "TLPParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "XYZ_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String XYZ_ATTR = \"xyz\";" ], [ "WIDTH_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String WIDTH_ATTR = \"ui.tikz.width\";" ], [ "HEIGHT_ATTR", "org.graphstream.stream.file", "FileSinkTikZ", "public static final String HEIGHT_ATTR = \"ui.tikz.height\";" ], [ "DEFAULT_WIDTH", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_WIDTH = 10;" ], [ "DEFAULT_HEIGHT", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DEFAULT_HEIGHT = 10;" ], [ "DISPLAY_MIN_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MIN_SIZE_IN_MM = 2;" ], [ "DISPLAY_MAX_SIZE_IN_MM", "org.graphstream.stream.file", "FileSinkTikZ", "public static final double DISPLAY_MAX_SIZE_IN_MM = 10;" ], [ "jjbitVec0", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final int[] jjnextStates = { 21, 27, 8, 10, 11, 18, 19, 22, 23, 26, 1, 2, 13, 14 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, \"\\133\", \"\\135\", \"\\173\", \"\\175\", \"\\72\", \"\\54\", \"\\75\", null, null, null, null, null, null, null, null, null, null, \"\\73\", null, null, null, null, null, null, null, null, null, \"\\137\" };" ], [ "lexStateNames", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoToken = { 0x3ffffffc01L };" ], [ "jjtoSkip", "org.graphstream.stream.file.dot", "DOTParserTokenManager", "static final long[] jjtoSkip = { 0x7eL };" ], [ "jjbitVec0", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjbitVec0 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };" ], [ "jjnextStates", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final int[] jjnextStates = { 21, 22, 23, 17, 19, 2, 3, 5, 6, 8, 9 };" ], [ "jjstrLiteralImages", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] jjstrLiteralImages = { \"\", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null };" ], [ "lexStateNames", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "public static final String[] lexStateNames = { \"DEFAULT\" };" ], [ "jjtoToken", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoToken = { 0x3fffffffffffc9L };" ], [ "jjtoSkip", "org.graphstream.stream.file.pajek", "PajekParserTokenManager", "static final long[] jjtoSkip = { 0x6L };" ], [ "XMLNS", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS = \"http://www.gexf.net/1.2draft\";" ], [ "XMLNS_XSI", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_XSI = \"http://www.w3.org/2001/XMLSchema-instance\";" ], [ "XMLNS_SL", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_SL = \"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\";" ], [ "XMLNS_VIZ", "org.graphstream.stream.file.gexf", "GEXF", "public static final String XMLNS_VIZ = \"http://www.gexf.net/1.2draft/viz\";" ], [ "VERSION", "org.graphstream.stream.file.gexf", "GEXF", "public static final String VERSION = \"1.2\";" ], [ "BUFFER_SIZE", "org.graphstream.stream.file.dgs", "DGSParser", "protected static final int BUFFER_SIZE = 4096;" ], [ "ARRAY_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_OPEN = '{';" ], [ "ARRAY_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int ARRAY_CLOSE = '}';" ], [ "MAP_OPEN", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_OPEN = '[';" ], [ "MAP_CLOSE", "org.graphstream.stream.file.dgs", "DGSParser", "public static final int MAP_CLOSE = ']';" ], [ "gradientId", "org.graphstream.stream.file", "FileSinkSVG2", "static int gradientId = 0;" ], [ "gradientId", "org.graphstream.stream.file", "SVGStyle", "static int gradientId = 0;" ], [ "TIME_PREFIX", "org.graphstream.stream", "Timeline", "public static final String TIME_PREFIX = \"time\";" ], [ "SYNC_DISABLE_KEY", "org.graphstream.stream.sync", "SinkTime", "public static final String SYNC_DISABLE_KEY = \"org.graphstream.stream.sync.disable\";" ], [ "disableSync", "org.graphstream.stream.sync", "SinkTime", "protected static final boolean disableSync;" ], [ "LIGHT_YELLOW", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String LIGHT_YELLOW = \"\u001B[33;1m\";" ], [ "RESET", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final String RESET = \"\u001B[0m\";" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "NetStreamReceiver", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "BUFFER_INITIAL_SIZE", "org.graphstream.stream.netstream", "IncomingBuffer", "protected static final int BUFFER_INITIAL_SIZE = 8192;" ], [ "EVENT_GETVERSION", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_GETVERSION = 0x00;" ], [ "EVENT_START", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_START = 0x01;" ], [ "EVENT_END", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_END = 0x02;" ], [ "EVENT_ADD_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE = 0x10;" ], [ "EVENT_DEL_NODE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE = 0x11;" ], [ "EVENT_ADD_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE = 0x12;" ], [ "EVENT_DEL_EDGE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE = 0x13;" ], [ "EVENT_STEP", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_STEP = 0x14;" ], [ "EVENT_CLEARED", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CLEARED = 0x15;" ], [ "EVENT_ADD_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_GRAPH_ATTR = 0x16;" ], [ "EVENT_CHG_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_GRAPH_ATTR = 0x17;" ], [ "EVENT_DEL_GRAPH_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_GRAPH_ATTR = 0x18;" ], [ "EVENT_ADD_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_NODE_ATTR = 0x19;" ], [ "EVENT_CHG_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_NODE_ATTR = 0x1a;" ], [ "EVENT_DEL_NODE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_NODE_ATTR = 0x1b;" ], [ "EVENT_ADD_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_ADD_EDGE_ATTR = 0x1c;" ], [ "EVENT_CHG_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_CHG_EDGE_ATTR = 0x1d;" ], [ "EVENT_DEL_EDGE_ATTR", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int EVENT_DEL_EDGE_ATTR = 0x1e;" ], [ "TYPE_UNKNOWN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_UNKNOWN = 0x00;" ], [ "TYPE_BOOLEAN", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN = 0x50;" ], [ "TYPE_BOOLEAN_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BOOLEAN_ARRAY = 0x51;" ], [ "TYPE_BYTE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE = 0x52;" ], [ "TYPE_BYTE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_BYTE_ARRAY = 0x53;" ], [ "TYPE_SHORT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT = 0x54;" ], [ "TYPE_SHORT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_SHORT_ARRAY = 0x55;" ], [ "TYPE_INT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT = 0x56;" ], [ "TYPE_INT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_INT_ARRAY = 0x57;" ], [ "TYPE_LONG", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG = 0x58;" ], [ "TYPE_LONG_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_LONG_ARRAY = 0x59;" ], [ "TYPE_FLOAT", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT = 0x5a;" ], [ "TYPE_FLOAT_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_FLOAT_ARRAY = 0x5b;" ], [ "TYPE_DOUBLE", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE = 0x5c;" ], [ "TYPE_DOUBLE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_DOUBLE_ARRAY = 0x5d;" ], [ "TYPE_STRING", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_STRING = 0x5e;" ], [ "TYPE_RAW", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_RAW = 0x5f;" ], [ "TYPE_ARRAY", "org.graphstream.stream.netstream", "NetStreamConstants", "public static byte TYPE_ARRAY = 0x60;" ], [ "TYPE_NULL", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int TYPE_NULL = 0x61;" ], [ "COMMAND", "org.graphstream.stream.netstream", "NetStreamConstants", "public static int COMMAND = 0x70;" ], [ "NO_OPTIONS", "org.graphstream.stream.netstream.packing", "Base64", "public final static int NO_OPTIONS = 0;" ], [ "ENCODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ENCODE = 1;" ], [ "DECODE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DECODE = 0;" ], [ "GZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int GZIP = 2;" ], [ "DONT_GUNZIP", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DONT_GUNZIP = 4;" ], [ "DO_BREAK_LINES", "org.graphstream.stream.netstream.packing", "Base64", "public final static int DO_BREAK_LINES = 8;" ], [ "URL_SAFE", "org.graphstream.stream.netstream.packing", "Base64", "public final static int URL_SAFE = 16;" ], [ "ORDERED", "org.graphstream.stream.netstream.packing", "Base64", "public final static int ORDERED = 32;" ], [ "INITIAL_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final int INITIAL_EDGE_CAPACITY;" ], [ "GROWTH_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final double GROWTH_FACTOR = 1.1;" ], [ "I_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char I_EDGE = 0;" ], [ "IO_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char IO_EDGE = 1;" ], [ "O_EDGE", "org.graphstream.graph.implementations", "AdjacencyListNode", "protected static final char O_EDGE = 2;" ], [ "GROW_FACTOR", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final double GROW_FACTOR = 1.1;" ], [ "DEFAULT_NODE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_NODE_CAPACITY = 128;" ], [ "DEFAULT_EDGE_CAPACITY", "org.graphstream.graph.implementations", "AdjacencyListGraph", "public static final int DEFAULT_EDGE_CAPACITY = 1024;" ] ],
  "tokensMethodJavadocValues" : [ [ "1", "int" ] ],
  "tokensMethodArguments" : [ [ "id", "java.lang", "String" ], [ "fromIndex", "", "int" ], [ "toIndex", "", "int" ], [ "directed", "", "boolean" ] ],
  "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods" : [ [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String node1, String node2) throws IdAlreadyInUseException, ElementNotFoundException, EdgeRejectedException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, String from, String to, boolean directed) throws IdAlreadyInUseException, ElementNotFoundException" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0)" ], [ "getStep", "org.graphstream.graph", "Graph", "double getStep()" ], [ "getIndex", "org.graphstream.graph", "Element", "public abstract int getIndex()" ], [ "hasArray", "org.graphstream.graph", "Element", "public abstract boolean hasArray(String arg0)" ], [ "hasVector", "org.graphstream.graph", "Element", "public abstract boolean hasVector(String arg0)" ], [ "getNodeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getNodeSet()" ], [ "hasAttribute", "org.graphstream.graph", "Element", "public abstract boolean hasAttribute(String arg0, Class<?> arg1)" ], [ "nodeFactory", "org.graphstream.graph", "Graph", "NodeFactory<? extends Node> nodeFactory()" ], [ "getEdgeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getEdgeIterator()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String id) throws ElementNotFoundException" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(String[] arg0)" ], [ "nullAttributesAreErrors", "org.graphstream.graph", "Graph", "boolean nullAttributesAreErrors()" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node node1, Node node2) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "equals", "java.lang", "Object", "public boolean equals(Object arg0)" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display()" ], [ "getArray", "org.graphstream.graph", "Element", "public abstract Object[] getArray(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Node node1, Node node2) throws ElementNotFoundException" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(String id) throws ElementNotFoundException" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int fromIndex, int toIndex, boolean directed) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "addNode", "org.graphstream.graph", "Graph", "<T extends Node> T addNode(String id) throws IdAlreadyInUseException" ], [ "getNodeCount", "org.graphstream.graph", "Structure", "public abstract int getNodeCount()" ], [ "edgeFactory", "org.graphstream.graph", "Graph", "EdgeFactory<? extends Edge> edgeFactory()" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(Edge edge)" ], [ "isStrict", "org.graphstream.graph", "Graph", "boolean isStrict()" ], [ "getEachEdge", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachEdge()" ], [ "spliterator", "java.lang", "Iterable", "public default Spliterator<T> spliterator()" ], [ "getVector", "org.graphstream.graph", "Element", "public abstract ArrayList<? extends Number> getVector(String arg0)" ], [ "toString", "java.lang", "Object", "public String toString()" ], [ "getAttributeCount", "org.graphstream.graph", "Element", "public abstract int getAttributeCount()" ], [ "clone", "java.lang", "Object", "protected native Object clone() throws CloneNotSupportedException" ], [ "iterator", "java.lang", "Iterable", "public abstract Iterator<T> iterator()" ], [ "getId", "org.graphstream.graph", "Element", "public abstract String getId()" ], [ "elementSinks", "org.graphstream.graph", "Graph", "Iterable<ElementSink> elementSinks()" ], [ "getClass", "java.lang", "Object", "public final native Class<? extends Object> getClass()" ], [ "hasNumber", "org.graphstream.graph", "Element", "public abstract boolean hasNumber(String arg0)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(String from, String to) throws ElementNotFoundException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0, Class<T> arg1)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(int index) throws IndexOutOfBoundsException" ], [ "getEachNode", "org.graphstream.graph", "Structure", "public abstract <T> Iterable<? extends T> getEachNode()" ], [ "getFirstAttributeOf", "org.graphstream.graph", "Element", "public abstract transient <T> T getFirstAttributeOf(Class<T> arg0, String[] arg1)" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int fromIndex, int toIndex) throws IndexOutOfBoundsException, ElementNotFoundException" ], [ "hashCode", "java.lang", "Object", "public native int hashCode()" ], [ "getNodeIterator", "org.graphstream.graph", "Structure", "public abstract <T> Iterator<T> getNodeIterator()" ], [ "attributeSinks", "org.graphstream.graph", "Graph", "Iterable<AttributeSink> attributeSinks()" ], [ "getAttributeKeySet", "org.graphstream.graph", "Element", "public abstract Collection<String> getAttributeKeySet()" ], [ "isAutoCreationEnabled", "org.graphstream.graph", "Graph", "boolean isAutoCreationEnabled()" ], [ "getAttributeKeyIterator", "org.graphstream.graph", "Element", "public abstract Iterator<String> getAttributeKeyIterator()" ], [ "display", "org.graphstream.graph", "Graph", "Viewer display(boolean autoLayout)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, Node from, Node to, boolean directed) throws IdAlreadyInUseException, EdgeRejectedException" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(String id)" ], [ "addEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T addEdge(String id, int index1, int index2) throws IndexOutOfBoundsException, IdAlreadyInUseException, EdgeRejectedException" ], [ "removeEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T removeEdge(int index) throws IndexOutOfBoundsException" ], [ "getAttribute", "org.graphstream.graph", "Element", "public abstract <T> T getAttribute(String arg0)" ], [ "removeNode", "org.graphstream.graph", "Graph", "<T extends Node> T removeNode(Node node)" ], [ "getEachAttributeKey", "org.graphstream.graph", "Element", "public abstract Iterable<String> getEachAttributeKey()" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(int index) throws IndexOutOfBoundsException" ], [ "getNumber", "org.graphstream.graph", "Element", "public abstract double getNumber(String arg0)" ], [ "hasHash", "org.graphstream.graph", "Element", "public abstract boolean hasHash(String arg0)" ], [ "getEdgeCount", "org.graphstream.graph", "Structure", "public abstract int getEdgeCount()" ], [ "getEdge", "org.graphstream.graph", "Graph", "<T extends Edge> T getEdge(int index) throws IndexOutOfBoundsException" ], [ "getNode", "org.graphstream.graph", "Graph", "<T extends Node> T getNode(String id)" ], [ "getEdgeSet", "org.graphstream.graph", "Structure", "public abstract <T> Collection<T> getEdgeSet()" ], [ "getHash", "org.graphstream.graph", "Element", "public abstract HashMap<?, ?> getHash(String arg0)" ], [ "getLabel", "org.graphstream.graph", "Element", "public abstract CharSequence getLabel(String arg0)" ], [ "hasLabel", "org.graphstream.graph", "Element", "public abstract boolean hasLabel(String arg0)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(int arg0, String arg1, int arg2, int arg3)" ], [ "formatted", "java.lang", "String", "public String formatted(Object[] arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0, int arg1)" ], [ "toString", "java.lang", "String", "public String toString()" ], [ "codePoints", "java.lang", "String", "public IntStream codePoints()" ], [ "equalsIgnoreCase", "java.lang", "String", "public boolean equalsIgnoreCase(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0, int arg1)" ], [ "concat", "java.lang", "String", "public String concat(String arg0)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase()" ], [ "replaceAll", "java.lang", "String", "public String replaceAll(String arg0, String arg1)" ], [ "hashCode", "java.lang", "String", "public int hashCode()" ], [ "equals", "java.lang", "String", "public boolean equals(Object arg0)" ], [ "repeat", "java.lang", "String", "public String repeat(int arg0)" ], [ "replaceFirst", "java.lang", "String", "public String replaceFirst(String arg0, String arg1)" ], [ "toLowerCase", "java.lang", "String", "public String toLowerCase(Locale arg0)" ], [ "replace", "java.lang", "String", "public String replace(CharSequence arg0, CharSequence arg1)" ], [ "length", "java.lang", "String", "public int length()" ], [ "stripTrailing", "java.lang", "String", "public String stripTrailing()" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0, int arg1)" ], [ "coder", "java.lang", "String", "byte coder()" ], [ "lines", "java.lang", "String", "public Stream<String> lines()" ], [ "replace", "java.lang", "String", "public String replace(char arg0, char arg1)" ], [ "toCharArray", "java.lang", "String", "public char[] toCharArray()" ], [ "offsetByCodePoints", "java.lang", "String", "public int offsetByCodePoints(int arg0, int arg1)" ], [ "compareTo", "java.lang", "String", "public int compareTo(String arg0)" ], [ "substring", "java.lang", "String", "public String substring(int arg0)" ], [ "trim", "java.lang", "String", "public String trim()" ], [ "contains", "java.lang", "String", "public boolean contains(CharSequence arg0)" ], [ "compareToIgnoreCase", "java.lang", "String", "public int compareToIgnoreCase(String arg0)" ], [ "split", "java.lang", "String", "public String[] split(String arg0)" ], [ "isEmpty", "java.lang", "String", "public boolean isEmpty()" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0)" ], [ "startsWith", "java.lang", "String", "public boolean startsWith(String arg0, int arg1)" ], [ "codePointCount", "java.lang", "String", "public int codePointCount(int arg0, int arg1)" ], [ "regionMatches", "java.lang", "String", "public boolean regionMatches(boolean arg0, int arg1, String arg2, int arg3, int arg4)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(Charset arg0)" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes(String arg0) throws UnsupportedEncodingException" ], [ "charAt", "java.lang", "String", "public char charAt(int arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0)" ], [ "chars", "java.lang", "String", "public IntStream chars()" ], [ "resolveConstantDesc", "java.lang", "String", "public String resolveConstantDesc(MethodHandles.Lookup arg0)" ], [ "intern", "java.lang", "String", "public native String intern()" ], [ "endsWith", "java.lang", "String", "public boolean endsWith(String arg0)" ], [ "codePointAt", "java.lang", "String", "public int codePointAt(int arg0)" ], [ "codePointBefore", "java.lang", "String", "public int codePointBefore(int arg0)" ], [ "subSequence", "java.lang", "String", "public CharSequence subSequence(int arg0, int arg1)" ], [ "translateEscapes", "java.lang", "String", "public String translateEscapes()" ], [ "indexOf", "java.lang", "String", "public int indexOf(String arg0)" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(int arg0, int arg1)" ], [ "strip", "java.lang", "String", "public String strip()" ], [ "getBytes", "java.lang", "String", "public byte[] getBytes()" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(CharSequence arg0)" ], [ "isLatin1", "java.lang", "String", "boolean isLatin1()" ], [ "lastIndexOf", "java.lang", "String", "public int lastIndexOf(String arg0)" ], [ "contentEquals", "java.lang", "String", "public boolean contentEquals(StringBuffer arg0)" ], [ "toUpperCase", "java.lang", "String", "public String toUpperCase(Locale arg0)" ], [ "indexOf", "java.lang", "String", "public int indexOf(int arg0, int arg1)" ], [ "matches", "java.lang", "String", "public boolean matches(String arg0)" ], [ "value", "java.lang", "String", "byte[] value()" ], [ "split", "java.lang", "String", "public String[] split(String arg0, int arg1)" ], [ "stripIndent", "java.lang", "String", "public String stripIndent()" ], [ "indent", "java.lang", "String", "public String indent(int arg0)" ], [ "transform", "java.lang", "String", "public <R> R transform(Function<? super String, ? extends R> arg0)" ], [ "describeConstable", "java.lang", "String", "public Optional<String> describeConstable()" ], [ "stripLeading", "java.lang", "String", "public String stripLeading()" ], [ "isBlank", "java.lang", "String", "public boolean isBlank()" ], [ "compareTo", "java.lang", "Comparable", "public abstract int compareTo(T arg0)" ], [ "toString", "java.lang", "CharSequence", "public abstract String toString()" ], [ "charAt", "java.lang", "CharSequence", "public abstract char charAt(int arg0)" ], [ "subSequence", "java.lang", "CharSequence", "public abstract CharSequence subSequence(int arg0, int arg1)" ], [ "chars", "java.lang", "CharSequence", "public default IntStream chars()" ], [ "isEmpty", "java.lang", "CharSequence", "public default boolean isEmpty()" ], [ "length", "java.lang", "CharSequence", "public abstract int length()" ], [ "codePoints", "java.lang", "CharSequence", "public default IntStream codePoints()" ], [ "describeConstable", "java.lang.constant", "Constable", "public abstract Optional<? extends ConstantDesc> describeConstable()" ], [ "resolveConstantDesc", "java.lang.constant", "ConstantDesc", "public abstract Object resolveConstantDesc(MethodHandles.Lookup arg0) throws ReflectiveOperationException" ] ],
  "tokensMethodVariablesNonPrivateNonStaticAttributes" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods" : [ ],
  "tokensOracleVariablesNonPrivateNonStaticAttributes" : [ ]
} ]